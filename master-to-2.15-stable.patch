diff --git a/.evergreen/config-atlas.yml b/.evergreen/config-atlas.yml
index 749bcf605..1e3a2942e 100644
--- a/.evergreen/config-atlas.yml
+++ b/.evergreen/config-atlas.yml
@@ -506,10 +506,6 @@ axes:
         display_name: Sharded
         variables:
           TOPOLOGY: sharded-cluster
-      - id: "load-balanced"
-        display_name: Load Balanced
-        variables:
-          TOPOLOGY: load-balanced
 
   - id: "single-mongos"
     display_name: Single Mongos
diff --git a/.evergreen/config.yml b/.evergreen/config.yml
index 4cc26204a..489443622 100644
--- a/.evergreen/config.yml
+++ b/.evergreen/config.yml
@@ -542,10 +542,6 @@ axes:
         display_name: Sharded
         variables:
           TOPOLOGY: sharded-cluster
-      - id: "load-balanced"
-        display_name: Load Balanced
-        variables:
-          TOPOLOGY: load-balanced
 
   - id: "single-mongos"
     display_name: Single Mongos
@@ -850,7 +846,6 @@ axes:
           API_VERSION_REQUIRED: 1
       - id: no
         display_name: No
-
 buildvariants:
   - matrix_name: "docker"
     matrix_spec:
@@ -879,7 +874,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-2.7", "ruby-2.3"]
       mongodb-version: ['4.2']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -890,7 +885,7 @@ buildvariants:
       auth-and-ssl: ["noauth-and-ssl", "auth-and-nossl"]
       ruby: "ruby-2.6"
       mongodb-version: ['4.0']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: rhel70
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -901,7 +896,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.5"
       mongodb-version: ['3.6']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -912,7 +907,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.4"
       mongodb-version: ['3.4']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -923,7 +918,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.3"
       mongodb-version: ['3.2']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -934,7 +929,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-2.7"]
       mongodb-version: ['3.0']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1404
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -945,7 +940,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.6"
       mongodb-version: ['2.6']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1404
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -956,7 +951,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-3.0", "ruby-2.7"]
       mongodb-version: '4.4'
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -967,24 +962,12 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-2.7"]
       mongodb-version: '5.0'
-      topology: '*'
+      topology: "*"
       os: ubuntu1804
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
       - name: "test-mlaunch"
 
-  - matrix_name: "single-lb"
-    matrix_spec:
-      auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
-      ruby: ["ruby-2.7"]
-      mongodb-version: '5.0'
-      topology: load-balanced
-      single-mongos: single-mongos
-      os: ubuntu1804
-    display_name: "${mongodb-version} ${topology} single-lb ${auth-and-ssl} ${ruby}"
-    tasks:
-      - name: "test-mlaunch"
-
   - matrix_name: "mongo-5.0-api-version"
     matrix_spec:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
@@ -1014,7 +997,7 @@ buildvariants:
       retry-reads: no-retry-reads
       ruby: "ruby-2.6"
       mongodb-version: ["4.0"]
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${retry-reads} ${ruby}"
     tasks:
@@ -1035,31 +1018,18 @@ buildvariants:
     matrix_spec:
       ruby: "ruby-2.5"
       mongodb-version: ['3.4', '3.6', '4.0']
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: '*'
       storage-engine: mmapv1
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} mmapv1 ${ruby}"
     tasks:
       - name: "test-mlaunch"
 
-  # TODO remove this configuration when 5.0 final ships and just leave
-  # the lint-5.0 one.
   - matrix_name: "lint"
     matrix_spec:
       lint: on
       ruby: "ruby-2.7"
       mongodb-version: ["4.4"]
-      topology: ["standalone", "replica-set", "sharded-cluster"]
-      os: ubuntu1804
-    display_name: "${mongodb-version} ${topology} ${lint} ${ruby}"
-    tasks:
-      - name: "test-mlaunch"
-
-  - matrix_name: "lint-5.0"
-    matrix_spec:
-      lint: on
-      ruby: "ruby-2.7"
-      mongodb-version: ["5.0"]
       topology: '*'
       os: ubuntu1804
     display_name: "${mongodb-version} ${topology} ${lint} ${ruby}"
@@ -1071,7 +1041,7 @@ buildvariants:
       fork: on
       ruby: ["ruby-3.0", "ruby-2.7"]
       mongodb-version: ["4.4"]
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: '*'
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} fork ${ruby}"
     tasks:
@@ -1082,7 +1052,7 @@ buildvariants:
       solo: on
       ruby: [ruby-3.0, ruby-2.7, ruby-2.6, ruby-2.5, ruby-2.4, ruby-2.3, jruby-9.2]
       mongodb-version: ["4.4"]
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: '*'
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} solo ${ruby}"
     tasks:
@@ -1137,7 +1107,7 @@ buildvariants:
       auth-and-ssl: "auth-and-ssl"
       ruby: "jruby-9.2"
       mongodb-version: "4.2"
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: rhel70
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -1148,7 +1118,7 @@ buildvariants:
       auth-and-ssl: "noauth-and-nossl"
       ruby: "jruby-9.2"
       mongodb-version: "2.6"
-      topology: ["standalone", "replica-set", "sharded-cluster"]
+      topology: "*"
       os: rhel62
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
diff --git a/.evergreen/config/axes.yml.erb b/.evergreen/config/axes.yml.erb
index 8e321e8f9..9fada1315 100644
--- a/.evergreen/config/axes.yml.erb
+++ b/.evergreen/config/axes.yml.erb
@@ -77,10 +77,6 @@ axes:
         display_name: Sharded
         variables:
           TOPOLOGY: sharded-cluster
-      - id: "load-balanced"
-        display_name: Load Balanced
-        variables:
-          TOPOLOGY: load-balanced
 
   - id: "single-mongos"
     display_name: Single Mongos
diff --git a/.evergreen/config/standard.yml.erb b/.evergreen/config/standard.yml.erb
index ad2673b98..73450f62b 100644
--- a/.evergreen/config/standard.yml.erb
+++ b/.evergreen/config/standard.yml.erb
@@ -1,5 +1,3 @@
-<% tt = %w(standalone replica-set sharded-cluster) %>
-
 buildvariants:
   - matrix_name: "docker"
     matrix_spec:
@@ -28,7 +26,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-2.7", "ruby-2.3"]
       mongodb-version: ['4.2']
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -39,7 +37,7 @@ buildvariants:
       auth-and-ssl: ["noauth-and-ssl", "auth-and-nossl"]
       ruby: "ruby-2.6"
       mongodb-version: ['4.0']
-      topology: <%= tt %>
+      topology: "*"
       os: rhel70
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -50,7 +48,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.5"
       mongodb-version: ['3.6']
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -61,7 +59,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.4"
       mongodb-version: ['3.4']
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -72,7 +70,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.3"
       mongodb-version: ['3.2']
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -83,7 +81,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-2.7"]
       mongodb-version: ['3.0']
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1404
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -94,7 +92,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: "ruby-2.6"
       mongodb-version: ['2.6']
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1404
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -105,7 +103,7 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-3.0", "ruby-2.7"]
       mongodb-version: '4.4'
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -116,24 +114,12 @@ buildvariants:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
       ruby: ["ruby-2.7"]
       mongodb-version: '5.0'
-      topology: '*'
+      topology: "*"
       os: ubuntu1804
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
       - name: "test-mlaunch"
 
-  - matrix_name: "single-lb"
-    matrix_spec:
-      auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
-      ruby: ["ruby-2.7"]
-      mongodb-version: '5.0'
-      topology: load-balanced
-      single-mongos: single-mongos
-      os: ubuntu1804
-    display_name: "${mongodb-version} ${topology} single-lb ${auth-and-ssl} ${ruby}"
-    tasks:
-      - name: "test-mlaunch"
-
   - matrix_name: "mongo-5.0-api-version"
     matrix_spec:
       auth-and-ssl: ["auth-and-ssl", "noauth-and-nossl"]
@@ -163,7 +149,7 @@ buildvariants:
       retry-reads: no-retry-reads
       ruby: "ruby-2.6"
       mongodb-version: ["4.0"]
-      topology: <%= tt %>
+      topology: "*"
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} ${retry-reads} ${ruby}"
     tasks:
@@ -184,31 +170,18 @@ buildvariants:
     matrix_spec:
       ruby: "ruby-2.5"
       mongodb-version: ['3.4', '3.6', '4.0']
-      topology: <%= tt %>
+      topology: '*'
       storage-engine: mmapv1
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} mmapv1 ${ruby}"
     tasks:
       - name: "test-mlaunch"
 
-  # TODO remove this configuration when 5.0 final ships and just leave
-  # the lint-5.0 one.
   - matrix_name: "lint"
     matrix_spec:
       lint: on
       ruby: "ruby-2.7"
       mongodb-version: ["4.4"]
-      topology: <%= tt %>
-      os: ubuntu1804
-    display_name: "${mongodb-version} ${topology} ${lint} ${ruby}"
-    tasks:
-      - name: "test-mlaunch"
-
-  - matrix_name: "lint-5.0"
-    matrix_spec:
-      lint: on
-      ruby: "ruby-2.7"
-      mongodb-version: ["5.0"]
       topology: '*'
       os: ubuntu1804
     display_name: "${mongodb-version} ${topology} ${lint} ${ruby}"
@@ -220,7 +193,7 @@ buildvariants:
       fork: on
       ruby: ["ruby-3.0", "ruby-2.7"]
       mongodb-version: ["4.4"]
-      topology: <%= tt %>
+      topology: '*'
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} fork ${ruby}"
     tasks:
@@ -231,7 +204,7 @@ buildvariants:
       solo: on
       ruby: [ruby-3.0, ruby-2.7, ruby-2.6, ruby-2.5, ruby-2.4, ruby-2.3, jruby-9.2]
       mongodb-version: ["4.4"]
-      topology: <%= tt %>
+      topology: '*'
       os: ubuntu1604
     display_name: "${mongodb-version} ${topology} solo ${ruby}"
     tasks:
@@ -286,7 +259,7 @@ buildvariants:
       auth-and-ssl: "auth-and-ssl"
       ruby: "jruby-9.2"
       mongodb-version: "4.2"
-      topology: <%= tt %>
+      topology: "*"
       os: rhel70
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
@@ -297,7 +270,7 @@ buildvariants:
       auth-and-ssl: "noauth-and-nossl"
       ruby: "jruby-9.2"
       mongodb-version: "2.6"
-      topology: <%= tt %>
+      topology: "*"
       os: rhel62
     display_name: "${mongodb-version} ${topology} ${auth-and-ssl} ${ruby}"
     tasks:
diff --git a/.evergreen/run-tests.sh b/.evergreen/run-tests.sh
index deaab7dfb..0d3272cee 100755
--- a/.evergreen/run-tests.sh
+++ b/.evergreen/run-tests.sh
@@ -10,11 +10,9 @@ else
   set -x
 fi
 
-MRSS_ROOT=`dirname "$0"`/../spec/shared
-
-. $MRSS_ROOT/shlib/distro.sh
-. $MRSS_ROOT/shlib/set_env.sh
-. $MRSS_ROOT/shlib/server.sh
+. `dirname "$0"`/../spec/shared/shlib/distro.sh
+. `dirname "$0"`/../spec/shared/shlib/set_env.sh
+. `dirname "$0"`/../spec/shared/shlib/server.sh
 . `dirname "$0"`/functions.sh
 . `dirname "$0"`/functions-aws.sh
 . `dirname "$0"`/functions-config.sh
diff --git a/docs/reference/create-client.txt b/docs/reference/create-client.txt
index 56a69df19..9c61db567 100644
--- a/docs/reference/create-client.txt
+++ b/docs/reference/create-client.txt
@@ -111,43 +111,23 @@ their stated purposes:
 Connection Types
 ================
 
-The driver will, by default, discover the type of deployment it is instructed
-to connect to (except for load-balanced deployments)
-and behave in the manner that matches the deployment type.
-The subsections below describe how the driver behaves in each of the deployment
-types as well as how to force particular behavior, bypassing automatic
-deployment type detection.
-
-Note that the detection of deployment type happens when the driver receives
-the first reply from any of the servers it is instructed to connect to
-(unless the load-balancing mode is requested, see below). The driver will
-remain in the discovered or configured topology even if the underlying
-deployment is replaced by one of a different type. In particular, when
-replacing a replica set with a sharded cluster at the same address
-the client instance must be recreated (such as by restarting the application)
-for it to communicate with the sharded cluster.
-
-Automatic discovery of load-balanced deployments is currently not supported.
-Load-balanced deployments will be treated as deployments of their underlying
-type, which would generally be sharded clusters. The driver will fail to
-correctly operate when treating a load-balanced deployment as a sharded
-cluster, therefore when the deployment is a load-balanced one the client
-must be explicitly configured to :ref:`connect to a load balancer
-<load-balancer-connection>`.
-
-
-Standalone Server Connection
-----------------------------
+Direct Connection
+-----------------
 
-If the deployment is a single server, also known as a standalone deployment,
-all operations will be directed to the specified server.
+If the deployment is a replica set, the driver will by default discover all
+members of the replica set given the address of any one member, and will
+dispatch operations to the appropriate member (for example, writes would be
+dispatched to the primary).
+
+To force all operations to be performed on the designated server, specify the
+``direct_connection`` option:
+
+.. code-block:: ruby
 
-If the server is shut down and replaced by a replica set node, the driver
-will continue sending all operations to that node, even if the node is or
-becomes a secondary.
+  Mongo::Client.new([ '1.2.3.4:27017' ], database: 'mydb', direct_connection: true)
 
-To force a standalone connection, see the :ref:`direct connection
-<direct-connection>` section below.
+  # Or using the URI syntax:
+  Mongo::Client.new("mongodb://1.2.3.4:27017/mydb?directConnection=true")
 
 
 .. _connect-replica-set:
@@ -155,184 +135,63 @@ To force a standalone connection, see the :ref:`direct connection
 Replica Set Connection
 ----------------------
 
-When connecting to a :manual:`replica set</replication/>`, it is sufficient
-to pass the address of any node in the replica set to the driver.
-The node does not have to be the primary and it may be a hidden node.
-The driver will then automatically discover the remaining nodes.
-
-However, it is recommended to specify all nodes that are part of the
-replica set, so that in the event of one or more nodes being unavailable
-(for example, due to maintenance or reconfiguration) the driver can still
-connect to the replica set.
-
-Replica set connection examples:
+To connect to a :manual:`replica set</replication/>` deployment managed by a
+service providing SRV URIs (such as MongoDB Atlas), connect to the URI:
 
 .. code-block:: ruby
 
-  Mongo::Client.new([ '127.0.0.1:27017' ], database: 'mydb')
-
-  Mongo::Client.new([ '127.0.0.1:27017', '127.0.0.1:27018' ], database: 'mydb')
-
-  # Or using the URI syntax:
-  Mongo::Client.new("mongodb://127.0.0.1:27017,127.0.0.1:27018/mydb")
+  Mongo::Client.new("mongodb+srv://username:myRealPassword@cluster0.mongodb.net/test?w=majority")
 
-To make the driver verify the replica set name upon connection, pass it using
-the ``replica_set`` Ruby option or the ``replicaSet`` URI option:
+If not using SRV URIs, it is sufficient to pass the address of any node in the
+replica set to the driver; the driver will then automatically discover the
+remaining nodes. However, it is recommended to specify all nodes that are part
+of the replica set, so that in the event of one or more nodes being unavailable
+(for example, due to maintenance or reconfiguration) the driver can still
+connect to the replica set.
 
 .. code-block:: ruby
 
   Mongo::Client.new([ '127.0.0.1:27017', '127.0.0.1:27018' ],
-    database: 'mydb', replica_set: 'myapp')
+    :database => 'mydb', replica_set: 'myapp')
 
   # Or using the URI syntax:
   Mongo::Client.new("mongodb://127.0.0.1:27017,127.0.0.1:27018/mydb?replicaSet=myapp")
 
-If the deployment is not a replica set or uses a different replica set name,
-all operations will fail (until the expected replica set is returned by
-the servers).
-
-It is also possible to force a replica set connection without specifying
-the replica set name. Doing so is generally unnecessary and is deprecated:
-
-.. code-block:: ruby
-
-  Mongo::Client.new([ '127.0.0.1:27017', '127.0.0.1:27018' ],
-    database: 'mydb', connect: :replica_set)
-
-  # Or using the URI syntax:
-  Mongo::Client.new("mongodb://127.0.0.1:27017,127.0.0.1:27018/mydb?connect=replica_set")
-
-To connect to a MongoDB Atlas cluster which is deployed as a replica set,
-connect to the URI:
-
-.. code-block:: ruby
-
-  Mongo::Client.new("mongodb+srv://username:myRealPassword@cluster0.mongodb.net/test?w=majority")
-
-Please review the :ref:`SRV URI notes <srv-uri-notes>` if using SRV URIs.
-
 
 .. _connect-sharded-cluster:
 
 Sharded Cluster Connection
 --------------------------
 
-To connect to a :manual:`sharded cluster</sharding/>` deployment, specify
-the addresses of the ``mongos`` routers:
-
-.. code-block:: ruby
-
-  Mongo::Client.new([ '1.2.3.4:27017', '1.2.3.5:27017' ], database: 'mydb')
-
-  Mongo::Client.new("mongodb://1.2.3.4:27017,1.2.3.5:27017/mydb")
-
-Note that unlike a replica set connection, you may choose to connect to a
-subset of the ``mongos`` routers that exist in the deployment. The driver
-will monitor each router and will use the ones that are available
-(i.e., the driver will generally handle individual routers becoming
-unavailable due to failures or maintenance). When specifying the list of
-routers explicitly, the driver will not discover remaining routers that
-may be configured and will not attempt to connect to them.
-
-The driver will automatically balance the operation load among the routers
-it is aware of. 
-
-To connect to a MongoDB Atlas cluster which is deployed as a sharded cluster,
-connect to the URI:
+To connect to a :manual:`sharded cluster</sharding/>` deployment managed by a
+service providing SRV URIs (such as MongoDB Atlas), connect to the URI:
 
 .. code-block:: ruby
 
   Mongo::Client.new("mongodb+srv://username:myRealPassword@cluster0.mongodb.net/test?w=majority")
 
-When the driver connects to a sharded cluster via an SRV URI, it will
-periodically poll the SRV records of the address specified in the URI
-for changes and will automatically add and remove the ``mongos`` hosts
-to/from its list of servers as they are added and removed to/from the
-sharded cluster.
+When the driver connects to a sharded cluster via an SRV URI, it will monitor
+the SRV records of the address specified in the URI for changes and will
+automatically add and remove ``mongos`` hosts to/from its list of servers as
+they are added and removed to/from the sharded cluster.
 
-To force a sharded cluster connection, use the ``connect: :sharded``
-option. Doing so is generally unnecessary and is deprecated:
+If not using SRV URIs, pass the addresses of one or more
+:manual:`mongos</reference/program/mongos/>` hosts. Unlike with
+replica set deployments, the driver is not able to discover all ``mongos``
+nodes in a sharded cluster when not using SRV URIs. It is not required that all
+``mongos`` node addresses are given to the driver - the driver will balance
+the operation load among the nodes it is given. Specifying more nodes will
+spread the operation load accordingly.
 
 .. code-block:: ruby
 
-  Mongo::Client.new([ '127.0.0.1:27017', '127.0.0.1:27018' ],
-    database: 'mydb', connect: :sharded)
-
-  # Or using the URI syntax:
-  Mongo::Client.new("mongodb://127.0.0.1:27017,127.0.0.1:27018/mydb?connect=sharded")
-
-Please review the :ref:`SRV URI notes <srv-uri-notes>` if using SRV URIs.
-
-
-.. _direct-connection:
-
-Direct Connection
------------------
-
-To disable the deployment type discovery and force all operations to be
-performed on a particular server, specify the ``direct_connection`` option:
-
-.. code-block:: ruby
-
-  Mongo::Client.new([ '1.2.3.4:27017' ], database: 'mydb', direct_connection: true)
-
-  # Or using the URI syntax:
-  Mongo::Client.new("mongodb://1.2.3.4:27017/mydb?directConnection=true")
-
-Alternatively, the deprecated ``connect: :direct`` option is equivalent:
-
-.. code-block:: ruby
-
-  Mongo::Client.new([ '1.2.3.4:27017' ], database: 'mydb', connect: :direct)
-
-  # Or using the URI syntax:
-  Mongo::Client.new("mongodb://1.2.3.4:27017/mydb?connect=direct")
-
-The direct connection mode is most useful for performing operations on a
-particular replica set node, although it also permits the underlying server
-to change type (e.g. from a replica set node to a ``mongos`` router, or vice
-versa).
-
-
-.. _load-balancer-connection:
-
-Load Balancer Connection
-------------------------
-
-Unlike other deployment types, the driver does not currently automatically
-detect a load-balanced deployment.
-
-To connect to a load balancer, specify the ``load_balanced: true`` Ruby option
-or the ``loadBalanced=true`` URI option:
-
-.. code-block:: ruby
-
-  Mongo::Client.new([ '1.2.3.4:27017' ], database: 'mydb', load_balanced: true)
-
-  # Or using the URI syntax:
-  Mongo::Client.new("mongodb://1.2.3.4:27017/mydb?loadBalanced=true")
-
-When using these options, if the specified server is not a load balancer,
-the client will fail all operations (until the server becomes a load balancer).
-
-To treat the server as a load balancer even if it doesn't identify as such,
-use the ``connect: :load_balanced`` Ruby option or the ``connect=load_balanced``
-URI option:
-
-.. code-block:: ruby
-
-  Mongo::Client.new([ '1.2.3.4:27017' ],
-    database: 'mydb', load_balanced: true, connect: :load_balanced)
-
-  # Or using the URI syntax:
-  Mongo::Client.new("mongodb://1.2.3.4:27017/mydb?loadBalanced=true&connect=load_balanced")
-
+  Mongo::Client.new([ '1.2.3.4:27017', '1.2.3.5:27017' ], :database => 'mydb')
 
+  Mongo::Client.new("mongodb://1.2.3.4:27017,1.2.3.5:27017/mydb")
 
-.. _srv-uri-notes:
 
-SRV URI Notes
-=============
+SRV URIs
+========
 
 When the driver connects to a
 :manual:`mongodb+srv protocol <reference/connection-string/#dns-seedlist-connection-format>`
@@ -350,18 +209,7 @@ URI, keep in mind the following:
 2. The driver looks up URI options in the DNS TXT records corresponding to the
    SRV records. These options can be overridden by URI options specified in the
    URI and by Ruby options, in this order.
-3. Because the URI options are retrieved in a separate DNS query from the
-   SRV lookup, in environments with unreliable network connectivity
-   the URI option query may fail when the SRV lookup succeeds. Such a failure
-   would cause the driver to use the wrong auth source leading to
-   authentication failures. This can be worked around by explicitly specifying
-   the auth source:
-
-   .. code-block:: ruby
-
-     Mongo::Client.new("mongodb+srv://username:myRealPassword@cluster0.mongodb.net/test?w=majority&authSource=admin")
-
-4. If the topology of the constructed ``Client`` object is unknown or a
+3. If the topology of the constructed ``Client`` object is unknown or a
    sharded cluster, the driver will begin monitoring the specified SRV DNS
    records for changes and will automatically update the list of servers in the
    cluster. The updates will stop if the topology becomes a single or a replica
@@ -479,11 +327,7 @@ Ruby Options
    * - ``:connect``
      - **Deprecated.** Disables deployment topology discovery normally
        performed by the dirver and forces the cluster topology to a specific
-       type. Valid values are ``:direct``, ``:load_balanced``,
-       ``:replica_set`` or ``:sharded``. If ``:load_balanced`` is used,
-       the client will behave as if it is connected to a load balancer
-       regardless of whether the server(s) it connects to advertise themselves
-       as load balancers.
+       type. Choices: ``:direct``, ``:replica_set`` or ``:sharded``.
      - ``Symbol``
      - none
 
@@ -518,11 +362,6 @@ Ruby Options
      - ``Object``
      - none
 
-   * - ``:load_balanced``
-     - Whether to expect to connect to a load balancer.
-     - ``Boolean``
-     - false
-
    * - ``:local_threshold``
      - Specifies the maximum latency in seconds between the nearest
        server and the servers that can be available for selection to operate on.
@@ -535,14 +374,7 @@ Ruby Options
      - ``Logger``
 
    * - ``:max_idle_time``
-     - The maximum time, in seconds, that a connection can be idle before it
-       is closed by the connection pool.
-       
-       *Warning:* when connected to a load balancer, the driver uses existing
-       connections for iterating cursors (which includes change streams)
-       and executing transactions. Setting an idle time via this option may
-       cause the driver to close connections that are needed for subsequent
-       operations, causing those operations to fail.
+     - The maximum seconds a socket can remain idle since it has been checked in to the pool.
      - ``Integer``
      - none
 
@@ -931,11 +763,6 @@ URI options are explained in detail in the :manual:`Connection URI reference
    * - connect=String
      - ``:connect => Symbol``
 
-       The same values that the ``:connect`` Ruby option accepts are
-       accepted here. For multi-word values, the values must be provided
-       using underscores to separate the words, i.e.
-       ``connect=replica_set`` and ``connect=load_balanced``.
-
    * - connectTimeoutMS=Integer
      - ``:connect_timeout => Float``
 
@@ -955,9 +782,6 @@ URI options are explained in detail in the :manual:`Connection URI reference
    * - journal=Boolean
      - ``{ :write_concern => { :j => true|false }}``
 
-   * - loadBalanced=Boolean
-     - ``:load_balanced => Boolean``
-
    * - localThresholdMS=Integer
      - ``:local_threshold => Float``
 
diff --git a/docs/reference/crud-operations.txt b/docs/reference/crud-operations.txt
index a242dbed3..fe7d68c21 100644
--- a/docs/reference/crud-operations.txt
+++ b/docs/reference/crud-operations.txt
@@ -260,32 +260,6 @@ when querying and their corresponding methods as examples.
          # MongoDB 2.6
          client[:artists].find.explain(verbose: true)
          
-       The explain operation supports ``:session`` and ``:read``
-       (for read preference) options. To specify these options for a single
-       explain operation, they must be given to the ``find`` method as
-       follows:
-     
-       .. code-block:: ruby
-
-         client[:artists].find({}, session: session).explain
-
-         client[:artists].find({}, read: {mode: :secondary_preferred}).explain
-       
-       If the read preference option is specified on the client or on the
-       collection, it will be passed to the explain operation:
-     
-       .. code-block:: ruby
-
-         client[:artists, read: {mode: :secondary_preferred}].find.explain
-       
-       Note that the session option is not accepted when creating a collection
-       object.
-       
-       The explain command does not support passing the read concern option.
-       If the read concern is specifed on the client or collection level, or
-       if the read concern is specified as a find option, it will NOT be passed
-       by the driver to the explain command.
-       
        .. note::
        
          The information returned by the server for the ``explain`` command
diff --git a/lib/mongo/bulk_write.rb b/lib/mongo/bulk_write.rb
index 19fe9e56f..1d742b4f5 100644
--- a/lib/mongo/bulk_write.rb
+++ b/lib/mongo/bulk_write.rb
@@ -66,7 +66,7 @@ module Mongo
           if single_statement?(operation)
             write_concern = write_concern(session)
             write_with_retry(session, write_concern) do |server, txn_num|
-              server.with_connection(service_id: context.service_id) do |connection|
+              server.with_connection do |connection|
                 execute_operation(
                   operation.keys.first,
                   operation.values.flatten,
@@ -80,7 +80,7 @@ module Mongo
             end
           else
             nro_write_with_retry(session, write_concern) do |server|
-              server.with_connection(service_id: context.service_id) do |connection|
+              server.with_connection do |connection|
                 execute_operation(
                   operation.keys.first,
                   operation.values.flatten,
diff --git a/lib/mongo/client.rb b/lib/mongo/client.rb
index 8533a176c..114e2f26c 100644
--- a/lib/mongo/client.rb
+++ b/lib/mongo/client.rb
@@ -67,7 +67,6 @@ module Mongo
       :database,
       :heartbeat_frequency,
       :id_generator,
-      :load_balanced,
       :local_threshold,
       :logger,
       :log_prefix,
@@ -244,10 +243,7 @@ module Mongo
     # @option options [ Symbol ] :connect Deprecated - use :direct_connection
     #   option instead of this option. The connection method to use. This
     #   forces the cluster to behave in the specified way instead of
-    #   auto-discovering. One of :direct, :replica_set, :sharded,
-    #   :load_balanced. If :connect is set to :load_balanced, the driver
-    #   will behave as if the server is a load balancer even if it isn't
-    #   connected to a load balancer.
+    #   auto-discovering. One of :direct, :replica_set, :sharded
     # @option options [ Float ] :connect_timeout The timeout, in seconds, to
     #   attempt a connection.
     # @option options [ String ] :database The database to connect to.
@@ -255,8 +251,6 @@ module Mongo
     #   for the server monitor to refresh its description via hello.
     # @option options [ Object ] :id_generator A custom object to generate ids
     #   for documents. Must respond to #generate.
-    # @option options [ true | false ] :load_balanced Whether to expect to
-    #   connect to a load balancer.
     # @option options [ Integer ] :local_threshold The local threshold boundary
     #   in seconds for selecting a near server for an operation.
     # @option options [ Logger ] :logger A custom logger to use.
@@ -1240,15 +1234,9 @@ module Mongo
         raise ArgumentError, "If :write and :write_concern are both given, they must be identical: #{options.inspect}"
       end
 
-      connect = options[:connect]&.to_sym
-
-      if connect && !%i(direct replica_set sharded load_balanced).include?(connect)
-        raise ArgumentError, "Invalid :connect option value: #{connect}"
-      end
-
       if options[:direct_connection]
-        if connect && connect != :direct
-          raise ArgumentError, "Conflicting client options: direct_connection=true and connect=#{connect}"
+        if options[:connect] && options[:connect].to_sym != :direct
+          raise ArgumentError, "Conflicting client options: direct_connection=true and connect=#{options[:connect]}"
         end
         # When a new client is created, we get the list of seed addresses
         if addresses && addresses.length > 1
@@ -1260,26 +1248,8 @@ module Mongo
         end
       end
 
-      if options[:load_balanced]
-        if addresses && addresses.length > 1
-          raise ArgumentError, "load_balanced=true cannot be used with multiple seeds"
-        end
-
-        if options[:direct_connection]
-          raise ArgumentError, "direct_connection=true cannot be used with load_balanced=true"
-        end
-
-        if connect && connect != :load_balanced
-          raise ArgumentError, "connect=#{connect} cannot be used with load_balanced=true"
-        end
-
-        if options[:replica_set]
-          raise ArgumentError, "load_balanced=true cannot be used with replica_set option"
-        end
-      end
-
-      if options[:direct_connection] == false && connect && connect == :direct
-        raise ArgumentError, "Conflicting client options: direct_connection=false and connect=#{connect}"
+      if options[:direct_connection] == false && options[:connect] && options[:connect].to_sym == :direct
+        raise ArgumentError, "Conflicting client options: direct_connection=false and connect=#{options[:connect]}"
       end
 
       %i(connect_timeout socket_timeout).each do |key|
diff --git a/lib/mongo/cluster.rb b/lib/mongo/cluster.rb
index ac59a25cc..c282ea528 100644
--- a/lib/mongo/cluster.rb
+++ b/lib/mongo/cluster.rb
@@ -203,7 +203,7 @@ module Mongo
       @connected = true
 
       if options[:cleanup] != false
-        @cursor_reaper = CursorReaper.new(self)
+        @cursor_reaper = CursorReaper.new
         @socket_reaper = SocketReaper.new(self)
         @periodic_executor = PeriodicExecutor.new([
           @cursor_reaper, @socket_reaper,
@@ -212,56 +212,54 @@ module Mongo
         @periodic_executor.run!
       end
 
-      unless load_balanced?
-        # Need to record start time prior to starting monitoring
-        start_monotime = Utils.monotonic_time
+      # Need to record start time prior to starting monitoring
+      start_monotime = Utils.monotonic_time
 
-        servers.each do |server|
-          server.start_monitoring
-        end
+      servers.each do |server|
+        server.start_monitoring
+      end
 
-        if options[:scan] != false
-          server_selection_timeout = options[:server_selection_timeout] || ServerSelector::SERVER_SELECTION_TIMEOUT
-          # The server selection timeout can be very short especially in
-          # tests, when the client waits for a synchronous scan before
-          # starting server selection. Limiting the scan to server selection time
-          # then aborts the scan before it can process even local servers.
-          # Therefore, allow at least 3 seconds for the scan here.
-          if server_selection_timeout < 3
-            server_selection_timeout = 3
+      if options[:scan] != false
+        server_selection_timeout = options[:server_selection_timeout] || ServerSelector::SERVER_SELECTION_TIMEOUT
+        # The server selection timeout can be very short especially in
+        # tests, when the client waits for a synchronous scan before
+        # starting server selection. Limiting the scan to server selection time
+        # then aborts the scan before it can process even local servers.
+        # Therefore, allow at least 3 seconds for the scan here.
+        if server_selection_timeout < 3
+          server_selection_timeout = 3
+        end
+        deadline = start_monotime + server_selection_timeout
+        # Wait for the first scan of each server to complete, for
+        # backwards compatibility.
+        # If any servers are discovered during this SDAM round we are going to
+        # wait for these servers to also be queried, and so on, up to the
+        # server selection timeout or the 3 second minimum.
+        loop do
+          # Ensure we do not try to read the servers list while SDAM is running
+          servers = @sdam_flow_lock.synchronize do
+            servers_list.dup
           end
-          deadline = start_monotime + server_selection_timeout
-          # Wait for the first scan of each server to complete, for
-          # backwards compatibility.
-          # If any servers are discovered during this SDAM round we are going to
-          # wait for these servers to also be queried, and so on, up to the
-          # server selection timeout or the 3 second minimum.
-          loop do
-            # Ensure we do not try to read the servers list while SDAM is running
-            servers = @sdam_flow_lock.synchronize do
-              servers_list.dup
-            end
-            if servers.all? { |server| server.last_scan_monotime && server.last_scan_monotime >= start_monotime }
-              break
-            end
-            if (time_remaining = deadline - Utils.monotonic_time) <= 0
-              break
-            end
-            log_debug("Waiting for up to #{'%.2f' % time_remaining} seconds for servers to be scanned: #{summary}")
-            # Since the semaphore may have been signaled between us checking
-            # the servers list above and the wait call below, we should not
-            # wait for the full remaining time - wait for up to 1 second, then
-            # recheck the state.
-            begin
-              server_selection_semaphore.wait([time_remaining, 1].min)
-            rescue ::Timeout::Error
-              # nothing
-            end
+          if servers.all? { |server| server.last_scan_monotime && server.last_scan_monotime >= start_monotime }
+            break
+          end
+          if (time_remaining = deadline - Utils.monotonic_time) <= 0
+            break
+          end
+          log_debug("Waiting for up to #{'%.2f' % time_remaining} seconds for servers to be scanned: #{summary}")
+          # Since the semaphore may have been signaled between us checking
+          # the servers list above and the wait call below, we should not
+          # wait for the full remaining time - wait for up to 1 second, then
+          # recheck the state.
+          begin
+            server_selection_semaphore.wait([time_remaining, 1].min)
+          rescue ::Timeout::Error
+            # nothing
           end
         end
-
-        start_stop_srv_monitor
       end
+
+      start_stop_srv_monitor
     end
 
     # Create a cluster for the provided client, for use when we don't want the
@@ -323,14 +321,6 @@ module Mongo
     def_delegators :topology, :replica_set?, :replica_set_name, :sharded?,
                    :single?, :unknown?
 
-    # Returns whether the cluster is configured to be in the load-balanced
-    # topology.
-    #
-    # @return [ true | false ] Whether the topology is load-balanced.
-    def load_balanced?
-      topology.is_a?(Topology::LoadBalanced)
-    end
-
     [:register_cursor, :schedule_kill_cursor, :unregister_cursor].each do |m|
       define_method(m) do |*args|
         if options[:cleanup] != false
@@ -609,25 +599,9 @@ module Mongo
     #   on 4.2+ servers).
     # @option aptions [ true | false ] :awaited Whether the updated description
     #   was a result of processing an awaited hello.
-    # @option options [ Object ] :service_id Change state for the specified
-    #   service id only.
     #
     # @api private
     def run_sdam_flow(previous_desc, updated_desc, options = {})
-      if load_balanced?
-        if updated_desc.config.empty?
-          unless options[:keep_connection_pool]
-            servers_list.each do |server|
-              # TODO should service id be taken out of updated_desc?
-              # We could also assert that
-              # options[:service_id] == updated_desc.service_id
-              server.clear_connection_pool(service_id: options[:service_id])
-            end
-          end
-        end
-        return
-      end
-
       @sdam_flow_lock.synchronize do
         flow = SdamFlow.new(self, previous_desc, updated_desc,
           awaited: options[:awaited])
@@ -808,11 +782,8 @@ module Mongo
     def add(host, add_options=nil)
       address = Address.new(host, options)
       if !addresses.include?(address)
-        opts = options.merge(monitor: false)
-        if Topology::LoadBalanced === topology
-          opts[:load_balancer] = true
-        end
-        server = Server.new(address, self, @monitoring, event_listeners, opts)
+        server = Server.new(address, self, @monitoring, event_listeners, options.merge(
+          monitor: false))
         @update_lock.synchronize do
           # Need to recheck whether server is present in @servers, because
           # the previous check was not under a lock.
@@ -928,10 +899,6 @@ module Mongo
     #
     # @api private
     def validate_session_support!
-      if topology.is_a?(Topology::LoadBalanced)
-        return
-      end
-
       @state_change_lock.synchronize do
         @sdam_flow_lock.synchronize do
           if topology.data_bearing_servers?
diff --git a/lib/mongo/cluster/periodic_executor.rb b/lib/mongo/cluster/periodic_executor.rb
index e4b2df693..67d5090e9 100644
--- a/lib/mongo/cluster/periodic_executor.rb
+++ b/lib/mongo/cluster/periodic_executor.rb
@@ -36,15 +36,14 @@ module Mongo
       #
       # @example Create a PeriodicExecutor.
       #   Mongo::Cluster::PeriodicExecutor.new([reaper, reaper2])
-      #
-      # @param [ Array<Object> ] executors The executors. Each must respond
-      #   to #execute and #flush.
       # @param [ Hash ] options The options.
       #
       # @option options [ Logger ] :logger A custom logger to use.
       #
       # @api private
-      def initialize(executors, options = {})
+      #
+      # @since 2.5.0
+      def initialize(executors = [], options = {})
         @thread = nil
         @executors = executors
         @stop_semaphore = Semaphore.new
diff --git a/lib/mongo/cluster/reapers/cursor_reaper.rb b/lib/mongo/cluster/reapers/cursor_reaper.rb
index 3e2fcd387..9ea10a5a0 100644
--- a/lib/mongo/cluster/reapers/cursor_reaper.rb
+++ b/lib/mongo/cluster/reapers/cursor_reaper.rb
@@ -28,38 +28,42 @@ module Mongo
     class CursorReaper
       include Retryable
 
-      # The default time interval for the cursor reaper to send pending
-      # kill cursors operations.
+      # The default time interval for the cursor reaper to send pending kill cursors operations.
       #
       # @since 2.3.0
       FREQUENCY = 1.freeze
 
       # Create a cursor reaper.
       #
-      # @param [ Cluster ] cluster The cluster.
+      # @example Create a CursorReaper.
+      #   Mongo::Cluster::CursorReaper.new(cluster)
       #
       # @api private
-      def initialize(cluster)
-        @cluster = cluster
+      #
+      # @since 2.3.0
+      def initialize
         @to_kill = {}
-        @active_cursor_ids = Set.new
+        @active_cursors = Set.new
         @mutex = Mutex.new
       end
 
-      attr_reader :cluster
-
       # Schedule a kill cursors operation to be eventually executed.
       #
-      # @param [ Cursor::KillSpec ] kill_spec The kill specification.
-      # @param [ Mongo::Server ] server The server to send the kill cursors
-      #   operation to.
+      # @example Schedule a kill cursors operation.
+      #   cursor_reaper.schedule_kill_cursor(id, op_spec, server)
+      #
+      # @param [ Integer ] id The id of the cursor to kill.
+      # @param [ Hash ] op_spec The spec for the kill cursors op.
+      # @param [ Mongo::Server ] server The server to send the kill cursors operation to.
       #
       # @api private
-      def schedule_kill_cursor(kill_spec, server)
+      #
+      # @since 2.3.0
+      def schedule_kill_cursor(id, op_spec, server)
         @mutex.synchronize do
-          if @active_cursor_ids.include?(kill_spec.cursor_id)
-            @to_kill[server.address.seed] ||= Set.new
-            @to_kill[server.address.seed] << kill_spec
+          if @active_cursors.include?(id)
+            @to_kill[server] ||= Set.new
+            @to_kill[server] << op_spec
           end
         end
       end
@@ -83,7 +87,7 @@ module Mongo
         end
 
         @mutex.synchronize do
-          @active_cursor_ids << id
+          @active_cursors << id
         end
       end
 
@@ -106,7 +110,7 @@ module Mongo
         end
 
         @mutex.synchronize do
-          @active_cursor_ids.delete(id)
+          @active_cursors.delete(id)
         end
       end
 
@@ -119,70 +123,33 @@ module Mongo
       #
       # @since 2.3.0
       def kill_cursors
-        # TODO optimize this to batch kill cursor operations for the same
-        # server/database/collection instead of killing each cursor
-        # individually.
-
-        loop do
-          server_address_str = nil
-
-          kill_spec = @mutex.synchronize do
-            # Find a server that has any cursors scheduled for destruction.
-            server_address_str, specs =
-              @to_kill.detect { |server_address_str, specs| specs.any? }
-
-            if specs.nil?
-              # All servers have empty specs, nothing to do.
-              return
-            end
-
-            # Note that this mutates the spec in the queue.
-            # If the kill cursor operation fails, we don't attempt to
-            # kill that cursor again.
-            spec = specs.take(1).tap do |arr|
-              specs.subtract(arr)
-            end.first
-
-            unless @active_cursor_ids.include?(spec.cursor_id)
-              # The cursor was already killed, typically because it has
-              # been iterated to completion. Remove the kill spec from
-              # our records without doing any more work.
-              spec = nil
-            end
+        to_kill_copy = {}
+        active_cursors_copy = []
 
-            spec
-          end
-
-          # If there was a spec to kill but its cursor was already killed,
-          # look for another spec.
-          next unless kill_spec
-
-          # We could also pass kill_spec directly into the KillCursors
-          # operation, though this would make that operation have a
-          # different API from all of the other ones which accept hashes.
-          spec = {
-            cursor_ids: [kill_spec.cursor_id],
-            coll_name: kill_spec.coll_name,
-            db_name: kill_spec.db_name,
-          }
-          op = Operation::KillCursors.new(spec)
-
-          server = cluster.servers.detect do |server|
-            server.address.seed == server_address_str
-          end
-
-          unless server
-            # TODO We currently don't have a server for the address that the
-            # cursor is associated with. We should leave the cursor in the
-            # queue to be killed at a later time (when the server comes back).
-            next
-          end
+        @mutex.synchronize do
+          to_kill_copy = @to_kill.dup
+          active_cursors_copy = @active_cursors.dup
+          @to_kill = {}
+        end
 
+        to_kill_copy.each do |server, op_specs|
           options = {
             server_api: server.options[:server_api],
-            service_id: kill_spec.service_id,
           }
-          op.execute(server, context: Operation::Context.new(options: options))
+          context = Operation::Context.new(options: options)
+          op_specs.each do |op_spec|
+            if server.features.find_command_enabled?
+              Cursor::Builder::KillCursorsCommand.update_cursors(op_spec, active_cursors_copy.to_a)
+              if Cursor::Builder::KillCursorsCommand.get_cursors_list(op_spec).size > 0
+                Operation::KillCursors.new(op_spec).execute(server, context: context)
+              end
+            else
+              Cursor::Builder::OpKillCursors.update_cursors(op_spec, active_cursors_copy.to_a)
+              if Cursor::Builder::OpKillCursors.get_cursors_list(op_spec).size > 0
+                Operation::KillCursors.new(op_spec).execute(server, context: context)
+              end
+            end
+          end
         end
       end
       alias :execute :kill_cursors
diff --git a/lib/mongo/cluster/sdam_flow.rb b/lib/mongo/cluster/sdam_flow.rb
index 62fcd9d47..b89045598 100644
--- a/lib/mongo/cluster/sdam_flow.rb
+++ b/lib/mongo/cluster/sdam_flow.rb
@@ -105,11 +105,6 @@ class Mongo::Cluster
       end
 
       case topology
-      when Topology::LoadBalanced
-        @updated_desc = ::Mongo::Server::Description::LoadBalancer.new(
-          updated_desc.address,
-        )
-        update_server_descriptions
       when Topology::Single
         if topology.replica_set_name
           if updated_desc.replica_set_name != topology.replica_set_name
@@ -117,7 +112,7 @@ class Mongo::Cluster
               "Server #{updated_desc.address.to_s} has an incorrect replica set name '#{updated_desc.replica_set_name}'; expected '#{topology.replica_set_name}'"
             )
             @updated_desc = ::Mongo::Server::Description.new(updated_desc.address,
-              {}, average_round_trip_time: updated_desc.average_round_trip_time)
+              {}, updated_desc.average_round_trip_time)
             update_server_descriptions
           end
         end
@@ -234,7 +229,7 @@ class Mongo::Cluster
 
       if stale_primary?
         @updated_desc = ::Mongo::Server::Description.new(updated_desc.address,
-          {}, average_round_trip_time: updated_desc.average_round_trip_time)
+          {}, updated_desc.average_round_trip_time)
         update_server_descriptions
         check_if_has_primary
         return
@@ -263,8 +258,7 @@ class Mongo::Cluster
         if server.address != updated_desc.address
           if server.primary?
             server.update_description(::Mongo::Server::Description.new(
-              server.address, {},
-              average_round_trip_time: server.description.average_round_trip_time))
+              server.address, {}, server.description.average_round_trip_time))
           end
         end
       end
diff --git a/lib/mongo/cluster/topology.rb b/lib/mongo/cluster/topology.rb
index 88f92c31c..3b8b32891 100644
--- a/lib/mongo/cluster/topology.rb
+++ b/lib/mongo/cluster/topology.rb
@@ -38,7 +38,6 @@ end
 
 require 'mongo/cluster/topology/base'
 require 'mongo/cluster/topology/no_replica_set_options'
-require 'mongo/cluster/topology/load_balanced'
 require 'mongo/cluster/topology/replica_set_no_primary'
 require 'mongo/cluster/topology/replica_set_with_primary'
 require 'mongo/cluster/topology/sharded'
@@ -51,12 +50,10 @@ module Mongo
       # The various topologies for server selection.
       #
       # @since 2.0.0
-      # @api private
       OPTIONS = {
-        direct: Single,
-        load_balanced: LoadBalanced,
         replica_set: ReplicaSetNoPrimary,
         sharded: Sharded,
+        direct: Single,
       }.freeze
 
       # Get the initial cluster topology for the provided options.
@@ -74,43 +71,26 @@ module Mongo
       # @option options [ Symbol ] :connect Deprecated - use :direct_connection
       #   option instead of this option. The connection method to use. This
       #   forces the cluster to behave in the specified way instead of
-      #   auto-discovering. One of :direct, :replica_set, :sharded,
-      #   :load_balanced. If :connect is set to :load_balanced, the driver
-      #   will behave as if the server is a load balancer even if it isn't
-      #   connected to a load balancer.
-      # @option options [ true | false ] :load_balanced Whether to expect to
-      #   connect to a load balancer.
+      #   auto-discovering. One of :direct, :replica_set, :sharded
       # @option options [ Symbol ] :replica_set The name of the replica set to
       #   connect to. Servers not in this replica set will be ignored.
       #
-      # @return [ ReplicaSet, Sharded, Single, LoadBalanced ] The topology.
+      # @return [ ReplicaSet, Sharded, Single ] The topology.
       #
       # @since 2.0.0
       # @api private
       def initial(cluster, monitoring, options)
-        connect = options[:connect]&.to_sym
         cls = if options[:direct_connection]
-          if connect && connect != :direct
-            raise ArgumentError, "Conflicting topology options: direct_connection=true and connect=#{connect}"
-          end
-          if options[:load_balanced]
-            raise ArgumentError, "Conflicting topology options: direct_connection=true and load_balanced=true"
+          if options[:connect] && options[:connect] && options[:connect].to_sym != :direct
+            raise ArgumentError, "Conflicting topology options: direct_connection=true and connect=#{options[:connect]}"
           end
           Single
-        elsif options[:direct_connection] == false && connect && connect == :direct
-          raise ArgumentError, "Conflicting topology options: direct_connection=false and connect=#{connect}"
-        elsif connect && connect != :load_balanced
-          if options[:load_balanced]
-            raise ArgumentError, "Conflicting topology options: connect=#{options[:connect].inspect} and load_balanced=true"
-          end
+        elsif options[:direct_connection] == false && options[:connect] && options[:connect].to_sym == :direct
+          raise ArgumentError, "Conflicting topology options: direct_connection=false and connect=#{options[:connect]}"
+        elsif options.key?(:connect)
           OPTIONS.fetch(options[:connect].to_sym)
         elsif options.key?(:replica_set) || options.key?(:replica_set_name)
-          if options[:load_balanced]
-            raise ArgumentError, "Conflicting topology options: replica_set/replica_set_name and load_balanced=true"
-          end
           ReplicaSetNoPrimary
-        elsif options[:load_balanced] || connect == :load_balanced
-          LoadBalanced
         else
           Unknown
         end
diff --git a/lib/mongo/cluster/topology/base.rb b/lib/mongo/cluster/topology/base.rb
index 971a58b82..c248fa202 100644
--- a/lib/mongo/cluster/topology/base.rb
+++ b/lib/mongo/cluster/topology/base.rb
@@ -67,21 +67,17 @@ module Mongo
             @server_descriptions[server.address.to_s] = server.description
           end
 
-          if is_a?(LoadBalanced)
-            @compatible = true
-          else
-            begin
-              server_descriptions.each do |address_str, desc|
-                unless desc.unknown?
-                  desc.features.check_driver_support!
-                end
+          begin
+            server_descriptions.each do |address_str, desc|
+              unless desc.unknown?
+                desc.features.check_driver_support!
               end
-            rescue Error::UnsupportedFeatures => e
-              @compatible = false
-              @compatibility_error = e
-            else
-              @compatible = true
             end
+          rescue Error::UnsupportedFeatures => e
+            @compatible = false
+            @compatibility_error = e
+          else
+            @compatible = true
           end
 
           @have_data_bearing_servers = false
diff --git a/lib/mongo/cluster/topology/load_balanced.rb b/lib/mongo/cluster/topology/load_balanced.rb
deleted file mode 100644
index 0ad295b13..000000000
--- a/lib/mongo/cluster/topology/load_balanced.rb
+++ /dev/null
@@ -1,102 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  class Cluster
-    module Topology
-
-      # Defines behavior for when a cluster is in load-balanced topology.
-      class LoadBalanced < Base
-
-        # The display name for the topology.
-        NAME = 'LoadBalanced'.freeze
-
-        # Get the display name.
-        #
-        # @return [ String ] The display name.
-        def display_name
-          self.class.name.gsub(/.*::/, '')
-        end
-
-        # @note This method is experimental and subject to change.
-        #
-        # @api experimental
-        def summary
-          details = server_descriptions.keys.join(',')
-          "#{display_name}[#{details}]"
-        end
-
-        # Determine if the topology would select a readable server for the
-        # provided candidates and read preference.
-        #
-        # @param [ Cluster ] cluster The cluster.
-        # @param [ ServerSelector ] server_selector The server
-        #   selector.
-        #
-        # @return [ true ] A standalone always has a readable server.
-        def has_readable_server?(cluster, server_selector = nil); true; end
-
-        # Determine if the topology would select a writable server for the
-        # provided candidates.
-        #
-        # @param [ Cluster ] cluster The cluster.
-        #
-        # @return [ true ] A standalone always has a writable server.
-        def has_writable_server?(cluster); true; end
-
-        # Returns whether this topology is one of the replica set ones.
-        #
-        # @return [ false ] Always false.
-        def replica_set?; false; end
-
-        # Select appropriate servers for this topology.
-        #
-        # @param [ Array<Server> ] servers The known servers.
-        #
-        # @return [ Array<Server> ] All of the known servers.
-        def servers(servers, name = nil)
-          servers
-        end
-
-        # Returns whether this topology is sharded.
-        #
-        # @return [ false ] Always false.
-        def sharded?; false; end
-
-        # Returns whether this topology is Single.
-        #
-        # @return [ true ] Always false.
-        def single?; false; end
-
-        # Returns whether this topology is Unknown.
-        #
-        # @return [ false ] Always false.
-        def unknown?; false; end
-
-        private
-
-        def validate_options(options, cluster)
-          if cluster.servers_list.length > 1
-            raise ArgumentError, "Cannot instantiate a load-balanced topology with more than one server in the cluster: #{cluster.servers_list.map(&:address).map(&:seed).join(', ')}"
-          end
-
-          super(options, cluster)
-        end
-      end
-    end
-  end
-end
diff --git a/lib/mongo/collection.rb b/lib/mongo/collection.rb
index 987e2d054..38fef3fb5 100644
--- a/lib/mongo/collection.rb
+++ b/lib/mongo/collection.rb
@@ -251,7 +251,7 @@ module Mongo
       # TODO put the list of read options in a class-level constant when
       # we figure out what the full set of them is.
       options = Hash[self.options.reject do |key, value|
-        %w(read read_preference read_concern).include?(key.to_s)
+        %w(read read_preference).include?(key.to_s)
       end]
       options.update(Utils.slice_hash(opts, *TIME_SERIES_OPTIONS.keys))
       # Converting Ruby spelled time series options to server style.
@@ -269,17 +269,17 @@ module Mongo
         else
           self.write_concern
         end
+        server = next_primary(nil, session)
+        if (options[:collation] || options[Operation::COLLATION]) && !server.with_connection { |connection| connection.features }.collation_enabled?
+          raise Error::UnsupportedCollation
+        end
 
-        context = Operation::Context.new(client: client, session: session)
-        Operation::Create.new(
-          selector: operation,
-          db_name: database.name,
-          write_concern: write_concern,
-          session: session,
-          # Note that these are collection options, collation isn't
-          # taken from options passed to the create method.
-          collation: options[:collation] || options['collation'],
-        ).execute(next_primary(nil, session), context: context)
+        Operation::Create.new({
+                                selector: operation,
+                                db_name: database.name,
+                                write_concern: write_concern,
+                                session: session,
+                                }).execute(server, context: Operation::Context.new(client: client, session: session))
       end
     end
 
@@ -353,8 +353,8 @@ module Mongo
     # @option options [ true, false ] :no_cursor_timeout The server normally times out idle
     #   cursors after an inactivity period (10 minutes) to prevent excess memory use.
     #   Set this option to prevent that.
-    # @option options [ true, false ] :oplog_replay For internal replication
-    #   use only, applications should not set this option.
+    # @option options [ true, false ] :oplog_replay Internal replication use only - driver
+    #   should not set.
     # @option options [ Hash ] :projection The fields to include or exclude from each doc
     #   in the result set.
     # @option options [ Session ] :session The session to use.
diff --git a/lib/mongo/collection/view.rb b/lib/mongo/collection/view.rb
index dd58ef89c..9fef98bcb 100644
--- a/lib/mongo/collection/view.rb
+++ b/lib/mongo/collection/view.rb
@@ -141,8 +141,6 @@ module Mongo
       # @option options [ Hash ] :read The read preference to use for the
       #   query. If none is provided, the collection's default read preference
       #   is used.
-      # @option options [ Hash ] :read_concern The read concern to use for
-      #   the query.
       # @option options [ true | false ] :show_disk_loc Return disk location
       #   info as a field in each doc.
       # @option options [ Integer ] :skip The number of documents to skip.
@@ -155,19 +153,7 @@ module Mongo
       def initialize(collection, filter = {}, options = {})
         validate_doc!(filter)
         @collection = collection
-
-        filter = BSON::Document.new(filter)
-        options = BSON::Document.new(options)
-
-        # This is when users pass $query in filter and other modifiers
-        # alongside?
-        query = filter.delete(:$query)
-        # This makes modifiers contain the filter if filter wasn't
-        # given via $query but as top-level keys, presumably
-        # downstream code ignores non-modifier keys in the modifiers?
-        modifiers = filter.merge(options.delete(:modifiers) || {})
-        @filter = (query || filter).freeze
-        @options = Operation::Find::Builder::Modifiers.map_driver_options(modifiers).merge!(options).freeze
+        parse_parameters!(BSON::Document.new(filter), BSON::Document.new(options))
       end
 
       # Get a human-readable string representation of +View+.
@@ -203,10 +189,30 @@ module Mongo
         @filter = other.filter.dup
       end
 
+      def parse_parameters!(filter, options)
+        query = filter.delete(QUERY)
+        modifiers = (filter || {}).merge(options.delete(MODIFIERS) || {})
+        @filter = (query || filter).freeze
+        @options = Builder::Modifiers.map_driver_options(modifiers).merge!(options).freeze
+      end
+
       def new(options)
         View.new(collection, filter, options)
       end
 
+      def apply_collation!(doc, server, opts = {})
+        if coll = doc[:collation] || opts[:collation] || opts['collation'] || collation
+          validate_collation!(server, coll)
+          doc[:collation] = coll
+        end
+      end
+
+      def validate_collation!(server, coll)
+        if coll && !server.with_connection { |connection| connection.features }.collation_enabled?
+          raise Error::UnsupportedCollation.new
+        end
+      end
+
       def view; self; end
 
       def with_session(opts = {}, &block)
diff --git a/lib/mongo/collection/view/aggregation.rb b/lib/mongo/collection/view/aggregation.rb
index 37e22854d..c5ffdb7ca 100644
--- a/lib/mongo/collection/view/aggregation.rb
+++ b/lib/mongo/collection/view/aggregation.rb
@@ -121,12 +121,10 @@ module Mongo
         end
 
         def valid_server?(server)
-          if secondary_ok?
-            true
-          else
-            description = server.description
-            description.standalone? || description.mongos? || description.primary? || description.load_balancer?
+          description = server.with_connection do |connection|
+            connection.description
           end
+          description.standalone? || description.mongos? || description.primary? || secondary_ok?
         end
 
         def secondary_ok?
@@ -138,9 +136,16 @@ module Mongo
             log_warn("Rerouting the Aggregation operation to the primary server - #{server.summary} is not suitable")
             server = cluster.next_primary(nil, session)
           end
+          validate_collation!(server)
           initial_query_op(session).execute(server, context: Operation::Context.new(client: client, session: session))
         end
 
+        def validate_collation!(server)
+          if options[:collation] && !server.with_connection { |connection| connection.features }.collation_enabled?
+            raise Error::UnsupportedCollation.new
+          end
+        end
+
         # Skip, sort, limit, projection are specified as pipeline stages
         # rather than as options.
         def cache_options
diff --git a/lib/mongo/collection/view/builder.rb b/lib/mongo/collection/view/builder.rb
index 46cc1dff3..3577f58db 100644
--- a/lib/mongo/collection/view/builder.rb
+++ b/lib/mongo/collection/view/builder.rb
@@ -17,3 +17,7 @@
 
 require 'mongo/collection/view/builder/aggregation'
 require 'mongo/collection/view/builder/map_reduce'
+require 'mongo/collection/view/builder/op_query'
+require 'mongo/collection/view/builder/find_command'
+require 'mongo/collection/view/builder/flags'
+require 'mongo/collection/view/builder/modifiers'
diff --git a/lib/mongo/collection/view/builder/aggregation.rb b/lib/mongo/collection/view/builder/aggregation.rb
index d6a0fa039..bfa199bcb 100644
--- a/lib/mongo/collection/view/builder/aggregation.rb
+++ b/lib/mongo/collection/view/builder/aggregation.rb
@@ -79,12 +79,11 @@ module Mongo
           # @since 2.2.0
           def specification
             spec = {
-              selector: aggregation_command,
-              db_name: database.name,
-              read: view.read_preference,
-              session: @options[:session],
-              collation: @options[:collation],
-            }
+                    selector: aggregation_command,
+                    db_name: database.name,
+                    read: view.read_preference,
+                    session: @options[:session]
+                   }
             if write?
               spec.update(write_concern: write_concern)
             end
diff --git a/lib/mongo/collection/view/builder/find_command.rb b/lib/mongo/collection/view/builder/find_command.rb
new file mode 100644
index 000000000..cde73e7d0
--- /dev/null
+++ b/lib/mongo/collection/view/builder/find_command.rb
@@ -0,0 +1,173 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+# Copyright (C) 2015-2020 MongoDB Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module Mongo
+  class Collection
+    class View
+      module Builder
+
+        # Builds a find command specification from options.
+        #
+        # @since 2.2.0
+        class FindCommand
+          extend Forwardable
+
+          # The mappings from ruby options to the find command.
+          #
+          # @since 2.2.0
+          MAPPINGS = BSON::Document.new(
+            sort: 'sort',
+            projection: 'projection',
+            hint: 'hint',
+            skip: 'skip',
+            limit: 'limit',
+            batch_size: 'batchSize',
+            single_batch: 'singleBatch',
+            comment: 'comment',
+            max_scan: 'maxScan',
+            max_time_ms: 'maxTimeMS',
+            max_value: 'max',
+            min_value: 'min',
+            return_key: 'returnKey',
+            show_disk_loc: 'showRecordId',
+            snapshot: 'snapshot',
+            tailable: 'tailable',
+            tailable_cursor: 'tailable',
+            oplog_replay: 'oplogReplay',
+            no_cursor_timeout: 'noCursorTimeout',
+            await_data: 'awaitData',
+            allow_partial_results: 'allowPartialResults',
+            allow_disk_use: 'allowDiskUse',
+            collation: 'collation'
+          ).freeze
+
+          # Create the find command builder.
+          #
+          # @example Create the find command builder.
+          #   FindCommandBuilder.new(view)
+          #
+          # @param [ Collection::View ] view The collection view.
+          # @param [ Session ] session The session.
+          #
+          # @since 2.2.2
+          def initialize(view, session)
+            @view = view
+            @session = session
+          end
+
+          def_delegators :@view, :collection, :database, :filter, :options, :read
+
+          # Get the specification to pass to the find command operation.
+          #
+          # @example Get the specification.
+          #   builder.specification
+          #
+          # @return [ Hash ] The specification.
+          #
+          # @since 2.2.0
+          def specification
+            {
+              selector: find_command,
+              db_name: database.name,
+              read: read,
+              session: @session,
+            }
+          end
+
+          # Get the specification for an explain command that wraps the find
+          # command.
+          #
+          # @example Get the explain spec.
+          #   builder.explain_specification
+          #
+          # @return [ Hash ] The specification.
+          #
+          # @since 2.2.0
+          def explain_specification
+            {
+              selector: {
+                explain: find_command,
+              },
+              db_name: database.name,
+              read: read,
+              session: @session,
+              # We should always have options{:explain] set if we are explaining.
+              # The explain field is not sent to the server, it will be
+              # processed in the operation layer.
+              explain: options[:explain],
+            }
+          end
+
+          private
+
+          def find_command
+            document = BSON::Document.new(
+              find: collection.name,
+              filter: filter,
+            )
+            if collection.read_concern
+              document[:readConcern] = Options::Mapper.transform_values_to_strings(
+                collection.read_concern)
+            end
+            command = Options::Mapper.transform_documents(
+              convert_flags(options), MAPPINGS, document)
+            if command['oplogReplay']
+              log_warn("oplogReplay is deprecated and ignored by MongoDB 4.4 and later")
+            end
+            convert_limit_and_batch_size(command)
+            command
+          end
+
+          def convert_limit_and_batch_size(command)
+            if command[:limit] && command[:limit] < 0 &&
+                command[:batchSize] && command[:batchSize] < 0
+
+              command[:limit] = command[:limit].abs
+              command[:batchSize] = command[:limit].abs
+              command[:singleBatch] = true
+
+            else
+              [:limit, :batchSize].each do |opt|
+                if command[opt]
+                  if command[opt] < 0
+                    command[opt] = command[opt].abs
+                    command[:singleBatch] = true
+                  elsif command[opt] == 0
+                    command.delete(opt)
+                  end
+                end
+              end
+            end
+          end
+
+          def convert_flags(options)
+            return options if options.empty?
+            opts = options.dup
+            opts.delete(:cursor_type)
+            Flags.map_flags(options).reduce(opts) do |o, key|
+              o.merge!(key => true)
+            end
+          end
+
+          def log_warn(*args)
+            database.client.log_warn(*args)
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/mongo/operation/find/builder/flags.rb b/lib/mongo/collection/view/builder/flags.rb
similarity index 77%
rename from lib/mongo/operation/find/builder/flags.rb
rename to lib/mongo/collection/view/builder/flags.rb
index c7820d61f..31d3eb793 100644
--- a/lib/mongo/operation/find/builder/flags.rb
+++ b/lib/mongo/collection/view/builder/flags.rb
@@ -16,17 +16,19 @@
 # limitations under the License.
 
 module Mongo
-  module Operation
-    class Find
+  class Collection
+    class View
       module Builder
 
-        # Provides behavior for converting Ruby options to wire protocol flags
-        # when sending find and related commands (e.g. explain).
+        # Provides behavior for mapping flags.
         #
-        # @api private
+        # @since 2.2.0
         module Flags
+          extend self
 
           # Options to cursor flags mapping.
+          #
+          # @since 2.2.0
           MAPPINGS = {
             :allow_partial_results => [ :partial ],
             :oplog_replay => [ :oplog_replay ],
@@ -34,18 +36,20 @@ module Mongo
             :tailable => [ :tailable_cursor ],
             :tailable_await => [ :await_data, :tailable_cursor],
             :await_data => [ :await_data ],
-            :exhaust => [ :exhaust ],
+            :exhaust => [ :exhaust ]
           }.freeze
 
-          # Converts Ruby find options to an array of flags.
+          # Maps an array of flags from the provided options.
           #
-          # Any keys in the input hash that are not options that map to flags
-          # are ignored.
+          # @example Map the flags.
+          #   Flags.map_flags(options)
           #
           # @param [ Hash, BSON::Document ] options The options.
           #
           # @return [ Array<Symbol> ] The flags.
-          module_function def map_flags(options)
+          #
+          # @since 2.2.0
+          def map_flags(options)
             MAPPINGS.each.reduce(options[:flags] || []) do |flags, (key, value)|
               cursor_type = options[:cursor_type]
               if options[key] || (cursor_type && cursor_type == key)
diff --git a/lib/mongo/collection/view/builder/map_reduce.rb b/lib/mongo/collection/view/builder/map_reduce.rb
index f07135979..967847dc5 100644
--- a/lib/mongo/collection/view/builder/map_reduce.rb
+++ b/lib/mongo/collection/view/builder/map_reduce.rb
@@ -36,7 +36,7 @@ module Mongo
             scope: 'scope',
             verbose: 'verbose',
             bypass_document_validation: 'bypassDocumentValidation',
-            collation: 'collation',
+            collation: 'collation'
           ).freeze
 
           def_delegators :@view, :collection, :database, :filter, :read, :write_concern
@@ -71,6 +71,36 @@ module Mongo
             @options = options
           end
 
+          # Get the specification for issuing a find command on the map/reduce
+          # results.
+          #
+          # @example Get the command specification.
+          #   builder.command_specification
+          #
+          # @return [ Hash ] The specification.
+          #
+          # @since 2.2.0
+          def command_specification
+            {
+              selector: find_command,
+              db_name: query_database,
+              read: read,
+              session: options[:session]
+            }
+          end
+
+          # Get the specification for the document query after a map/reduce.
+          #
+          # @example Get the query specification.
+          #   builder.query_specification
+          #
+          # @return [ Hash ] The specification.
+          #
+          # @since 2.2.0
+          def query_specification
+            { selector: {}, options: {}, db_name: query_database, coll_name: query_collection }
+          end
+
           # Get the specification to pass to the map/reduce operation.
           #
           # @example Get the specification.
@@ -83,8 +113,6 @@ module Mongo
             spec = {
               selector: map_reduce_command,
               db_name: database.name,
-              # Note that selector just above may also have a read preference
-              # specified, per the #map_reduce_command method below.
               read: read,
               session: options[:session]
             }
@@ -93,6 +121,8 @@ module Mongo
 
           private
 
+          OUT_ACTIONS = [ :replace, :merge, :reduce ].freeze
+
           def write?(spec)
             if out = spec[:selector][:out]
               out.is_a?(String) ||
@@ -100,30 +130,37 @@ module Mongo
             end
           end
 
+          def find_command
+            BSON::Document.new('find' => query_collection, 'filter' => {})
+          end
+
           def map_reduce_command
             command = BSON::Document.new(
               :mapReduce => collection.name,
               :map => map,
               :reduce => reduce,
               :query => filter,
-              :out => { inline: 1 },
+              :out => { inline: 1 }
             )
-            # Shouldn't this use self.read ?
             if collection.read_concern
               command[:readConcern] = Options::Mapper.transform_values_to_strings(
                 collection.read_concern)
             end
-            command.update(view_options)
-            command.update(Utils.slice_hash(options, :collation))
-            # Read preference isn't simply passed in the command payload
-            # (it may need to be converted to wire protocol flags)
-            # so remove it here and hopefully it's handled elsewhere.
-            # If not, RUBY-2706.
-            command.delete(:read)
+            command.merge!(view_options)
             command.merge!(Options::Mapper.transform_documents(options, MAPPINGS))
             command
           end
 
+          def query_database
+            options[:out].respond_to?(:keys) && options[:out][:db] ? options[:out][:db] : database.name
+          end
+
+          def query_collection
+            if options[:out].respond_to?(:keys)
+              options[:out][OUT_ACTIONS.find { |action| options[:out][action] }]
+            end || options[:out]
+          end
+
           def view_options
             @view_options ||= (opts = view.options.dup
                                opts.delete(:session)
diff --git a/lib/mongo/operation/find/builder/modifiers.rb b/lib/mongo/collection/view/builder/modifiers.rb
similarity index 59%
rename from lib/mongo/operation/find/builder/modifiers.rb
rename to lib/mongo/collection/view/builder/modifiers.rb
index 4aec9389f..e9cc3689f 100644
--- a/lib/mongo/operation/find/builder/modifiers.rb
+++ b/lib/mongo/collection/view/builder/modifiers.rb
@@ -16,70 +16,64 @@
 # limitations under the License.
 
 module Mongo
-  module Operation
-    class Find
+  class Collection
+    class View
       module Builder
 
-        # Provides behavior for mapping Ruby options to legacy OP_QUERY
-        # find modifiers.
+        # Provides behavior for mapping modifiers.
         #
-        # This module is used in two ways:
-        # 1. When Collection#find is invoked with the legacy OP_QUERY
-        #    syntax (:$query argument etc.), this module is used to map
-        #    the legacy parameters into the Ruby options that normally
-        #    are used by applications.
-        # 2. When sending a find operation using the OP_QUERY protocol,
-        #    this module is used to map the Ruby find options to the
-        #    modifiers in the wire protocol message.
-        #
-        # @api private
+        # @since 2.2.0
         module Modifiers
+          extend self
 
-          # Mappings from Ruby options to OP_QUERY modifiers.
+          # Mappings from driver options to legacy server values.
+          #
+          # @since 2.2.0
           DRIVER_MAPPINGS = BSON::Document.new(
-            comment: '$comment',
-            explain: '$explain',
+            sort: '$orderby',
             hint: '$hint',
+            comment: '$comment',
+            snapshot: '$snapshot',
             max_scan: '$maxScan',
-            max_time_ms: '$maxTimeMS',
             max_value: '$max',
             min_value: '$min',
+            max_time_ms: '$maxTimeMS',
             return_key: '$returnKey',
             show_disk_loc: '$showDiskLoc',
-            snapshot: '$snapshot',
-            sort: '$orderby',
+            explain: '$explain'
           ).freeze
 
-          # Mappings from OP_QUERY modifiers to Ruby options.
+          # Mappings from server values to driver options.
+          #
+          # @since 2.2.0
           SERVER_MAPPINGS = BSON::Document.new(DRIVER_MAPPINGS.invert).freeze
 
-          # Transform the provided OP_QUERY modifiers to Ruby options.
+          # Transform the provided server modifiers to driver options.
           #
           # @example Transform to driver options.
           #   Modifiers.map_driver_options(modifiers)
           #
           # @param [ Hash ] modifiers The modifiers.
           #
-          # @return [ BSON::Document ] The Ruby options.
-          module_function def map_driver_options(modifiers)
+          # @return [ BSON::Document ] The driver options.
+          #
+          # @since 2.2.0
+          def self.map_driver_options(modifiers)
             Options::Mapper.transform_documents(modifiers, SERVER_MAPPINGS)
           end
 
-          # Transform the provided Ruby options into a document of OP_QUERY
+          # Transform the provided options into a document of only server
           # modifiers.
           #
-          # Accepts both string and symbol keys.
-          #
-          # The input mapping may contain additional keys that do not map to
-          # OP_QUERY modifiers, in which case the extra keys are ignored.
-          #
           # @example Map the server modifiers.
           #   Modifiers.map_server_modifiers(options)
           #
           # @param [ Hash, BSON::Document ] options The options.
           #
           # @return [ BSON::Document ] The modifiers.
-          module_function def map_server_modifiers(options)
+          #
+          # @since 2.2.0
+          def self.map_server_modifiers(options)
             Options::Mapper.transform_documents(options, DRIVER_MAPPINGS)
           end
         end
diff --git a/lib/mongo/collection/view/builder/op_query.rb b/lib/mongo/collection/view/builder/op_query.rb
new file mode 100644
index 000000000..4debfe99e
--- /dev/null
+++ b/lib/mongo/collection/view/builder/op_query.rb
@@ -0,0 +1,94 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+# Copyright (C) 2015-2020 MongoDB Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module Mongo
+  class Collection
+    class View
+      module Builder
+
+        # Builds a legacy OP_QUERY specification from options.
+        #
+        # @since 2.2.0
+        class OpQuery
+          extend Forwardable
+
+          def_delegators :@view, :cluster, :collection, :database, :filter, :options, :read
+
+          # @return [ BSON::Document ] modifiers The server modifiers.
+          attr_reader :modifiers
+
+          # Create the new legacy query builder.
+          #
+          # @example Create the query builder.
+          #   QueryBuilder.new(view)
+          #
+          # @param [ Collection::View ] view The collection view.
+          #
+          # @since 2.2.2
+          def initialize(view)
+            @view = view
+            @modifiers = Modifiers.map_server_modifiers(options)
+          end
+
+          def specification
+            {
+              :selector  => requires_special_filter? ? special_filter : filter,
+              :read      => read,
+              :options   => query_options,
+              :db_name   => database.name,
+              :coll_name => collection.name
+            }
+          end
+
+          private
+
+          def query_options
+            BSON::Document.new(
+              project: options[:projection],
+              skip: options[:skip],
+              limit: options[:limit],
+              flags: Flags.map_flags(options),
+              batch_size: options[:batch_size]
+            )
+          end
+
+          def requires_special_filter?
+            !modifiers.empty? || cluster.sharded?
+          end
+
+          def read_pref_formatted
+            @read_formatted ||= begin
+              if read
+                read_pref = ServerSelector.get(read).to_mongos
+                Mongo::Lint.validate_camel_case_read_preference(read_pref)
+                read_pref
+              else
+                nil
+              end
+            end
+          end
+
+          def special_filter
+            sel = BSON::Document.new(:$query => filter).merge!(modifiers)
+            sel[:$readPreference] = read_pref_formatted unless read_pref_formatted.nil?
+            sel
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/mongo/collection/view/iterable.rb b/lib/mongo/collection/view/iterable.rb
index c18bc19da..b4f766743 100644
--- a/lib/mongo/collection/view/iterable.rb
+++ b/lib/mongo/collection/view/iterable.rb
@@ -25,13 +25,6 @@ module Mongo
       # @since 2.0.0
       module Iterable
 
-        # Returns the cursor associated with this view, if any.
-        #
-        # @return [ nil | Cursor ] The cursor, if any.
-        #
-        # @api private
-        attr_reader :cursor
-
         # Iterate through documents returned by a query with this +View+.
         #
         # @example Iterate through the result of the view.
@@ -137,52 +130,36 @@ module Mongo
             projection: projection,
             collation: collation,
             read_concern: read_concern,
-            read_preference: read_preference,
+            read_preference: read_preference
+
           }
         end
 
         def initial_query_op(server, session)
-          spec = {
-            coll_name: collection.name,
-            filter: filter,
-            projection: projection,
-            db_name: database.name,
-            session: session,
-            collation: collation,
-            sort: sort,
-            skip: skip,
-            limit: limit,
-            allow_disk_use: options[:allow_disk_use],
-            read: read,
-            read_concern: options[:read_concern] || read_concern,
-            batch_size: batch_size,
-            hint: options[:hint],
-            max_time_ms: options[:max_time_ms],
-            max_value: options[:max_value],
-            min_value: options[:min_value],
-            return_key: options[:return_key],
-            show_disk_loc: options[:show_disk_loc],
-            comment: options[:comment],
-            oplog_replay: if (v = options[:oplog_replay]).nil?
-              collection.options[:oplog_replay]
-            else
-              v
-            end,
-          }
-
-          if spec[:oplog_replay]
-            collection.client.log_warn("The :oplog_replay option is deprecated and ignored by MongoDB 4.4 and later")
+          if server.with_connection { |connection| connection.features }.find_command_enabled?
+            initial_command_op(session)
+          else
+            # Server versions that do not have the find command feature
+            # (versions older than 3.2) do not support the allow_disk_use option
+            # but perform no validation and will not raise an error if it is
+            # specified. If the allow_disk_use option is specified, raise an error
+            # to alert the user.
+            raise Error::UnsupportedOption.allow_disk_use_error if options.key?(:allow_disk_use)
+            Operation::Find.new(Builder::OpQuery.new(self).specification)
           end
+        end
 
+        def initial_command_op(session)
+          builder = Builder::FindCommand.new(self, session)
           if explained?
-            spec[:explain] = options[:explain]
-            Operation::Explain.new(spec)
+            Operation::Explain.new(builder.explain_specification)
           else
-            Operation::Find.new(spec)
+            Operation::Find.new(builder.specification)
           end
         end
 
         def send_initial_query(server, session = nil)
+          validate_collation!(server, collation)
           initial_query_op(server, session).execute(server, context: Operation::Context.new(client: client, session: session))
         end
 
diff --git a/lib/mongo/collection/view/map_reduce.rb b/lib/mongo/collection/view/map_reduce.rb
index 28fb3b024..6df3d92c9 100644
--- a/lib/mongo/collection/view/map_reduce.rb
+++ b/lib/mongo/collection/view/map_reduce.rb
@@ -156,28 +156,6 @@ module Mongo
           configure(:out, location)
         end
 
-        # Returns the collection name where the map-reduce result is written to.
-        # If the result is returned inline, returns nil.
-        def out_collection_name
-          if options[:out].respond_to?(:keys)
-            options[:out][OUT_ACTIONS.find do |action|
-              options[:out][action]
-            end]
-          end || options[:out]
-        end
-
-        # Returns the database name where the map-reduce result is written to.
-        # If the result is returned inline, returns nil.
-        def out_database_name
-          if options[:out]
-            if options[:out].respond_to?(:keys) && (db = options[:out][:db])
-              db
-            else
-              database.name
-            end
-          end
-        end
-
         # Set or get a scope on the operation.
         #
         # @example Set the scope value.
@@ -229,8 +207,6 @@ module Mongo
 
         private
 
-        OUT_ACTIONS = [ :replace, :merge, :reduce ].freeze
-
         def server_selector
           @view.send(:server_selector)
         end
@@ -252,12 +228,10 @@ module Mongo
         end
 
         def valid_server?(server)
-          if secondary_ok?
-            true
-          else
-            description = server.description
-            description.standalone? || description.mongos? || description.primary? || description.load_balancer?
+          description = server.with_connection do |connection|
+            connection.description
           end
+          description.standalone? || description.mongos? || description.primary? || secondary_ok?
         end
 
         def secondary_ok?
@@ -270,6 +244,7 @@ module Mongo
             log_warn(msg)
             server = cluster.next_primary(nil, session)
           end
+          validate_collation!(server)
           initial_query_op(session).execute(server, context: Operation::Context.new(client: client, session: session))
         end
 
@@ -282,21 +257,22 @@ module Mongo
         end
 
         def fetch_query_op(server, session)
-          spec = {
-            coll_name: out_collection_name,
-            db_name: out_database_name,
-            filter: {},
-            session: session,
-            read: read,
-            read_concern: options[:read_concern] || collection.read_concern,
-            collation: options[:collation] || view.options[:collation],
-          }
-          Operation::Find.new(spec)
+          if server.with_connection { |connection| connection.features }.find_command_enabled?
+            Operation::Find.new(find_command_spec(session))
+          else
+            Operation::Find.new(fetch_query_spec)
+          end
         end
 
         def send_fetch_query(server, session)
           fetch_query_op(server, session).execute(server, context: Operation::Context.new(client: client, session: session))
         end
+
+        def validate_collation!(server)
+          if (view.options[:collation] || options[:collation]) && !server.with_connection { |connection| connection.features }.collation_enabled?
+            raise Error::UnsupportedCollation.new
+          end
+        end
       end
     end
   end
diff --git a/lib/mongo/collection/view/readable.rb b/lib/mongo/collection/view/readable.rb
index 674bdcdb2..663ba3e03 100644
--- a/lib/mongo/collection/view/readable.rb
+++ b/lib/mongo/collection/view/readable.rb
@@ -24,6 +24,16 @@ module Mongo
       # @since 2.0.0
       module Readable
 
+        # The query modifier constant.
+        #
+        # @since 2.2.0
+        QUERY = '$query'.freeze
+
+        # The modifiers option constant.
+        #
+        # @since 2.2.0
+        MODIFIERS = 'modifiers'.freeze
+
         # Execute an aggregation on the collection view.
         #
         # @example Aggregate documents.
@@ -159,15 +169,13 @@ module Mongo
           selector = ServerSelector.get(read_pref || server_selector)
           with_session(opts) do |session|
             read_with_retry(session, selector) do |server|
+              apply_collation!(cmd, server, opts)
               Operation::Count.new(
-                selector: cmd,
-                db_name: database.name,
-                options: {:limit => -1},
-                read: read_pref,
-                session: session,
-                # For some reason collation was historically accepted as a
-                # string key. Note that this isn't documented as valid usage.
-                collation: opts[:collation] || opts['collation'] || collation,
+                                     :selector => cmd,
+                                     :db_name => database.name,
+                                     :options => {:limit => -1},
+                                     :read => read_pref,
+                                     :session => session,
               ).execute(server, context: Operation::Context.new(client: client, session: session))
             end.n.to_i
           end
@@ -235,8 +243,8 @@ module Mongo
           read_pref = opts[:read] || read_preference
           selector = ServerSelector.get(read_pref || server_selector)
           with_session(opts) do |session|
+            context = Operation::Context.new(client: client, session: session)
             read_with_retry(session, selector) do |server|
-              context = Operation::Context.new(client: client, session: session)
               if server.description.server_version_gte?('5.0')
                 pipeline = [
                   {'$collStats' => {'count' => {}}},
@@ -307,16 +315,14 @@ module Mongo
           selector = ServerSelector.get(read_pref || server_selector)
           with_session(opts) do |session|
             read_with_retry(session, selector) do |server|
-              Operation::Distinct.new(
-                selector: cmd,
-                db_name: database.name,
-                options: {:limit => -1},
-                read: read_pref,
-                session: session,
-                # For some reason collation was historically accepted as a
-                # string key. Note that this isn't documented as valid usage.
-                collation: opts[:collation] || opts['collation'] || collation,
-              ).execute(server, context: Operation::Context.new(client: client, session: session))
+              apply_collation!(cmd, server, opts)
+              Operation::Distinct.new({
+                                        :selector => cmd,
+                                        :db_name => database.name,
+                                        :options => {:limit => -1},
+                                        :read => read_pref,
+                                        :session => session,
+                                       }).execute(server, context: Operation::Context.new(client: client, session: session))
             end.first['values']
           end
         end
@@ -536,11 +542,7 @@ module Mongo
           configure(:sort, spec)
         end
 
-        # If called without arguments or with a nil argument, returns
-        # the legacy (OP_QUERY) server modifiers for the current view.
-        # If called with a non-nil argument, which must be a Hash or a
-        # subclass, merges the provided modifiers into the current view.
-        # Both string and symbol keys are allowed in the input hash.
+        # “meta” operators that let you modify the output or behavior of a query.
         #
         # @example Set the modifiers document.
         #   view.modifiers(:$orderby => Mongo::Index::ASCENDING)
@@ -551,11 +553,8 @@ module Mongo
         #
         # @since 2.1.0
         def modifiers(doc = nil)
-          if doc.nil?
-            Operation::Find::Builder::Modifiers.map_server_modifiers(options)
-          else
-            new(options.merge(Operation::Find::Builder::Modifiers.map_driver_options(BSON::Document.new(doc))))
-          end
+          return Builder::Modifiers.map_server_modifiers(options) if doc.nil?
+          new(options.merge(Builder::Modifiers.map_driver_options(doc)))
         end
 
         # A cumulative time limit in milliseconds for processing get more operations
@@ -646,42 +645,34 @@ module Mongo
 
         def parallel_scan(cursor_count, options = {})
           if options[:session]
-            # The session would be overwritten by the one in +options+ later.
             session = client.send(:get_session, @options)
           else
             session = nil
           end
           server = server_selector.select_server(cluster, nil, session)
-          spec = {
-            coll_name: collection.name,
-            db_name: database.name,
-            cursor_count: cursor_count,
-            read_concern: read_concern,
-            session: session,
-          }.update(options)
-          session = spec[:session]
-          op = Operation::ParallelScan.new(spec)
-          # Note that the context object shouldn't be reused for subsequent
-          # GetMore operations.
-          context = Operation::Context.new(client: client, session: session)
-          result = op.execute(server, context: context)
-          result.cursor_ids.map do |cursor_id|
-            spec = {
-              cursor_id: cursor_id,
-              coll_name: collection.name,
-              db_name: database.name,
-              session: session,
-              batch_size: batch_size,
-              to_return: 0,
-              # max_time_ms is not being passed here, I assume intentionally?
-            }
-            op = Operation::GetMore.new(spec)
-            context = Operation::Context.new(
-              client: client,
-              session: session,
-              service_id: result.connection_description.service_id,
-            )
-            result = op.execute(server, context: context)
+          cmd = Operation::ParallelScan.new({
+                  :coll_name => collection.name,
+                  :db_name => database.name,
+                  :cursor_count => cursor_count,
+                  :read_concern => read_concern,
+                  :session => session,
+                }.merge!(options))
+          cmd.execute(server, context: Operation::Context.new(client: client, session: session)).cursor_ids.map do |cursor_id|
+            result = if server.with_connection { |connection| connection.features }.find_command_enabled?
+              Operation::GetMore.new({
+                :selector => {:getMore => BSON::Int64.new(cursor_id),
+                             :collection => collection.name},
+                :db_name => database.name,
+                :session => session,
+              }).execute(server, context: Operation::Context.new(client: client, session: session))
+             else
+              Operation::GetMore.new({
+                :to_return => 0,
+                :cursor_id => BSON::Int64.new(cursor_id),
+                :db_name => database.name,
+                :coll_name => collection.name
+              }).execute(server, context: Operation::Context.new(client: client, session: session))
+            end
             Cursor.new(self, result, server, session: session)
           end
         end
diff --git a/lib/mongo/collection/view/writable.rb b/lib/mongo/collection/view/writable.rb
index 5baa768ba..7a2b8f807 100644
--- a/lib/mongo/collection/view/writable.rb
+++ b/lib/mongo/collection/view/writable.rb
@@ -46,44 +46,33 @@ module Mongo
         # @option opts [ Session ] :session The session to use.
         # @option opts [ Hash | String ] :hint The index to use for this operation.
         #   May be specified as a Hash (e.g. { _id: 1 }) or a String (e.g. "_id_").
-        # @option opts [ Hash ] :write_concern The write concern options.
-        #   Can be :w => Integer, :fsync => Boolean, :j => Boolean.
         #
         # @return [ BSON::Document, nil ] The document, if found.
         #
         # @since 2.0.0
         def find_one_and_delete(opts = {})
-          with_session(opts) do |session|
-            write_concern = if opts[:write_concern]
-              WriteConcern.get(opts[:write_concern])
-            else
-              write_concern_with_session(session)
-            end
-            if opts[:hint] && write_concern && !write_concern.acknowledged?
-              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
-            end
-
-            QueryCache.clear_namespace(collection.namespace)
-
-            cmd = Utils.compact_hash(
-              findAndModify: collection.name,
-              query: filter,
-              remove: true,
-              fields: projection,
-              sort: sort,
-              maxTimeMS: max_time_ms,
-              bypassDocumentValidation: opts[:bypass_document_validation],
-              hint: opts[:hint],
-              collation: opts[:collation] || opts['collation'] || collation,
-            )
+          QueryCache.clear_namespace(collection.namespace)
+
+          cmd = { :findAndModify => collection.name, :query => filter, :remove => true }
+          cmd[:fields] = projection if projection
+          cmd[:sort] = sort if sort
+          cmd[:maxTimeMS] = max_time_ms if max_time_ms
+          if opts[:bypass_document_validation]
+            cmd[:bypassDocumentValidation] = true
+          end
 
-            write_with_retry(session, write_concern) do |server, txn_num|
-              Operation::WriteCommand.new(
-                selector: cmd,
-                db_name: database.name,
-                write_concern: write_concern,
-                session: session,
-                txn_num: txn_num,
+          with_session(opts) do |session|
+            applied_write_concern = applied_write_concern(session)
+            cmd[:writeConcern] = applied_write_concern.options if applied_write_concern
+            write_with_retry(session, applied_write_concern) do |server, txn_num|
+              apply_collation!(cmd, server, opts)
+              apply_hint!(cmd, server, opts.merge(write_concern: applied_write_concern))
+
+              Operation::Command.new(
+                  :selector => cmd,
+                  :db_name => database.name,
+                  :session => session,
+                  :txn_num => txn_num,
               ).execute(server, context: Operation::Context.new(client: client, session: session))
             end
           end.first['value']
@@ -107,8 +96,6 @@ module Mongo
         # @option opts [ Hash ] :collation The collation to use.
         # @option opts [ Hash | String ] :hint The index to use for this operation.
         #   May be specified as a Hash (e.g. { _id: 1 }) or a String (e.g. "_id_").
-        # @option opts [ Hash ] :write_concern The write concern options.
-        #   Can be :w => Integer, :fsync => Boolean, :j => Boolean.
         #
         # @return [ BSON::Document ] The document.
         #
@@ -140,47 +127,37 @@ module Mongo
         # @option opts [ Session ] :session The session to use.
         # @option opts [ Hash | String ] :hint The index to use for this operation.
         #   May be specified as a Hash (e.g. { _id: 1 }) or a String (e.g. "_id_").
-        # @option opts [ Hash ] :write_concern The write concern options.
-        #   Can be :w => Integer, :fsync => Boolean, :j => Boolean.
         #
         # @return [ BSON::Document ] The document.
         #
         # @since 2.0.0
         def find_one_and_update(document, opts = {})
-          value = with_session(opts) do |session|
-            write_concern = if opts[:write_concern]
-              WriteConcern.get(opts[:write_concern])
-            else
-              write_concern_with_session(session)
-            end
-            if opts[:hint] && write_concern && !write_concern.acknowledged?
-              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
-            end
-
-            QueryCache.clear_namespace(collection.namespace)
-
-            cmd = Utils.compact_hash(
-              findAndModify: collection.name,
-              query: filter,
-              arrayFilters: opts[:array_filters] || opts['array_filters'],
-              update: document,
-              fields: projection,
-              sort: sort,
-              new: !!(opts[:return_document] && opts[:return_document] == :after),
-              upsert: opts[:upsert],
-              maxTimeMS: max_time_ms,
-              bypassDocumentValidation: opts[:bypass_document_validation],
-              hint: opts[:hint],
-              collation: opts[:collation] || opts['collation'] || collation,
-            )
+          QueryCache.clear_namespace(collection.namespace)
+
+          cmd = { :findAndModify => collection.name, :query => filter }
+          cmd[:update] = document
+          cmd[:fields] = projection if projection
+          cmd[:sort] = sort if sort
+          cmd[:new] = !!(opts[:return_document] && opts[:return_document] == :after)
+          cmd[:upsert] = opts[:upsert] if opts[:upsert]
+          cmd[:maxTimeMS] = max_time_ms if max_time_ms
+          if opts[:bypass_document_validation]
+            cmd[:bypassDocumentValidation] = true
+          end
 
-            write_with_retry(session, write_concern) do |server, txn_num|
-              Operation::WriteCommand.new(
-                selector: cmd,
-                db_name: database.name,
-                write_concern: write_concern,
-                session: session,
-                txn_num: txn_num,
+          value = with_session(opts) do |session|
+            applied_write_concern = applied_write_concern(opts[:session])
+            cmd[:writeConcern] = applied_write_concern.options if applied_write_concern
+            write_with_retry(session, applied_write_concern) do |server, txn_num|
+              apply_collation!(cmd, server, opts)
+              apply_array_filters!(cmd, server, opts)
+              apply_hint!(cmd, server, opts.merge(write_concern: applied_write_concern))
+
+              Operation::Command.new(
+                  :selector => cmd,
+                  :db_name => database.name,
+                  :session => session,
+                  :txn_num => txn_num,
               ).execute(server, context: Operation::Context.new(client: client, session: session))
             end
           end.first['value']
@@ -205,33 +182,26 @@ module Mongo
         #
         # @since 2.0.0
         def delete_many(opts = {})
+          QueryCache.clear_namespace(collection.namespace)
+
+          delete_doc = { Operation::Q => filter, Operation::LIMIT => 0 }
           with_session(opts) do |session|
             write_concern = if opts[:write_concern]
               WriteConcern.get(opts[:write_concern])
             else
               write_concern_with_session(session)
             end
-            if opts[:hint] && write_concern && !write_concern.acknowledged?
-              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
-            end
-
-            QueryCache.clear_namespace(collection.namespace)
-
-            delete_doc = Utils.compact_hash(
-              Operation::Q => filter,
-              Operation::LIMIT => 0,
-              hint: opts[:hint],
-              collation: opts[:collation] || opts['collation'] || collation,
-            )
-
             nro_write_with_retry(session, write_concern) do |server|
+              apply_collation!(delete_doc, server, opts)
+              apply_hint!(delete_doc, server, opts.merge(write_concern: write_concern))
+
               Operation::Delete.new(
-                deletes: [ delete_doc ],
-                db_name: collection.database.name,
-                coll_name: collection.name,
-                write_concern: write_concern,
-                bypass_document_validation: !!opts[:bypass_document_validation],
-                session: session,
+                  :deletes => [ delete_doc ],
+                  :db_name => collection.database.name,
+                  :coll_name => collection.name,
+                  :write_concern => write_concern,
+                  :bypass_document_validation => !!opts[:bypass_document_validation],
+                  :session => session,
               ).execute(server, context: Operation::Context.new(client: client, session: session))
             end
           end
@@ -255,34 +225,27 @@ module Mongo
         #
         # @since 2.0.0
         def delete_one(opts = {})
+          QueryCache.clear_namespace(collection.namespace)
+
+          delete_doc = { Operation::Q => filter, Operation::LIMIT => 1 }
           with_session(opts) do |session|
             write_concern = if opts[:write_concern]
               WriteConcern.get(opts[:write_concern])
             else
               write_concern_with_session(session)
             end
-            if opts[:hint] && write_concern && !write_concern.acknowledged?
-              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
-            end
-
-            QueryCache.clear_namespace(collection.namespace)
-
-            delete_doc = Utils.compact_hash(
-              Operation::Q => filter,
-              Operation::LIMIT => 1,
-              hint: opts[:hint],
-              collation: opts[:collation] || opts['collation'] || collation,
-            )
-
             write_with_retry(session, write_concern) do |server, txn_num|
+              apply_collation!(delete_doc, server, opts)
+              apply_hint!(delete_doc, server, opts.merge(write_concern: write_concern))
+
               Operation::Delete.new(
-                deletes: [ delete_doc ],
-                db_name: collection.database.name,
-                coll_name: collection.name,
-                write_concern: write_concern,
-                bypass_document_validation: !!opts[:bypass_document_validation],
-                session: session,
-                txn_num: txn_num,
+                  :deletes => [ delete_doc ],
+                  :db_name => collection.database.name,
+                  :coll_name => collection.name,
+                  :write_concern => write_concern,
+                  :bypass_document_validation => !!opts[:bypass_document_validation],
+                  :session => session,
+                  :txn_num => txn_num,
               ).execute(server, context: Operation::Context.new(client: client, session: session))
             end
           end
@@ -311,38 +274,34 @@ module Mongo
         #
         # @since 2.0.0
         def replace_one(replacement, opts = {})
+          QueryCache.clear_namespace(collection.namespace)
+
+          update_doc = { Operation::Q => filter,
+                         Operation::U => replacement,
+                        }
+          if opts[:upsert]
+            update_doc['upsert'] = true
+          end
           with_session(opts) do |session|
             write_concern = if opts[:write_concern]
               WriteConcern.get(opts[:write_concern])
             else
               write_concern_with_session(session)
             end
-            if opts[:hint] && write_concern && !write_concern.acknowledged?
-              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
-            end
-
-            QueryCache.clear_namespace(collection.namespace)
-
-            update_doc = Utils.compact_hash(
-              Operation::Q => filter,
-              arrayFilters: opts[:array_filters] || opts['array_filters'],
-              Operation::U => replacement,
-              hint: opts[:hint],
-              collation: opts[:collation] || opts['collation'] || collation,
-            )
-            if opts[:upsert]
-              update_doc['upsert'] = true
-            end
 
             write_with_retry(session, write_concern) do |server, txn_num|
+              apply_collation!(update_doc, server, opts)
+              apply_array_filters!(update_doc, server, opts)
+              apply_hint!(update_doc, server, opts.merge(write_concern: write_concern))
+
               Operation::Update.new(
-                updates: [ update_doc ],
-                db_name: collection.database.name,
-                coll_name: collection.name,
-                write_concern: write_concern,
-                bypass_document_validation: !!opts[:bypass_document_validation],
-                session: session,
-                txn_num: txn_num,
+                  :updates => [ update_doc ],
+                  :db_name => collection.database.name,
+                  :coll_name => collection.name,
+                  :write_concern => write_concern,
+                  :bypass_document_validation => !!opts[:bypass_document_validation],
+                  :session => session,
+                  :txn_num => txn_num,
               ).execute(server, context: Operation::Context.new(client: client, session: session))
             end
           end
@@ -373,38 +332,33 @@ module Mongo
         #
         # @since 2.0.0
         def update_many(spec, opts = {})
+          QueryCache.clear_namespace(collection.namespace)
+
+          update_doc = { Operation::Q => filter,
+                         Operation::U => spec,
+                         Operation::MULTI => true,
+                         }
+          if opts[:upsert]
+            update_doc['upsert'] = true
+          end
           with_session(opts) do |session|
             write_concern = if opts[:write_concern]
               WriteConcern.get(opts[:write_concern])
             else
               write_concern_with_session(session)
             end
-            if opts[:hint] && write_concern && !write_concern.acknowledged?
-              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
-            end
-
-            QueryCache.clear_namespace(collection.namespace)
-
-            update_doc = Utils.compact_hash(
-              Operation::Q => filter,
-              arrayFilters: opts[:array_filters] || opts['array_filters'],
-              Operation::U => spec,
-              Operation::MULTI => true,
-              hint: opts[:hint],
-              collation: opts[:collation] || opts['collation'] || collation,
-            )
-            if opts[:upsert]
-              update_doc['upsert'] = true
-            end
-
             nro_write_with_retry(session, write_concern) do |server|
+              apply_collation!(update_doc, server, opts)
+              apply_array_filters!(update_doc, server, opts)
+              apply_hint!(update_doc, server, opts.merge(write_concern: write_concern))
+
               Operation::Update.new(
-                updates: [ update_doc ],
-                db_name: collection.database.name,
-                coll_name: collection.name,
-                write_concern: write_concern,
-                bypass_document_validation: !!opts[:bypass_document_validation],
-                session: session,
+                  :updates => [ update_doc ],
+                  :db_name => collection.database.name,
+                  :coll_name => collection.name,
+                  :write_concern => write_concern,
+                  :bypass_document_validation => !!opts[:bypass_document_validation],
+                  :session => session,
               ).execute(server, context: Operation::Context.new(client: client, session: session))
             end
           end
@@ -435,40 +389,83 @@ module Mongo
         #
         # @since 2.0.0
         def update_one(spec, opts = {})
+          QueryCache.clear_namespace(collection.namespace)
+
+          update_doc = { Operation::Q => filter,
+                         Operation::U => spec,
+                         }
+          if opts[:upsert]
+            update_doc['upsert'] = true
+          end
           with_session(opts) do |session|
             write_concern = if opts[:write_concern]
               WriteConcern.get(opts[:write_concern])
             else
               write_concern_with_session(session)
             end
-            if opts[:hint] && write_concern && !write_concern.acknowledged?
-              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
+            write_with_retry(session, write_concern) do |server, txn_num|
+              apply_collation!(update_doc, server, opts)
+              apply_array_filters!(update_doc, server, opts)
+              apply_hint!(update_doc, server, opts.merge(write_concern: write_concern))
+
+              Operation::Update.new(
+                  :updates => [ update_doc ],
+                  :db_name => collection.database.name,
+                  :coll_name => collection.name,
+                  :write_concern => write_concern,
+                  :bypass_document_validation => !!opts[:bypass_document_validation],
+                  :session => session,
+                  :txn_num => txn_num,
+              ).execute(server, context: Operation::Context.new(client: client, session: session))
             end
+          end
+        end
 
-            QueryCache.clear_namespace(collection.namespace)
-
-            update_doc = Utils.compact_hash(
-              Operation::Q => filter,
-              arrayFilters: opts[:array_filters] || opts['array_filters'],
-              Operation::U => spec,
-              hint: opts[:hint],
-              collation: opts[:collation] || opts['collation'] || collation,
-            )
-            if opts[:upsert]
-              update_doc['upsert'] = true
+        private
+
+        def apply_hint!(doc, server, opts)
+          if hint = opts[:hint]
+            features = server.with_connection do |connection|
+              connection.description.features
             end
 
-            write_with_retry(session, write_concern) do |server, txn_num|
-              Operation::Update.new(
-                updates: [ update_doc ],
-                db_name: collection.database.name,
-                coll_name: collection.name,
-                write_concern: write_concern,
-                bypass_document_validation: !!opts[:bypass_document_validation],
-                session: session,
-                txn_num: txn_num,
-              ).execute(server, context: Operation::Context.new(client: client, session: session))
+            write_concern = opts[:write_concern]
+            if write_concern && !write_concern.acknowledged?
+              raise Error::UnsupportedOption.hint_error(unacknowledged_write: true)
             end
+
+            if doc.key?(:findAndModify) &&
+                !features.find_and_modify_option_validation_enabled?
+              raise Error::UnsupportedOption.hint_error
+            elsif !features.update_delete_option_validation_enabled?
+              raise Error::UnsupportedOption.hint_error
+            end
+
+            doc[:hint] = opts[:hint]
+          end
+        end
+
+        def apply_array_filters!(doc, server, opts = {})
+          if filters = opts[:array_filters] || opts[ARRAY_FILTERS]
+            validate_array_filters!(server, filters)
+            doc[:arrayFilters] = filters
+          end
+        end
+
+        def validate_array_filters!(server, filters)
+          if filters && !server.with_connection { |connection| connection.features }.array_filters_enabled?
+            raise Error::UnsupportedArrayFilters.new
+          end
+        end
+
+        # Get the write concern for an operation
+        #
+        # @return [ Mongo::WriteConcern ] The write concern.
+        def applied_write_concern(session)
+          if wco = options[:write_concern] || options[:write]
+            WriteConcern.get(wco)
+          else
+            write_concern_with_session(session)
           end
         end
       end
diff --git a/lib/mongo/cursor.rb b/lib/mongo/cursor.rb
index 7e2c57ebb..b5caa47e0 100644
--- a/lib/mongo/cursor.rb
+++ b/lib/mongo/cursor.rb
@@ -15,6 +15,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+require 'mongo/cursor/builder'
+
 module Mongo
 
   # Client-side representation of an iterator over a query result set on
@@ -67,10 +69,6 @@ module Mongo
     #
     # @since 2.0.0
     def initialize(view, result, server, options = {})
-      unless result.is_a?(Operation::Result)
-        raise ArgumentError, "Second argument must be a Mongo::Operation::Result: #{result.inspect}"
-      end
-
       @view = view
       @server = server
       @initial_result = result
@@ -84,8 +82,9 @@ module Mongo
       @session = @options[:session]
       unless closed?
         register
-        ObjectSpace.define_finalizer(self, self.class.finalize(kill_spec,
+        ObjectSpace.define_finalizer(self, self.class.finalize(@cursor_id,
           cluster,
+          kill_cursors_op_spec,
           server,
           @session))
       end
@@ -94,25 +93,23 @@ module Mongo
     # @api private
     attr_reader :server
 
-    # @api private
-    attr_reader :initial_result
-
     # Finalize the cursor for garbage collection. Schedules this cursor to be included
     # in a killCursors operation executed by the Cluster's CursorReaper.
     #
-    # @param [ Cursor::KillSpec ] kill_spec The KillCursor operation specification.
+    # @example Finalize the cursor.
+    #   Cursor.finalize(id, cluster, op, server)
+    #
+    # @param [ Integer ] cursor_id The cursor's id.
     # @param [ Mongo::Cluster ] cluster The cluster associated with this cursor and its server.
+    # @param [ Hash ] op_spec The killCursors operation specification.
     # @param [ Mongo::Server ] server The server to send the killCursors operation to.
     #
     # @return [ Proc ] The Finalizer.
     #
-    # @api private
-    def self.finalize(kill_spec, cluster, server, session)
-      unless KillSpec === kill_spec
-        raise ArgumentError, "First argument must be a KillSpec: #{kill_spec.inspect}"
-      end
+    # @since 2.3.0
+    def self.finalize(cursor_id, cluster, op_spec, server, session)
       proc do
-        cluster.schedule_kill_cursor(kill_spec, server)
+        cluster.schedule_kill_cursor(cursor_id, op_spec, server)
         session.end_session if session && session.implicit?
       end
     end
@@ -277,13 +274,7 @@ module Mongo
 
       unregister
       read_with_one_retry do
-        spec = {
-          coll_name: collection_name,
-          db_name: database.name,
-          cursor_ids: [id],
-        }
-        op = Operation::KillCursors.new(spec)
-        execute_operation(op)
+        kill_cursors_operation.execute(@server, context: Operation::Context.new(client: client, session: @session))
       end
 
       nil
@@ -358,17 +349,7 @@ module Mongo
       # doing so may result in silent data loss, the driver no longer retries
       # getMore operations in any circumstance.
       # https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.rst#qa
-      process(execute_operation(get_more_operation))
-    end
-
-    # @api private
-    def kill_spec
-      KillSpec.new(
-        cursor_id: id,
-        coll_name: collection_name,
-        db_name: database.name,
-        service_id: initial_result.connection_description.service_id,
-      )
+      process(get_more_operation.execute(@server, context: Operation::Context.new(client: client, session: @session)))
     end
 
     private
@@ -388,24 +369,11 @@ module Mongo
     end
 
     def get_more_operation
-      spec = {
-        session: @session,
-        db_name: database.name,
-        coll_name: collection_name,
-        cursor_id: id,
-        # 3.2+ servers use batch_size, 3.0- servers use to_return.
-        # TODO should to_return be calculated in the operation layer?
-        batch_size: batch_size,
-        to_return: to_return,
-        max_time_ms: if view.respond_to?(:max_await_time_ms) &&
-          view.max_await_time_ms &&
-          view.options[:await_data]
-        then
-          view.max_await_time_ms
-        else
-          nil
-        end,
-      }
+      if @server.with_connection { |connection| connection.features }.find_command_enabled?
+        spec = Builder::GetMoreCommand.new(self, @session).specification
+      else
+        spec = Builder::OpGetMore.new(self).specification
+      end
       Operation::GetMore.new(spec)
     end
 
@@ -413,6 +381,18 @@ module Mongo
       @session.end_session if @session && @session.implicit?
     end
 
+    def kill_cursors_operation
+      Operation::KillCursors.new(kill_cursors_op_spec)
+    end
+
+    def kill_cursors_op_spec
+      if @server.with_connection { |connection| connection.features }.find_command_enabled?
+        Builder::KillCursorsCommand.new(self).specification
+      else
+        Builder::OpKillCursors.new(self).specification
+      end
+    end
+
     def limited?
       limit ? limit > 0 : false
     end
@@ -453,16 +433,5 @@ module Mongo
     def unregister
       cluster.unregister_cursor(@cursor_id)
     end
-
-    def execute_operation(op)
-      context = Operation::Context.new(
-        client: client,
-        session: @session,
-        service_id: initial_result.connection_description.service_id,
-      )
-      op.execute(@server, context: context)
-    end
   end
 end
-
-require 'mongo/cursor/kill_spec'
diff --git a/lib/mongo/operation/find/builder.rb b/lib/mongo/cursor/builder.rb
similarity index 76%
rename from lib/mongo/operation/find/builder.rb
rename to lib/mongo/cursor/builder.rb
index c1d8b1fea..a821682c7 100644
--- a/lib/mongo/operation/find/builder.rb
+++ b/lib/mongo/cursor/builder.rb
@@ -15,7 +15,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-require 'mongo/operation/find/builder/command'
-require 'mongo/operation/find/builder/flags'
-require 'mongo/operation/find/builder/legacy'
-require 'mongo/operation/find/builder/modifiers'
+require 'mongo/cursor/builder/op_get_more'
+require 'mongo/cursor/builder/op_kill_cursors'
+require 'mongo/cursor/builder/get_more_command'
+require 'mongo/cursor/builder/kill_cursors_command'
diff --git a/lib/mongo/cursor/builder/get_more_command.rb b/lib/mongo/cursor/builder/get_more_command.rb
new file mode 100644
index 000000000..1e2170cd5
--- /dev/null
+++ b/lib/mongo/cursor/builder/get_more_command.rb
@@ -0,0 +1,80 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+# Copyright (C) 2015-2020 MongoDB Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module Mongo
+  class Cursor
+    module Builder
+
+      # Generates a specification for a get more command.
+      #
+      # @since 2.2.0
+      class GetMoreCommand
+        extend Forwardable
+
+        # @return [ Cursor ] cursor The cursor.
+        attr_reader :cursor
+
+        def_delegators :@cursor, :collection_name, :database, :view
+        def_delegators :view, :batch_size
+
+        # Create the new builder.
+        #
+        # @example Create the builder.
+        #   GetMoreCommand.new(cursor)
+        #
+        # @param [ Cursor ] cursor The cursor.
+        # @param [ Session ] session The session.
+        #
+        # @since 2.2.0
+        def initialize(cursor, session = nil)
+          @cursor = cursor
+          @session = session
+        end
+
+        # Get the specification.
+        #
+        # @example Get the specification.
+        #   get_more_command.specification
+        #
+        # @return [ Hash ] The spec.
+        #
+        # @since 2.2.0
+        def specification
+          { selector: get_more_command, db_name: database.name, session: @session }
+        end
+
+        private
+
+        def get_more_command
+          command = {
+            :getMore => BSON::Int64.new(cursor.id),
+            :collection => collection_name,
+          }
+          command[:batchSize] = batch_size.abs if batch_size && batch_size != 0
+          # If the max_await_time_ms option is set, then we set maxTimeMS on
+          # the get more command.
+          if view.respond_to?(:max_await_time_ms)
+            if view.max_await_time_ms && view.options[:await_data]
+              command[:maxTimeMS] = view.max_await_time_ms
+            end
+          end
+          command
+        end
+      end
+    end
+  end
+end
diff --git a/lib/mongo/cursor/builder/kill_cursors_command.rb b/lib/mongo/cursor/builder/kill_cursors_command.rb
new file mode 100644
index 000000000..5308e3670
--- /dev/null
+++ b/lib/mongo/cursor/builder/kill_cursors_command.rb
@@ -0,0 +1,111 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+# Copyright (C) 2015-2020 MongoDB Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module Mongo
+  class Cursor
+    module Builder
+
+      # Generates a specification for a kill cursors command.
+      #
+      # @since 2.2.0
+      class KillCursorsCommand
+        extend Forwardable
+
+        # @return [ Cursor ] cursor The cursor.
+        attr_reader :cursor
+
+        def_delegators :@cursor, :collection_name, :database
+
+        # Create the new builder.
+        #
+        # @example Create the builder.
+        #   KillCursorsCommand.new(cursor)
+        #
+        # @param [ Cursor ] cursor The cursor.
+        #
+        # @since 2.2.0
+        def initialize(cursor)
+          @cursor = cursor
+        end
+
+        # Get the specification.
+        #
+        # @example Get the specification.
+        #   kill_cursors_command.specification
+        #
+        # @return [ Hash ] The spec.
+        #
+        # @since 2.2.0
+        def specification
+          { selector: kill_cursors_command, db_name: database.name }
+        end
+
+        private
+
+        def kill_cursors_command
+          {
+            killCursors: collection_name,
+            cursors: [ BSON::Int64.new(cursor.id) ],
+          }
+        end
+
+        class << self
+
+          # Update a specification's list of cursor ids.
+          #
+          # @example Update a specification's list of cursor ids.
+          #   KillCursorsCommand.update_cursors(spec, ids)
+          #
+          # @return [ Hash ] The specification.
+          # @return [ Array<Integer> ] The ids to update with.
+          #
+          # @since 2.3.0
+          def update_cursors(spec, ids)
+            # Ruby 2.5+ can & BSON::Int64 instances.
+            # Ruby 2.4 and earlier cannot.
+            # Convert stored ids to Ruby integers for compatibility with
+            # older Rubies.
+            ids = get_cursors_list(spec) & ids
+            ids = ids.map do |cursor_id|
+              BSON::Int64.new(cursor_id)
+            end
+            spec[:selector].merge!(cursors: ids)
+          end
+
+          # Get the list of cursor ids from a spec generated by this Builder.
+          #
+          # @example Get the list of cursor ids.
+          #   KillCursorsCommand.cursors(spec)
+          #
+          # @return [ Array<Integer> ] The cursor ids.
+          #
+          # @since 2.3.0
+          def get_cursors_list(spec)
+            spec[:selector][:cursors].map do |value|
+              if value.respond_to?(:value)
+                # bson-ruby >= 4.6.0
+                value = value.value
+              else
+                value = value.instance_variable_get('@integer')
+              end
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/mongo/cursor/builder/op_get_more.rb b/lib/mongo/cursor/builder/op_get_more.rb
new file mode 100644
index 000000000..af5da4973
--- /dev/null
+++ b/lib/mongo/cursor/builder/op_get_more.rb
@@ -0,0 +1,64 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+# Copyright (C) 2015-2020 MongoDB Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module Mongo
+  class Cursor
+    module Builder
+
+      # Encapsulates behavior around generating an OP_GET_MORE specification.
+      #
+      # @since 2.2.0
+      class OpGetMore
+        extend Forwardable
+
+        # @return [ Cursor ] cursor The cursor.
+        attr_reader :cursor
+
+        def_delegators :@cursor, :collection_name, :database, :to_return
+
+        # Create the new builder.
+        #
+        # @example Create the builder.
+        #   OpGetMore.new(cursor)
+        #
+        # @param [ Cursor ] cursor The cursor.
+        #
+        # @since 2.2.0
+        def initialize(cursor)
+          @cursor = cursor
+        end
+
+        # Get the specification.
+        #
+        # @example Get the specification.
+        #   op_get_more.specification
+        #
+        # @return [ Hash ] The specification.
+        #
+        # @since 2.2.0
+        def specification
+          {
+            :to_return => to_return,
+            :cursor_id => BSON::Int64.new(cursor.id),
+            :db_name   => database.name,
+            :coll_name => collection_name,
+          }
+        end
+      end
+    end
+  end
+end
diff --git a/lib/mongo/cursor/builder/op_kill_cursors.rb b/lib/mongo/cursor/builder/op_kill_cursors.rb
new file mode 100644
index 000000000..8e9d80dce
--- /dev/null
+++ b/lib/mongo/cursor/builder/op_kill_cursors.rb
@@ -0,0 +1,106 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+# Copyright (C) 2015-2020 MongoDB Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module Mongo
+  class Cursor
+    module Builder
+
+      # Encapsulates behavior around generating an OP_KILL_CURSORS specification.
+      #
+      # @since 2.2.0
+      class OpKillCursors
+        extend Forwardable
+
+        # @return [ Cursor ] cursor The cursor.
+        attr_reader :cursor
+
+        def_delegators :@cursor, :collection_name, :database
+
+        # Create the new builder.
+        #
+        # @example Create the builder.
+        #   OpKillCursors.new(cursor)
+        #
+        # @param [ Cursor ] cursor The cursor.
+        #
+        # @since 2.2.0
+        def initialize(cursor)
+          @cursor = cursor
+        end
+
+        # Get the specification.
+        #
+        # @example Get the specification.
+        #   op_kill_cursors.specification
+        #
+        # @return [ Hash ] The specification.
+        #
+        # @since 2.2.0
+        def specification
+          {
+            coll_name: collection_name,
+            db_name: database.name,
+            cursor_ids: [ BSON::Int64.new(cursor.id) ],
+          }
+        end
+
+        class << self
+
+          # Update a specification's list of cursor ids.
+          #
+          # @example Update a specification's list of cursor ids.
+          #   OpKillCursors.update_cursors(spec, ids)
+          #
+          # @return [ Hash ] The specification.
+          # @return [ Array<Integer> ] The ids to update with.
+          #
+          # @since 2.3.0
+          def update_cursors(spec, ids)
+            # Ruby 2.5+ can & BSON::Int64 instances.
+            # Ruby 2.4 and earlier cannot.
+            # Convert stored ids to Ruby integers for compatibility with
+            # older Rubies.
+            ids = get_cursors_list(spec) & ids
+            ids = ids.map do |cursor_id|
+              BSON::Int64.new(cursor_id)
+            end
+            spec.merge!(cursor_ids: ids)
+          end
+
+          # Get the list of cursor ids from a spec generated by this Builder.
+          #
+          # @example Get the list of cursor ids.
+          #   OpKillCursors.cursors(spec)
+          #
+          # @return [ Array<Integer> ] The cursor ids.
+          #
+          # @since 2.3.0
+          def get_cursors_list(spec)
+            spec[:cursor_ids].map do |value|
+              if value.respond_to?(:value)
+                # bson-ruby >= 4.6.0
+                value.value
+              else
+                value.instance_variable_get('@integer')
+              end
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/mongo/cursor/kill_spec.rb b/lib/mongo/cursor/kill_spec.rb
deleted file mode 100644
index b28e9b0e3..000000000
--- a/lib/mongo/cursor/kill_spec.rb
+++ /dev/null
@@ -1,38 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  class Cursor
-
-    # This class contains the operation specification for KillCursors.
-    #
-    # Its purpose is to ensure we don't misspell attribute names accidentally.
-    #
-    # @api private
-    class KillSpec
-
-      def initialize(cursor_id:, coll_name:, db_name:, service_id:)
-        @cursor_id = cursor_id
-        @coll_name = coll_name
-        @db_name = db_name
-        @service_id = service_id
-      end
-
-      attr_reader :cursor_id, :coll_name, :db_name, :service_id
-    end
-  end
-end
diff --git a/lib/mongo/database/view.rb b/lib/mongo/database/view.rb
index 32492439e..940f0dc23 100644
--- a/lib/mongo/database/view.rb
+++ b/lib/mongo/database/view.rb
@@ -68,7 +68,7 @@ module Mongo
           send_initial_query(server, session, options.merge(name_only: true))
         end
         cursor.map do |info|
-          if cursor.initial_result.connection_description.features.list_collections_enabled?
+          if cursor.server.with_connection { |connection| connection.features }.list_collections_enabled?
             info['name']
           else
             (info['name'] &&
diff --git a/lib/mongo/error.rb b/lib/mongo/error.rb
index 5d6921e77..6f0458d65 100644
--- a/lib/mongo/error.rb
+++ b/lib/mongo/error.rb
@@ -217,7 +217,6 @@ require 'mongo/error/mismatched_domain'
 require 'mongo/error/mongocryptd_spawn_error'
 require 'mongo/error/multi_index_drop'
 require 'mongo/error/need_primary_server'
-require 'mongo/error/no_service_connection_available'
 require 'mongo/error/no_server_available'
 require 'mongo/error/no_srv_records'
 require 'mongo/error/session_ended'
diff --git a/lib/mongo/error/no_service_connection_available.rb b/lib/mongo/error/no_service_connection_available.rb
deleted file mode 100644
index 8a7513b6b..000000000
--- a/lib/mongo/error/no_service_connection_available.rb
+++ /dev/null
@@ -1,49 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  class Error
-
-    # Raised when the driver requires a connection to a particular service
-    # but no matching connections exist in the connection pool.
-    class NoServiceConnectionAvailable < Error
-      # @api private
-      def initialize(message, address:, service_id:)
-        super(message)
-
-        @address = address
-        @service_id = service_id
-      end
-
-      # @return [ Mongo::Address ] The address to which a connection was
-      #   requested.
-      attr_reader :address
-
-      # @return [ nil | Object ] The service id.
-      attr_reader :service_id
-
-      # @api private
-      def self.generate(address:, service_id:)
-        new(
-          "The connection pool for #{address} does not have a connection for service #{service_id}",
-          address: address,
-          service_id: service_id,
-        )
-      end
-    end
-  end
-end
diff --git a/lib/mongo/error/notable.rb b/lib/mongo/error/notable.rb
index 7590875bc..30a58ebc2 100644
--- a/lib/mongo/error/notable.rb
+++ b/lib/mongo/error/notable.rb
@@ -63,13 +63,6 @@ module Mongo
       # @return [ Integer | nil ] Connection pool generation.
       attr_accessor :generation
 
-      # Returns service id for the connection on which the error occurred.
-      #
-      # @return [ Object | nil ] Service id.
-      #
-      # @api experimental
-      attr_accessor :service_id
-
       # @api public
       def to_s
         super + notes_tail
diff --git a/lib/mongo/index/view.rb b/lib/mongo/index/view.rb
index dfb3a347a..9fe651d5f 100644
--- a/lib/mongo/index/view.rb
+++ b/lib/mongo/index/view.rb
@@ -129,10 +129,7 @@ module Mongo
       # @option options [ String | Integer ] :commit_quorum Specify how many
       #   data-bearing members of a replica set, including the primary, must
       #   complete the index builds successfully before the primary marks
-      #   the indexes as ready. Potential values are:
-      #   - an integer from 0 to the number of members of the replica set
-      #   - "majority" indicating that a majority of data bearing nodes must vote
-      #   - "votingMembers" which means that all voting data bearing nodes must vote
+      #   the indexes as ready.
       # @option options [ Session ] :session The session to use for the operation.
       #
       # @note Note that the options listed may be subset of those available.
@@ -180,10 +177,7 @@ module Mongo
       #   The following options are accepted:
       #   - commit_quorum: Specify how many data-bearing members of a replica set,
       #     including the primary, must complete the index builds successfully
-      #     before the primary marks the indexes as ready. Potential values are:
-      #     - an integer from 0 to the number of members of the replica set
-      #     - "majority" indicating that a majority of data bearing nodes must vote
-      #     - "votingMembers" which means that all voting data bearing nodes must vote
+      #     before the primary marks the indexes as ready.
       #   - session: The session to use.
       #
       # @return [ Result ] The result of the command.
@@ -199,6 +193,17 @@ module Mongo
         client.send(:with_session, @options.merge(options)) do |session|
           server = next_primary(nil, session)
 
+          # While server versions 3.4 and newer generally perform option
+          # validation, there was a bug on server versions 4.2.0 - 4.2.5 where
+          # the server would accept the commitQuorum option and use it internally
+          # (see SERVER-47193). As a result, the drivers specifications require
+          # drivers to perform validation and raise an error when the commitQuorum
+          # option is passed to servers that don't support it.
+          description = server.with_connection { |connection| connection.description }
+          if description.max_wire_version < 9 && options[:commit_quorum]
+            raise Error::UnsupportedOption.commit_quorum_error
+          end
+
           indexes = normalize_models(models, server)
           indexes.each do |index|
             if index[:bucketSize] || index['bucketSize']
@@ -211,9 +216,10 @@ module Mongo
             db_name: database.name,
             coll_name: collection.name,
             session: session,
-            commit_quorum: options[:commit_quorum],
-            write_concern: write_concern,
-          }
+            commit_quorum: options[:commit_quorum]
+           }
+
+          spec[:write_concern] = write_concern if description.features.collation_enabled?
 
           Operation::CreateIndex.new(spec).execute(server, context: Operation::Context.new(client: client, session: session))
         end
@@ -286,13 +292,13 @@ module Mongo
       def drop_by_name(name)
         client.send(:with_session, @options) do |session|
           spec = {
-            db_name: database.name,
-            coll_name: collection.name,
-            index_name: name,
-            session: session,
-            write_concern: write_concern,
-          }
+                   db_name: database.name,
+                   coll_name: collection.name,
+                   index_name: name,
+                   session: session
+                 }
           server = next_primary(nil, session)
+          spec[:write_concern] = write_concern if server.with_connection { |connection| connection.features }.collation_enabled?
           Operation::DropIndex.new(spec).execute(server, context: Operation::Context.new(client: client, session: session))
         end
       end
@@ -323,17 +329,30 @@ module Mongo
       end
 
       def normalize_models(models, server)
-        models.map do |model|
-          # Transform options first which gives us a mutable hash
-          Options::Mapper.transform(model, OPTIONS).tap do |model|
-            model[:name] ||= index_name(model.fetch(:key))
-          end
+        with_generated_names(models, server).map do |model|
+          Options::Mapper.transform(model, OPTIONS)
         end
       end
 
       def send_initial_query(server, session)
         initial_query_op(session).execute(server, context: Operation::Context.new(client: client, session: session))
       end
+
+      def with_generated_names(models, server)
+        models.dup.each do |model|
+          validate_collation!(model, server)
+          unless model[:name]
+            model[:name] = index_name(model[:key])
+          end
+        end
+      end
+
+      def validate_collation!(model, server)
+        if (model[:collation] || model[Operation::COLLATION]) &&
+            !server.with_connection { |connection| connection.features }.collation_enabled?
+          raise Error::UnsupportedCollation.new
+        end
+      end
     end
   end
 end
diff --git a/lib/mongo/monitoring/event/cmap/pool_cleared.rb b/lib/mongo/monitoring/event/cmap/pool_cleared.rb
index 82ce9dd25..a3934b7ad 100644
--- a/lib/mongo/monitoring/event/cmap/pool_cleared.rb
+++ b/lib/mongo/monitoring/event/cmap/pool_cleared.rb
@@ -31,18 +31,15 @@ module Mongo
           # @since 2.9.0
           attr_reader :address
 
-          # @return [ nil | Object ] The service id, if any.
-          attr_reader :service_id
-
           # Create the event.
           #
-          # @param [ Address ] address
-          # @param [ Object ] service_id The service id, if any.
+          # @example Create the event.
+          #   PoolCleared.new(address)
           #
+          # @since 2.9.0
           # @api private
-          def initialize(address, service_id: nil)
+          def initialize(address)
             @address = address
-            @service_id = service_id
           end
 
           # Returns a concise yet useful summary of the event.
diff --git a/lib/mongo/monitoring/event/command_failed.rb b/lib/mongo/monitoring/event/command_failed.rb
index 15e5f26e6..33bf017da 100644
--- a/lib/mongo/monitoring/event/command_failed.rb
+++ b/lib/mongo/monitoring/event/command_failed.rb
@@ -88,11 +88,11 @@ module Mongo
           @address = address
           @request_id = request_id
           @operation_id = operation_id
-          @service_id = service_id
           @message = message
           @started_event = started_event
           @failure = redacted(command_name, failure)
           @duration = duration
+          @service_id = service_id
         end
 
         # Returns a concise yet useful summary of the event.
diff --git a/lib/mongo/monitoring/event/command_started.rb b/lib/mongo/monitoring/event/command_started.rb
index 76e2f6bfe..8a78b8c78 100644
--- a/lib/mongo/monitoring/event/command_started.rb
+++ b/lib/mongo/monitoring/event/command_started.rb
@@ -78,7 +78,6 @@ module Mongo
         # @param [ Integer ] request_id The request id.
         # @param [ Integer ] operation_id The operation id.
         # @param [ BSON::Document ] command The command arguments.
-        # @param [ Object ] service_id The service id, if any.
         #
         # @since 2.1.0
         # @api private
@@ -141,7 +140,6 @@ module Mongo
         # @param [ Server::Address ] address The server address.
         # @param [ Integer ] operation_id The operation id.
         # @param [ Hash ] payload The message payload.
-        # @param [ Object ] service_id The service id, if any.
         #
         # @return [ CommandStarted ] The event.
         #
diff --git a/lib/mongo/monitoring/publishable.rb b/lib/mongo/monitoring/publishable.rb
index c168bf669..3128b5f95 100644
--- a/lib/mongo/monitoring/publishable.rb
+++ b/lib/mongo/monitoring/publishable.rb
@@ -35,6 +35,7 @@ module Mongo
       def publish_sdam_event(topic, event)
         return unless monitoring?
 
+        #log_debug("EVENT: #{event.summary}")
         monitoring.succeeded(topic, event)
       end
 
@@ -48,13 +49,12 @@ module Mongo
 
       def command_started(address, operation_id, payload,
         socket_object_id: nil, connection_id: nil, connection_generation: nil,
-        server_connection_id: nil, service_id: nil
+        server_connection_id: nil
       )
         event = Event::CommandStarted.generate(address, operation_id, payload,
             socket_object_id: socket_object_id, connection_id: connection_id,
             connection_generation: connection_generation,
             server_connection_id: server_connection_id,
-            service_id: service_id,
           )
         monitoring.started(
           Monitoring::COMMAND,
diff --git a/lib/mongo/operation.rb b/lib/mongo/operation.rb
index 1d345ad54..1160a69f4 100644
--- a/lib/mongo/operation.rb
+++ b/lib/mongo/operation.rb
@@ -20,14 +20,12 @@ require 'mongo/operation/shared/causal_consistency_supported'
 require 'mongo/operation/shared/write'
 require 'mongo/operation/shared/idable'
 require 'mongo/operation/shared/specifiable'
-require 'mongo/operation/shared/validatable'
 require 'mongo/operation/shared/object_id_generator'
 require 'mongo/operation/shared/op_msg_or_command'
 require 'mongo/operation/shared/op_msg_or_find_command'
 
 require 'mongo/operation/op_msg_base'
 require 'mongo/operation/command'
-require 'mongo/operation/write_command'
 require 'mongo/operation/aggregate'
 require 'mongo/operation/result'
 require 'mongo/operation/collections_info'
@@ -56,14 +54,6 @@ require 'mongo/operation/drop_index'
 
 module Mongo
 
-  # This module encapsulates all of the operation classes defined by the driver.
-  #
-  # The operation classes take Ruby options as constructor parameters.
-  # For example, :read contains read preference and :read_concern contains read
-  # concern, whereas server commands use readConcern field for the read
-  # concern and read preference is passed as $readPreference or secondaryOk
-  # wire protocol flag bit.
-  #
   # @api private
   module Operation
 
diff --git a/lib/mongo/operation/aggregate/command.rb b/lib/mongo/operation/aggregate/command.rb
index 9239d2fea..40f6d11ab 100644
--- a/lib/mongo/operation/aggregate/command.rb
+++ b/lib/mongo/operation/aggregate/command.rb
@@ -34,14 +34,6 @@ module Mongo
 
         private
 
-        def selector(connection)
-          super.tap do |selector|
-            if selector[:collation] && !connection.features.collation_enabled?
-              raise Error::UnsupportedCollation
-            end
-          end
-        end
-
         def write_concern_supported?(connection)
           connection.features.collation_enabled?
         end
diff --git a/lib/mongo/operation/context.rb b/lib/mongo/operation/context.rb
index dae3cd98b..29f3a6e24 100644
--- a/lib/mongo/operation/context.rb
+++ b/lib/mongo/operation/context.rb
@@ -24,18 +24,9 @@ module Mongo
     # in a single container, and provides facade methods for the contained
     # objects.
     #
-    # The context contains parameters for operations, and as such while an
-    # operation is being prepared nothing in the context should change.
-    # When the result of the operation is being processed, the data
-    # returned by the context may change (for example, because a transaction
-    # is aborted), but at that point the operation should no longer read
-    # anything from the context. Because context data may change during
-    # operation execution, context objects should not be reused for multiple
-    # operations.
-    #
     # @api private
     class Context
-      def initialize(client: nil, session: nil, service_id: nil, options: nil)
+      def initialize(client: nil, session: nil, options: nil)
         if options
           if client
             raise ArgumentError, 'Client and options cannot both be specified'
@@ -46,13 +37,8 @@ module Mongo
           end
         end
 
-        if service_id && session&.pinned_service_id
-          raise ArgumentError, 'Trying to pin context to a service when the session is already pinned to a service'
-        end
-
         @client = client
         @session = session
-        @service_id = service_id
         @options = options
       end
 
@@ -60,10 +46,6 @@ module Mongo
       attr_reader :session
       attr_reader :options
 
-      def service_id
-        @service_id || session&.pinned_service_id
-      end
-
       def in_transaction?
         session&.in_transaction? || false
       end
diff --git a/lib/mongo/operation/count/command.rb b/lib/mongo/operation/count/command.rb
index a2d38016b..aafe09432 100644
--- a/lib/mongo/operation/count/command.rb
+++ b/lib/mongo/operation/count/command.rb
@@ -32,12 +32,6 @@ module Mongo
 
         private
 
-        def selector(connection)
-          selector = spec[:selector]
-          selector = apply_collation(selector, connection, spec[:collation])
-          selector
-        end
-
         def message(connection)
           Protocol::Query.new(db_name, Database::COMMAND, command(connection), options(connection))
         end
diff --git a/lib/mongo/operation/count/op_msg.rb b/lib/mongo/operation/count/op_msg.rb
index 6e0bcfda8..ff47a9d0c 100644
--- a/lib/mongo/operation/count/op_msg.rb
+++ b/lib/mongo/operation/count/op_msg.rb
@@ -26,12 +26,6 @@ module Mongo
       # @since 2.5.2
       class OpMsg < OpMsgBase
         include CausalConsistencySupported
-
-        private
-
-        def selector(connection)
-          Utils.compact_hash(spec[:selector].merge(collation: spec[:collation]))
-        end
       end
     end
   end
diff --git a/lib/mongo/operation/create/command.rb b/lib/mongo/operation/create/command.rb
index 2cef393c9..b6e344d68 100644
--- a/lib/mongo/operation/create/command.rb
+++ b/lib/mongo/operation/create/command.rb
@@ -19,7 +19,7 @@ module Mongo
   module Operation
     class Create
 
-      # A MongoDB create collection operation sent as a command message.
+      # A MongoDB count operation sent as a command message.
       #
       # @api private
       #
@@ -32,12 +32,6 @@ module Mongo
 
         private
 
-        def selector(connection)
-          selector = spec[:selector]
-          selector = apply_collation(selector, connection, spec[:collation])
-          selector
-        end
-
         def message(connection)
           Protocol::Query.new(db_name, Database::COMMAND, command(connection), options(connection))
         end
diff --git a/lib/mongo/operation/create/op_msg.rb b/lib/mongo/operation/create/op_msg.rb
index 3914a894c..5e84c740b 100644
--- a/lib/mongo/operation/create/op_msg.rb
+++ b/lib/mongo/operation/create/op_msg.rb
@@ -26,13 +26,6 @@ module Mongo
       # @since 2.5.2
       class OpMsg < OpMsgBase
         include ExecutableTransactionLabel
-
-        private
-
-        def selector(connection)
-          # Collation is always supported on 3.6+ servers that would use OP_MSG.
-          Utils.compact_hash(spec[:selector].merge(collation: spec[:collation]))
-        end
       end
     end
   end
diff --git a/lib/mongo/operation/create_index/command.rb b/lib/mongo/operation/create_index/command.rb
index 5bbf6a8c5..b2bf221e2 100644
--- a/lib/mongo/operation/create_index/command.rb
+++ b/lib/mongo/operation/create_index/command.rb
@@ -33,23 +33,7 @@ module Mongo
         private
 
         def selector(connection)
-          indexes.each do |index|
-            if index[:collation] && !connection.features.collation_enabled?
-              raise Error::UnsupportedCollation
-            end
-          end
-
-          {
-            createIndexes: coll_name,
-            indexes: indexes,
-          }.tap do |selector|
-            if commit_quorum = spec[:commit_quorum]
-              unless connection.features.commit_quorum_enabled?
-                raise Error::UnsupportedOption.commit_quorum_error
-              end
-              selector[:commitQuorum] = commit_quorum
-            end
-          end
+          { :createIndexes => coll_name, :indexes => indexes }
         end
 
         def message(connection)
diff --git a/lib/mongo/operation/create_index/op_msg.rb b/lib/mongo/operation/create_index/op_msg.rb
index f1a0d2e9a..d0334352d 100644
--- a/lib/mongo/operation/create_index/op_msg.rb
+++ b/lib/mongo/operation/create_index/op_msg.rb
@@ -30,23 +30,10 @@ module Mongo
         private
 
         def selector(connection)
-          {
-            createIndexes: coll_name,
-            indexes: indexes,
-          }.tap do |selector|
-            if commit_quorum = spec[:commit_quorum]
-              # While server versions 3.4 and newer generally perform option
-              # validation, there was a bug on server versions 4.2.0 - 4.2.5 where
-              # the server would accept the commitQuorum option and use it internally
-              # (see SERVER-47193). As a result, the drivers specifications require
-              # drivers to perform validation and raise an error when the commitQuorum
-              # option is passed to servers that don't support it.
-              unless connection.features.commit_quorum_enabled?
-                raise Error::UnsupportedOption.commit_quorum_error
-              end
-              selector[:commitQuorum] = commit_quorum
-            end
-          end
+          selector = { :createIndexes => coll_name, :indexes => indexes }
+          selector[:commitQuorum] = commit_quorum if commit_quorum
+
+          selector
         end
       end
     end
diff --git a/lib/mongo/operation/delete/command.rb b/lib/mongo/operation/delete/command.rb
index e1e3ea485..8ee2dfe15 100644
--- a/lib/mongo/operation/delete/command.rb
+++ b/lib/mongo/operation/delete/command.rb
@@ -31,16 +31,13 @@ module Mongo
         include WriteConcernSupported
         include ExecutableNoValidate
         include PolymorphicResult
-        include Validatable
 
         private
 
         def selector(connection)
-          {
-            delete: coll_name,
-            deletes: validate_updates(connection, send(IDENTIFIER)),
-            ordered: ordered?,
-          }
+          { delete: coll_name,
+            deletes: send(IDENTIFIER),
+            ordered: ordered? }
         end
 
         def message(connection)
diff --git a/lib/mongo/operation/delete/legacy.rb b/lib/mongo/operation/delete/legacy.rb
index c5ec9375a..5dbf85b1c 100644
--- a/lib/mongo/operation/delete/legacy.rb
+++ b/lib/mongo/operation/delete/legacy.rb
@@ -28,21 +28,14 @@ module Mongo
         include Specifiable
         include Executable
         include PolymorphicResult
-        include Validatable
 
         private
 
-        def selector(connection)
-          # This returns the first delete.
-          # The driver only puts one delete into the list normally, so this
-          # doesn't discard operations.
-          send(IDENTIFIER).first.tap do |selector|
-            validate_find_options(connection, selector)
-          end
+        def selector
+          send(IDENTIFIER).first
         end
 
         def message(connection)
-          selector = selector(connection)
           opts = (selector[Operation::LIMIT] || 0) <= 0 ? {} : { :flags => [ :single_remove ] }
           Protocol::Delete.new(db_name, coll_name, selector[Operation::Q], opts)
         end
diff --git a/lib/mongo/operation/delete/op_msg.rb b/lib/mongo/operation/delete/op_msg.rb
index d68b50e6e..627d07774 100644
--- a/lib/mongo/operation/delete/op_msg.rb
+++ b/lib/mongo/operation/delete/op_msg.rb
@@ -29,20 +29,13 @@ module Mongo
         include ExecutableNoValidate
         include ExecutableTransactionLabel
         include PolymorphicResult
-        include Validatable
 
         private
 
         def selector(connection)
           { delete: coll_name,
             Protocol::Msg::DATABASE_IDENTIFIER => db_name,
-            ordered: ordered?,
-          }.tap do |selector|
-            if hint = spec[:hint]
-              validate_hint_on_update(connection, selector)
-              selector[:hint] = hint
-            end
-          end
+            ordered: ordered? }
         end
 
         def message(connection)
diff --git a/lib/mongo/operation/distinct/command.rb b/lib/mongo/operation/distinct/command.rb
index 091ae0586..6acfb011e 100644
--- a/lib/mongo/operation/distinct/command.rb
+++ b/lib/mongo/operation/distinct/command.rb
@@ -32,12 +32,6 @@ module Mongo
 
         private
 
-        def selector(connection)
-          selector = spec[:selector]
-          selector = apply_collation(selector, connection, spec[:collation])
-          selector
-        end
-
         def message(connection)
           Protocol::Query.new(db_name, Database::COMMAND, command(connection), options(connection))
         end
diff --git a/lib/mongo/operation/distinct/op_msg.rb b/lib/mongo/operation/distinct/op_msg.rb
index 7914d5af3..0ab1b08f9 100644
--- a/lib/mongo/operation/distinct/op_msg.rb
+++ b/lib/mongo/operation/distinct/op_msg.rb
@@ -27,13 +27,6 @@ module Mongo
       class OpMsg < OpMsgBase
         include CausalConsistencySupported
         include ExecutableTransactionLabel
-
-        private
-
-        def selector(connection)
-          # Collation is always supported on 3.6+ servers that would use OP_MSG.
-          Utils.compact_hash(spec[:selector].merge(collation: spec[:collation]))
-        end
       end
     end
   end
diff --git a/lib/mongo/operation/explain/command.rb b/lib/mongo/operation/explain/command.rb
index 05c2783be..1fedc83e1 100644
--- a/lib/mongo/operation/explain/command.rb
+++ b/lib/mongo/operation/explain/command.rb
@@ -34,19 +34,7 @@ module Mongo
         private
 
         def selector(connection)
-          # The mappings are BSON::Documents and as such store keys as
-          # strings, the spec here has symbol keys.
-          spec = BSON::Document.new(self.spec)
-
-          if spec[:collation] && !connection.features.collation_enabled?
-            raise Error::UnsupportedCollation
-          end
-
-          {
-            explain: {
-              find: coll_name,
-            }.update(Find::Builder::Command.selector(spec, connection)),
-          }.update(spec[:explain] || {})
+          super.merge(spec[:explain])
         end
 
         def message(connection)
diff --git a/lib/mongo/operation/explain/legacy.rb b/lib/mongo/operation/explain/legacy.rb
index cd54bc6b2..a1496d893 100644
--- a/lib/mongo/operation/explain/legacy.rb
+++ b/lib/mongo/operation/explain/legacy.rb
@@ -32,19 +32,12 @@ module Mongo
 
         private
 
-        def message(connection)
-          if spec[:collation] && !connection.features.collation_enabled?
-            raise Error::UnsupportedCollation
-          end
+        def selector(connection)
+          super.merge(spec[:explain])
+        end
 
-          Protocol::Query.new(
-            db_name,
-            coll_name,
-            Find::Builder::Legacy.selector(spec, connection),
-            options(connection).update(
-              Find::Builder::Legacy.query_options(spec, connection),
-            ),
-          )
+        def message(connection)
+          Protocol::Query.new(db_name, coll_name, command(connection), options(connection))
         end
       end
     end
diff --git a/lib/mongo/operation/explain/op_msg.rb b/lib/mongo/operation/explain/op_msg.rb
index 1500045e2..93db9a0ee 100644
--- a/lib/mongo/operation/explain/op_msg.rb
+++ b/lib/mongo/operation/explain/op_msg.rb
@@ -32,15 +32,7 @@ module Mongo
         private
 
         def selector(connection)
-          # The mappings are BSON::Documents and as such store keys as
-          # strings, the spec here has symbol keys.
-          spec = BSON::Document.new(self.spec)
-          {
-            explain: {
-              find: coll_name,
-            }.update(Find::Builder::Command.selector(spec, connection)),
-            Protocol::Msg::DATABASE_IDENTIFIER => db_name,
-          }.update(spec[:explain] || {})
+          super.merge(spec[:explain])
         end
       end
     end
diff --git a/lib/mongo/operation/find.rb b/lib/mongo/operation/find.rb
index a4528c015..6c2540ec3 100644
--- a/lib/mongo/operation/find.rb
+++ b/lib/mongo/operation/find.rb
@@ -19,7 +19,6 @@ require 'mongo/operation/find/command'
 require 'mongo/operation/find/op_msg'
 require 'mongo/operation/find/legacy'
 require 'mongo/operation/find/result'
-require 'mongo/operation/find/builder'
 
 module Mongo
   module Operation
diff --git a/lib/mongo/operation/find/builder/command.rb b/lib/mongo/operation/find/builder/command.rb
deleted file mode 100644
index b19dcb7c4..000000000
--- a/lib/mongo/operation/find/builder/command.rb
+++ /dev/null
@@ -1,110 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2015-2020 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  module Operation
-    class Find
-      module Builder
-
-        # Builds a find command specification from options.
-        #
-        # @api private
-        module Command
-
-          # The mappings from ruby options to the find command.
-          OPTION_MAPPINGS = BSON::Document.new(
-            allow_disk_use: 'allowDiskUse',
-            allow_partial_results: 'allowPartialResults',
-            await_data: 'awaitData',
-            batch_size: 'batchSize',
-            collation: 'collation',
-            comment: 'comment',
-            filter: 'filter',
-            hint: 'hint',
-            limit: 'limit',
-            max_scan: 'maxScan',
-            max_time_ms: 'maxTimeMS',
-            max_value: 'max',
-            min_value: 'min',
-            no_cursor_timeout: 'noCursorTimeout',
-            oplog_replay: 'oplogReplay',
-            projection: 'projection',
-            read_concern: 'readConcern',
-            return_key: 'returnKey',
-            show_disk_loc: 'showRecordId',
-            single_batch: 'singleBatch',
-            skip: 'skip',
-            snapshot: 'snapshot',
-            sort: 'sort',
-            tailable: 'tailable',
-            tailable_cursor: 'tailable',
-          ).freeze
-
-          module_function def selector(spec, connection)
-            if spec[:collation] && !connection.features.collation_enabled?
-              raise Error::UnsupportedCollation
-            end
-
-            BSON::Document.new.tap do |selector|
-              OPTION_MAPPINGS.each do |k, server_k|
-                unless (value = spec[k]).nil?
-                  selector[server_k] = value
-                end
-              end
-
-              if rc = selector[:readConcern]
-                selector[:readConcern] = Options::Mapper.transform_values_to_strings(rc)
-              end
-
-              convert_limit_and_batch_size!(selector)
-            end
-          end
-
-          private
-
-          # Converts negative limit and batchSize parameters in the
-          # find command to positive ones. Removes the parameters if their
-          # values are zero.
-          #
-          # This is only used for find commmand, not for OP_QUERY path.
-          #
-          # The +command+ parameter is mutated by this method.
-          module_function def convert_limit_and_batch_size!(command)
-            if command[:limit] && command[:limit] < 0 &&
-              command[:batchSize] && command[:batchSize] < 0
-            then
-              command[:limit] = command[:limit].abs
-              command[:batchSize] = command[:limit].abs
-              command[:singleBatch] = true
-            else
-              [:limit, :batchSize].each do |opt|
-                if command[opt]
-                  if command[opt] < 0
-                    command[opt] = command[opt].abs
-                    command[:singleBatch] = true
-                  elsif command[opt] == 0
-                    command.delete(opt)
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/lib/mongo/operation/find/builder/legacy.rb b/lib/mongo/operation/find/builder/legacy.rb
deleted file mode 100644
index 47a2e59ad..000000000
--- a/lib/mongo/operation/find/builder/legacy.rb
+++ /dev/null
@@ -1,123 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2015-2020 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  module Operation
-    class Find
-      module Builder
-
-        # Builds a legacy OP_QUERY specification from options.
-        #
-        # @api private
-        module Legacy
-
-          # Mappings from driver options to legacy server values.
-          #
-          # @since 2.2.0
-          DRIVER_MAPPINGS = {
-            comment: '$comment',
-            explain: '$explain',
-            hint: '$hint',
-            max_scan: '$maxScan',
-            max_time_ms: '$maxTimeMS',
-            max_value: '$max',
-            min_value: '$min',
-            show_disk_loc: '$showDiskLoc',
-            snapshot: '$snapshot',
-            sort: '$orderby',
-            return_key: '$returnKey',
-          }.freeze
-
-          module_function def selector(spec, connection)
-            if Lint.enabled?
-              if spec.keys.any? { |k| String === k }
-                raise Error::LintError, "The spec must contain symbol keys only"
-              end
-            end
-
-            # Server versions that do not have the find command feature
-            # (versions older than 3.2) do not support the allow_disk_use option
-            # but perform no validation and will not raise an error if it is
-            # specified. If the allow_disk_use option is specified, raise an error
-            # to alert the user.
-            unless spec[:allow_disk_use].nil?
-              raise Error::UnsupportedOption.allow_disk_use_error
-            end
-
-            if spec[:collation] && !connection.features.collation_enabled?
-              raise Error::UnsupportedCollation
-            end
-
-            modifiers = {}
-            DRIVER_MAPPINGS.each do |k, server_k|
-              unless (value = spec[k]).nil?
-                modifiers[server_k] = value
-              end
-            end
-
-            selector = spec[:filter] || BSON::Document.new
-            # Write nil into rp if not talking to mongos, rather than false
-            rp = if connection.description.mongos?
-              read_pref_formatted(spec)
-            end
-            if modifiers.any? || rp
-              selector = {'$query' => selector}.update(modifiers)
-
-              if rp
-                selector['$readPreference'] = rp
-              end
-            end
-
-            selector
-          end
-
-          module_function def query_options(spec, connection)
-            query_options = {
-              project: spec[:projection],
-              skip: spec[:skip],
-              limit: spec[:limit],
-              # batch_size is converted to batchSize by Mongo::Protocol::Query.
-              batch_size: spec[:batch_size],
-            }
-
-            unless (flags = Builder::Flags.map_flags(spec)).empty?
-              query_options[:flags] = ((query_options[:flags] || []) + flags).uniq
-            end
-
-            query_options
-          end
-
-          private
-
-          module_function def read_pref_formatted(spec)
-            if spec[:read_preference]
-              raise ArgumentError, "Spec cannot include :read_preference here, use :read"
-            end
-
-            if read = spec[:read]
-              read_pref = ServerSelector.get(read).to_mongos
-              Mongo::Lint.validate_camel_case_read_preference(read_pref)
-              read_pref
-            else
-              nil
-            end
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/lib/mongo/operation/find/command.rb b/lib/mongo/operation/find/command.rb
index 181b557c1..38a277d62 100644
--- a/lib/mongo/operation/find/command.rb
+++ b/lib/mongo/operation/find/command.rb
@@ -33,15 +33,6 @@ module Mongo
 
         private
 
-        def selector(connection)
-          # The mappings are BSON::Documents and as such store keys as
-          # strings, the spec here has symbol keys
-          spec = BSON::Document.new(self.spec)
-          {
-            find: coll_name,
-          }.update(Find::Builder::Command.selector(spec, connection))
-        end
-
         def message(connection)
           Protocol::Query.new(db_name, Database::COMMAND, command(connection), options(connection))
         end
diff --git a/lib/mongo/operation/find/legacy.rb b/lib/mongo/operation/find/legacy.rb
index 33989d1b8..f219b6094 100644
--- a/lib/mongo/operation/find/legacy.rb
+++ b/lib/mongo/operation/find/legacy.rb
@@ -35,16 +35,7 @@ module Mongo
         private
 
         def message(connection)
-          selector = Find::Builder::Legacy.selector(spec, connection)
-          options = options(connection).update(
-            Find::Builder::Legacy.query_options(spec, connection),
-          )
-          Protocol::Query.new(
-            db_name,
-            coll_name,
-            selector,
-            options,
-          )
+          Protocol::Query.new(db_name, coll_name, command(connection), options(connection))
         end
       end
     end
diff --git a/lib/mongo/operation/find/op_msg.rb b/lib/mongo/operation/find/op_msg.rb
index 9ebe85c60..7eab6b06b 100644
--- a/lib/mongo/operation/find/op_msg.rb
+++ b/lib/mongo/operation/find/op_msg.rb
@@ -28,18 +28,6 @@ module Mongo
         include CausalConsistencySupported
         include ExecutableTransactionLabel
         include PolymorphicResult
-
-        private
-
-        def selector(connection)
-          # The mappings are BSON::Documents and as such store keys as
-          # strings, the spec here has symbol keys.
-          spec = BSON::Document.new(self.spec)
-          {
-            find: coll_name,
-            Protocol::Msg::DATABASE_IDENTIFIER => db_name,
-          }.update(Find::Builder::Command.selector(spec, connection))
-        end
       end
     end
   end
diff --git a/lib/mongo/operation/get_more.rb b/lib/mongo/operation/get_more.rb
index 455f8f639..d7db7ef73 100644
--- a/lib/mongo/operation/get_more.rb
+++ b/lib/mongo/operation/get_more.rb
@@ -15,7 +15,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-require 'mongo/operation/get_more/command_builder'
 require 'mongo/operation/get_more/command'
 require 'mongo/operation/get_more/op_msg'
 require 'mongo/operation/get_more/legacy'
diff --git a/lib/mongo/operation/get_more/command.rb b/lib/mongo/operation/get_more/command.rb
index 9188d20e1..29c94c7ee 100644
--- a/lib/mongo/operation/get_more/command.rb
+++ b/lib/mongo/operation/get_more/command.rb
@@ -30,7 +30,6 @@ module Mongo
         include Limited
         include ReadPreferenceSupported
         include PolymorphicResult
-        include CommandBuilder
 
         private
 
diff --git a/lib/mongo/operation/get_more/command_builder.rb b/lib/mongo/operation/get_more/command_builder.rb
deleted file mode 100644
index 2ee7d43c4..000000000
--- a/lib/mongo/operation/get_more/command_builder.rb
+++ /dev/null
@@ -1,38 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  module Operation
-    class GetMore
-
-      # @api private
-      module CommandBuilder
-
-        private
-
-        def selector(connection)
-          Utils.compact_hash(
-            getMore: BSON::Int64.new(spec.fetch(:cursor_id)),
-            collection: spec.fetch(:coll_name),
-            batchSize: spec[:batch_size],
-            maxTimeMS: spec[:max_time_ms],
-          )
-        end
-      end
-    end
-  end
-end
diff --git a/lib/mongo/operation/get_more/op_msg.rb b/lib/mongo/operation/get_more/op_msg.rb
index c0a4dda3d..b0fb66858 100644
--- a/lib/mongo/operation/get_more/op_msg.rb
+++ b/lib/mongo/operation/get_more/op_msg.rb
@@ -27,7 +27,6 @@ module Mongo
       class OpMsg < OpMsgBase
         include ExecutableTransactionLabel
         include PolymorphicResult
-        include CommandBuilder
       end
     end
   end
diff --git a/lib/mongo/operation/kill_cursors.rb b/lib/mongo/operation/kill_cursors.rb
index 505fb5451..d3e30323f 100644
--- a/lib/mongo/operation/kill_cursors.rb
+++ b/lib/mongo/operation/kill_cursors.rb
@@ -15,7 +15,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-require 'mongo/operation/kill_cursors/command_builder'
 require 'mongo/operation/kill_cursors/command'
 require 'mongo/operation/kill_cursors/op_msg'
 require 'mongo/operation/kill_cursors/legacy'
diff --git a/lib/mongo/operation/kill_cursors/command.rb b/lib/mongo/operation/kill_cursors/command.rb
index 2e12d3ef6..3a2df6db7 100644
--- a/lib/mongo/operation/kill_cursors/command.rb
+++ b/lib/mongo/operation/kill_cursors/command.rb
@@ -28,17 +28,9 @@ module Mongo
         include Specifiable
         include Executable
         include Limited
-        include CommandBuilder
 
         private
 
-        def selector(connection)
-          {
-            killCursors: coll_name,
-            cursors: int64_cursor_ids,
-          }
-        end
-
         def message(connection)
           Protocol::Query.new(db_name, Database::COMMAND, selector(connection), options(connection))
         end
diff --git a/lib/mongo/operation/kill_cursors/command_builder.rb b/lib/mongo/operation/kill_cursors/command_builder.rb
deleted file mode 100644
index 25e8356d8..000000000
--- a/lib/mongo/operation/kill_cursors/command_builder.rb
+++ /dev/null
@@ -1,35 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  module Operation
-    class KillCursors
-
-      # @api private
-      module CommandBuilder
-
-        private
-
-        def int64_cursor_ids
-          spec.fetch(:cursor_ids).map do |id|
-            BSON::Int64.new(id)
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/lib/mongo/operation/kill_cursors/legacy.rb b/lib/mongo/operation/kill_cursors/legacy.rb
index 6544a29cb..b994a7ef9 100644
--- a/lib/mongo/operation/kill_cursors/legacy.rb
+++ b/lib/mongo/operation/kill_cursors/legacy.rb
@@ -27,12 +27,11 @@ module Mongo
       class Legacy
         include Specifiable
         include Executable
-        include CommandBuilder
 
         private
 
         def message(connection)
-          Protocol::KillCursors.new(coll_name, db_name, int64_cursor_ids)
+          Protocol::KillCursors.new(coll_name, db_name, cursor_ids)
         end
       end
     end
diff --git a/lib/mongo/operation/kill_cursors/op_msg.rb b/lib/mongo/operation/kill_cursors/op_msg.rb
index 5744c72d4..7007bd646 100644
--- a/lib/mongo/operation/kill_cursors/op_msg.rb
+++ b/lib/mongo/operation/kill_cursors/op_msg.rb
@@ -26,16 +26,6 @@ module Mongo
       # @since 2.5.2
       class OpMsg < OpMsgBase
         include ExecutableTransactionLabel
-        include CommandBuilder
-
-        private
-
-        def selector(connection)
-          {
-            killCursors: coll_name,
-            cursors: int64_cursor_ids,
-          }
-        end
       end
     end
   end
diff --git a/lib/mongo/operation/map_reduce/command.rb b/lib/mongo/operation/map_reduce/command.rb
index 116dc6460..676b73758 100644
--- a/lib/mongo/operation/map_reduce/command.rb
+++ b/lib/mongo/operation/map_reduce/command.rb
@@ -34,14 +34,6 @@ module Mongo
 
         private
 
-        def selector(connection)
-          super.tap do |selector|
-            if selector[:collation] && !connection.features.collation_enabled?
-              raise Error::UnsupportedCollation
-            end
-          end
-        end
-
         def message(connection)
           Protocol::Query.new(db_name, Database::COMMAND, command(connection), options(connection))
         end
diff --git a/lib/mongo/operation/map_reduce/op_msg.rb b/lib/mongo/operation/map_reduce/op_msg.rb
index 80698032c..f4837a192 100644
--- a/lib/mongo/operation/map_reduce/op_msg.rb
+++ b/lib/mongo/operation/map_reduce/op_msg.rb
@@ -19,7 +19,7 @@ module Mongo
   module Operation
     class MapReduce
 
-      # A MongoDB map-reduce operation sent as an op message.
+      # A MongoDB mapreduce operation sent as an op message.
       #
       # @api private
       #
diff --git a/lib/mongo/operation/shared/executable.rb b/lib/mongo/operation/shared/executable.rb
index 5d689d1c6..c3dd0cf87 100644
--- a/lib/mongo/operation/shared/executable.rb
+++ b/lib/mongo/operation/shared/executable.rb
@@ -31,19 +31,6 @@ module Mongo
           add_error_labels(connection, context) do
             add_server_diagnostics(connection) do
               get_result(connection, context, options).tap do |result|
-                if session
-                  if session.in_transaction? &&
-                    connection.description.load_balancer?
-                  then
-                    if session.pinned_service_id
-                      unless session.pinned_service_id == connection.service_id
-                        raise Error::InternalDriverError, "Expected operation to use service #{session.pinned_session_id} but it used #{connection.service_id}"
-                      end
-                    else
-                      session.pin_to_service(connection.service_id)
-                    end
-                  end
-                end
                 process_result(result, connection)
               end
             end
@@ -118,7 +105,6 @@ module Mongo
           connection.server.unknown!(
             keep_connection_pool: keep_pool,
             generation: connection.generation,
-            service_id: connection.service_id,
             topology_version: result.topology_version,
           )
 
diff --git a/lib/mongo/operation/shared/polymorphic_operation.rb b/lib/mongo/operation/shared/polymorphic_operation.rb
index 56508a0b8..f3069f45e 100644
--- a/lib/mongo/operation/shared/polymorphic_operation.rb
+++ b/lib/mongo/operation/shared/polymorphic_operation.rb
@@ -32,7 +32,7 @@ module Mongo
       #
       # @return [ Mongo::Operation::Result ] The operation result.
       def execute(server, context:, options: {})
-        server.with_connection(service_id: context.service_id) do |connection|
+        server.with_connection do |connection|
           operation = final_operation(connection)
           operation.execute(connection, context: context, options: options)
         end
diff --git a/lib/mongo/operation/shared/read_preference_supported.rb b/lib/mongo/operation/shared/read_preference_supported.rb
index ae3af1574..18a31d72a 100644
--- a/lib/mongo/operation/shared/read_preference_supported.rb
+++ b/lib/mongo/operation/shared/read_preference_supported.rb
@@ -96,9 +96,7 @@ module Mongo
       #
       # @return [ Hash ] New command document to send to the server.
       def add_read_preference_legacy(sel, connection)
-        if read && (
-          connection.description.mongos? || connection.description.load_balancer?
-        ) && read_pref = read.to_mongos
+        if read && connection.description.mongos? && read_pref = read.to_mongos
           # If the read preference contains only mode and mode is secondary
           # preferred and we are sending to a pre-OP_MSG server, this read
           # preference is indicated by the :secondary_ok wire protocol flag
diff --git a/lib/mongo/operation/shared/response_handling.rb b/lib/mongo/operation/shared/response_handling.rb
index 490f0c4de..358cc40f8 100644
--- a/lib/mongo/operation/shared/response_handling.rb
+++ b/lib/mongo/operation/shared/response_handling.rb
@@ -112,7 +112,6 @@ module Mongo
       rescue Error, Error::AuthError => e
         e.add_note("on #{connection.address.seed}")
         e.generation = connection.generation
-        e.service_id = connection.service_id
         raise e
       end
 
diff --git a/lib/mongo/operation/shared/sessions_supported.rb b/lib/mongo/operation/shared/sessions_supported.rb
index d2328e642..c2eb57c4b 100644
--- a/lib/mongo/operation/shared/sessions_supported.rb
+++ b/lib/mongo/operation/shared/sessions_supported.rb
@@ -133,7 +133,7 @@ module Mongo
           end
         end
 
-        sel = BSON::Document.new(selector(connection))
+        sel = selector(connection).dup
         add_write_concern!(sel)
         sel[Protocol::Msg::DATABASE_IDENTIFIER] = db_name
 
@@ -169,11 +169,8 @@ module Mongo
         Lint.assert_type(connection, Server::Connection)
 
         # https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst#topology-type-single
-        read_doc = if connection.description.standalone?
+        if connection.description.standalone?
           # Read preference is never sent to standalones.
-          nil
-        elsif connection.server.load_balancer?
-          read&.to_mongos
         elsif connection.description.mongos?
           # When server is a mongos:
           # - $readPreference is never sent when mode is 'primary'
@@ -181,7 +178,12 @@ module Mongo
           # When mode is 'secondaryPreferred' $readPreference is currently
           # required to only be sent when a non-mode field (i.e. tag_sets)
           # is present, but this causes wrong behavior (DRIVERS-1642).
-          read&.to_mongos
+          if read
+            doc = read.to_mongos
+            if doc
+              sel['$readPreference'] = doc
+            end
+          end
         elsif connection.server.cluster.single?
           # In Single topology:
           # - If no read preference is specified by the application, the driver
@@ -196,15 +198,13 @@ module Mongo
           if [nil, 'primary'].include?(read_doc['mode'])
             read_doc['mode'] = 'primaryPreferred'
           end
-          read_doc
+          sel['$readPreference'] = read_doc
         else
           # In replica sets, read preference is passed to the server if one
           # is specified by the application, and there is no default.
-          read&.to_doc
-        end
-
-        if read_doc
-          sel['$readPreference'] = read_doc
+          if read
+            sel['$readPreference'] = read.to_doc
+          end
         end
       end
 
diff --git a/lib/mongo/operation/shared/specifiable.rb b/lib/mongo/operation/shared/specifiable.rb
index 7c358d82e..3373de537 100644
--- a/lib/mongo/operation/shared/specifiable.rb
+++ b/lib/mongo/operation/shared/specifiable.rb
@@ -60,6 +60,11 @@ module Mongo
       # @since 2.0.0
       CURSOR_ID = :cursor_id.freeze
 
+      # The field for cursor ids.
+      #
+      # @since 2.0.0
+      CURSOR_IDS = :cursor_ids.freeze
+
       # The field for an index.
       #
       # @since 2.0.0
@@ -233,7 +238,7 @@ module Mongo
       #
       # @since 2.0.0
       def coll_name
-        spec.fetch(COLL_NAME)
+        spec[COLL_NAME]
       end
 
       # The id of the cursor created on the server.
@@ -248,6 +253,18 @@ module Mongo
         spec[CURSOR_ID]
       end
 
+      # The ids of the cursors to kill from the spec.
+      #
+      # @example Get the cursor ids from the spec.
+      #   specifiable.cursor_ids
+      #
+      # @return [ Array<Integer> ] The cursor ids.
+      #
+      # @since 2.0.0
+      def cursor_ids
+        spec[CURSOR_IDS]
+      end
+
       # Get the index from the specification.
       #
       # @example Get the index specification.
@@ -519,6 +536,17 @@ module Mongo
         @spec[:txn_num]
       end
 
+      # For createIndexes operations, the number of votes that a primary must
+      # wait for before commiting an index. Potential values are:
+      # - an integer from 0 to the number of members of the replica set
+      # - "majority" indicating that a majority of data bearing nodes must vote
+      # - "votingMembers" which means that all voting data bearing nodes must vote
+      #
+      # @return [ nil | Integer | String ] The commitQuorum value of the operation.
+      def commit_quorum
+        @spec[:commit_quorum]
+      end
+
       # The command.
       #
       # @return [ Hash ] The command.
@@ -552,16 +580,6 @@ module Mongo
       def acknowledged_write?
         write_concern.nil? || write_concern.acknowledged?
       end
-
-      def apply_collation(selector, connection, collation)
-        if collation
-          unless connection.features.collation_enabled?
-            raise Error::UnsupportedCollation
-          end
-          selector = selector.merge(collation: collation)
-        end
-        selector
-      end
     end
   end
 end
diff --git a/lib/mongo/operation/shared/validatable.rb b/lib/mongo/operation/shared/validatable.rb
deleted file mode 100644
index 70b555735..000000000
--- a/lib/mongo/operation/shared/validatable.rb
+++ /dev/null
@@ -1,87 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  module Operation
-
-    # @api private
-    module Validatable
-
-      def validate_find_options(connection, selector)
-        if selector.key?(:hint) &&
-          !connection.features.find_and_modify_option_validation_enabled?
-        then
-          raise Error::UnsupportedOption.hint_error
-        end
-
-        if selector.key?(:arrayFilters) &&
-          !connection.features.array_filters_enabled?
-        then
-          raise Error::UnsupportedArrayFilters
-        end
-
-        if selector.key?(:collation) &&
-          !connection.features.collation_enabled?
-        then
-          raise Error::UnsupportedCollation
-        end
-      end
-
-      # selector_or_item here is either:
-      # - The selector as used in a findAndModify command, or
-      # - One of the array elements in the updates array in an update command.
-      def validate_hint_on_update(connection, selector_or_item)
-        if selector_or_item.key?(:hint) &&
-          !connection.features.update_delete_option_validation_enabled?
-        then
-          raise Error::UnsupportedOption.hint_error
-        end
-      end
-
-      # selector_or_item here is either:
-      # - The selector as used in a findAndModify command, or
-      # - One of the array elements in the updates array in an update command.
-      def validate_array_filters(connection, selector_or_item)
-        if selector_or_item.key?(:arrayFilters) &&
-          !connection.features.array_filters_enabled?
-        then
-          raise Error::UnsupportedArrayFilters
-        end
-      end
-
-      # selector_or_item here is either:
-      # - The selector as used in a findAndModify command, or
-      # - One of the array elements in the updates array in an update command.
-      def validate_collation(connection, selector_or_item)
-        if selector_or_item.key?(:collation) &&
-          !connection.features.collation_enabled?
-        then
-          raise Error::UnsupportedCollation
-        end
-      end
-
-      def validate_updates(connection, updates)
-        updates.each do |update|
-          validate_array_filters(connection, update)
-          validate_collation(connection, update)
-          validate_hint_on_update(connection, update)
-        end
-        updates
-      end
-    end
-  end
-end
diff --git a/lib/mongo/operation/shared/write.rb b/lib/mongo/operation/shared/write.rb
index 424cdc38b..00bb719e3 100644
--- a/lib/mongo/operation/shared/write.rb
+++ b/lib/mongo/operation/shared/write.rb
@@ -35,7 +35,7 @@ module Mongo
       #
       # @since 2.5.2
       def execute(server, context:)
-        server.with_connection(service_id: context.service_id) do |connection|
+        server.with_connection do |connection|
           validate!(connection)
           op = if connection.features.op_msg_enabled?
               self.class::OpMsg.new(spec)
diff --git a/lib/mongo/operation/update/command.rb b/lib/mongo/operation/update/command.rb
index 8e02bbbfd..3fbbb9629 100644
--- a/lib/mongo/operation/update/command.rb
+++ b/lib/mongo/operation/update/command.rb
@@ -32,16 +32,13 @@ module Mongo
         include BypassDocumentValidation
         include ExecutableNoValidate
         include PolymorphicResult
-        include Validatable
 
         private
 
         def selector(connection)
-          {
-            update: coll_name,
-            updates: validate_updates(connection, send(IDENTIFIER)),
-            ordered: ordered?,
-          }
+          { update: coll_name,
+            updates: send(IDENTIFIER),
+            ordered: ordered? }
         end
 
         def message(connection)
diff --git a/lib/mongo/operation/update/legacy.rb b/lib/mongo/operation/update/legacy.rb
index fa3fbfc93..f8451f346 100644
--- a/lib/mongo/operation/update/legacy.rb
+++ b/lib/mongo/operation/update/legacy.rb
@@ -30,32 +30,24 @@ module Mongo
         include Specifiable
         include Executable
         include PolymorphicResult
-        include Validatable
 
         private
 
-        def selector(connection)
-          # This returns the first update.
-          # The driver only puts one update into the list normally, so this
-          # doesn't discard operations.
-          send(IDENTIFIER).first.tap do |selector|
-            validate_find_options(connection, selector)
-          end
+        def selector
+          send(IDENTIFIER).first
         end
 
         def message(connection)
-          selector = selector(connection)
-
           flags = []
           flags << :multi_update if selector[Operation::MULTI]
           flags << :upsert if selector[Operation::UPSERT]
 
           Protocol::Update.new(
-            db_name,
-            coll_name,
-            selector[Operation::Q],
-            selector[Operation::U],
-            flags.empty? ? {} : { flags: flags },
+              db_name,
+              coll_name,
+              selector[Operation::Q],
+              selector[Operation::U],
+              flags.empty? ? {} : { flags: flags }
           )
         end
 
@@ -63,10 +55,10 @@ module Mongo
           wc = write_concern ||  WriteConcern.get(WriteConcern::DEFAULT)
           if gle_message = wc.get_last_error
             Protocol::Query.new(
-              db_name,
-              Database::COMMAND,
-              gle_message,
-              options.merge(limit: -1),
+                db_name,
+                Database::COMMAND,
+                gle_message,
+                options.merge(limit: -1)
             )
           end
         end
diff --git a/lib/mongo/operation/update/op_msg.rb b/lib/mongo/operation/update/op_msg.rb
index 462e46a62..f84316854 100644
--- a/lib/mongo/operation/update/op_msg.rb
+++ b/lib/mongo/operation/update/op_msg.rb
@@ -29,20 +29,17 @@ module Mongo
         include ExecutableNoValidate
         include ExecutableTransactionLabel
         include PolymorphicResult
-        include Validatable
 
         private
 
         def selector(connection)
-          {
-            update: coll_name,
-            ordered: ordered?,
-          }
+          { update: coll_name,
+            Protocol::Msg::DATABASE_IDENTIFIER => db_name,
+            ordered: ordered? }
         end
 
         def message(connection)
-          updates = validate_updates(connection, send(IDENTIFIER))
-          section = Protocol::Msg::Section1.new(IDENTIFIER, updates)
+          section = Protocol::Msg::Section1.new(IDENTIFIER, send(IDENTIFIER))
           Protocol::Msg.new(flags, {}, command(connection), section)
         end
       end
diff --git a/lib/mongo/operation/write_command.rb b/lib/mongo/operation/write_command.rb
deleted file mode 100644
index 3d882f615..000000000
--- a/lib/mongo/operation/write_command.rb
+++ /dev/null
@@ -1,32 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-require 'mongo/operation/write_command/command'
-require 'mongo/operation/write_command/op_msg'
-
-module Mongo
-  module Operation
-
-    # A MongoDB general command operation.
-    #
-    # @api private
-    class WriteCommand
-      include Specifiable
-      include OpMsgOrCommand
-    end
-  end
-end
diff --git a/lib/mongo/operation/write_command/command.rb b/lib/mongo/operation/write_command/command.rb
deleted file mode 100644
index b97e47d8f..000000000
--- a/lib/mongo/operation/write_command/command.rb
+++ /dev/null
@@ -1,51 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  module Operation
-    class WriteCommand
-
-      # A MongoDB write command operation sent as a command message.
-      #
-      # @api private
-      class Command
-        include Specifiable
-        include Executable
-        include Limited
-        include ReadPreferenceSupported
-        include Validatable
-
-        private
-
-        def selector(connection)
-          super.tap do |selector|
-            if selector.key?(:findAndModify)
-              validate_find_options(connection, selector)
-            end
-            if wc = spec[:write_concern]
-              selector[:writeConcern] = wc.options
-            end
-          end
-        end
-
-        def message(connection)
-          Protocol::Query.new(db_name, Database::COMMAND, command(connection), options(connection))
-        end
-      end
-    end
-  end
-end
diff --git a/lib/mongo/operation/write_command/op_msg.rb b/lib/mongo/operation/write_command/op_msg.rb
deleted file mode 100644
index bfb0d3f5d..000000000
--- a/lib/mongo/operation/write_command/op_msg.rb
+++ /dev/null
@@ -1,43 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  module Operation
-    class WriteCommand
-
-      # A MongoDB write command operation sent as an op message.
-      #
-      # @api private
-      class OpMsg < OpMsgBase
-        include Validatable
-
-        private
-
-        def selector(connection)
-          super.tap do |selector|
-            if selector.key?(:findAndModify)
-              validate_find_options(connection, selector)
-            end
-            if wc = spec[:write_concern]
-              selector[:writeConcern] = wc.options
-            end
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/lib/mongo/protocol/query.rb b/lib/mongo/protocol/query.rb
index 49988cb90..e4e3f1911 100644
--- a/lib/mongo/protocol/query.rb
+++ b/lib/mongo/protocol/query.rb
@@ -64,21 +64,13 @@ module Mongo
       def initialize(database, collection, selector, options = {})
         @database = database
         @namespace = "#{database}.#{collection}"
-        if selector.nil?
-          raise ArgumentError, 'Selector cannot be nil'
-        end
         @selector = selector
         @options = options
         @project = options[:project]
         @limit = determine_limit
         @skip = options[:skip]  || 0
         @flags = options[:flags] || []
-        @upconverter = Upconverter.new(
-          collection,
-          BSON::Document.new(selector),
-          BSON::Document.new(options),
-          flags,
-        )
+        @upconverter = Upconverter.new(collection, selector, options, flags)
         super
       end
 
@@ -232,7 +224,7 @@ module Mongo
         }.freeze
 
         SPECIAL_FIELD_MAPPINGS = {
-          :$readPreference => '$readPreference',
+          :$readPreference => 'readPreference',
           :$orderby => 'sort',
           :$hint => 'hint',
           :$comment => 'comment',
@@ -257,6 +249,16 @@ module Mongo
           :partial => 'allowPartialResults'
         }.freeze
 
+        # Find command constant.
+        #
+        # @since 2.1.0
+        FIND = 'find'.freeze
+
+        # Filter attribute constant.
+        #
+        # @since 2.1.0
+        FILTER = 'filter'.freeze
+
         # @return [ String ] collection The name of the collection.
         attr_reader :collection
 
@@ -281,15 +283,6 @@ module Mongo
         #
         # @since 2.1.0
         def initialize(collection, filter, options, flags)
-          # Although the docstring claims both hashes and BSON::Documents
-          # are acceptable, this class expects the filter and options to
-          # contain symbol keys which isn't what the operation layer produces.
-          unless BSON::Document === filter
-            raise ArgumentError, 'Filter must provide indifferent access'
-          end
-          unless BSON::Document === options
-            raise ArgumentError, 'Options must provide indifferent access'
-          end
           @collection = collection
           @filter = filter
           @options = options
@@ -318,7 +311,7 @@ module Mongo
         #
         # @since 2.1.0
         def command_name
-          ((filter[:$query] || !command?) ? :find : filter.keys.first).to_s
+          ((filter[:$query] || !command?) ? FIND : filter.keys.first).to_s
         end
 
         private
@@ -340,25 +333,15 @@ module Mongo
         end
 
         def find_command
-          document = BSON::Document.new(
-            find: collection,
-            filter: query_filter,
-          )
+          document = BSON::Document.new
+          document.store(FIND, collection)
+          document.store(FILTER, query_filter)
           OPTION_MAPPINGS.each do |legacy, option|
             document.store(option, options[legacy]) unless options[legacy].nil?
           end
-          if Lint.enabled?
-            filter.each do |k, v|
-              unless String === k
-                raise Error::LintError, "All keys in filter must be strings: #{filter.inspect}"
-              end
-            end
-          end
-          Lint.validate_camel_case_read_preference(filter['readPreference'])
+          Mongo::Lint.validate_camel_case_read_preference(filter['readPreference'])
           SPECIAL_FIELD_MAPPINGS.each do |special, normal|
-            unless (v = filter[special]).nil?
-              document.store(normal, v)
-            end
+            document.store(normal, filter[special]) unless filter[special].nil?
           end
           FLAG_MAPPINGS.each do |legacy, flag|
             document.store(flag, true) if flags.include?(legacy)
diff --git a/lib/mongo/server.rb b/lib/mongo/server.rb
index 73aaf483c..706a20889 100644
--- a/lib/mongo/server.rb
+++ b/lib/mongo/server.rb
@@ -54,8 +54,6 @@ module Mongo
     #   done by this server. Note: setting this option to false will make
     #   the server non-functional. It is intended for use in tests which
     #   manually invoke SDAM state transitions.
-    # @option options [ true | false ] :load_balancer Whether this server
-    #   is a load balancer.
     #
     # @since 2.0.0
     def initialize(address, cluster, monitoring, event_listeners, options = {})
@@ -71,8 +69,7 @@ module Mongo
       end
       @scan_semaphore = DistinguishingSemaphore.new
       @round_trip_time_averager = RoundTripTimeAverager.new
-      @description = Description.new(address, {},
-        load_balancer: !!@options[:load_balancer])
+      @description = Description.new(address, {})
       @last_scan = nil
       @last_scan_monotime = nil
       unless options[:monitoring_io] == false
@@ -183,7 +180,6 @@ module Mongo
                    :secondary?,
                    :standalone?,
                    :unknown?,
-                   :load_balancer?,
                    :last_write_date,
                    :logical_session_timeout
 
@@ -226,6 +222,20 @@ module Mongo
       address == other.address
     end
 
+    # Get a new context for this server in which to send messages.
+    #
+    # @example Get the server context.
+    #   server.context
+    #
+    # @return [ Mongo::Server::Context ] context The server context.
+    #
+    # @since 2.0.0
+    #
+    # @deprecated Will be removed in version 3.0
+    def context
+      Context.new(self)
+    end
+
     # Determine if a connection to the server is able to be established and
     # messages can be sent to it.
     #
@@ -317,8 +327,6 @@ module Mongo
     # @api private
     def status
       case
-      when load_balancer?
-        'LB'
       when primary?
         'PRIMARY'
       when secondary?
@@ -425,8 +433,8 @@ module Mongo
     # @return [ Object ] The result of the block execution.
     #
     # @since 2.3.0
-    def with_connection(service_id: nil, &block)
-      pool.with_connection(service_id: service_id, &block)
+    def with_connection(&block)
+      pool.with_connection(&block)
     end
 
     # Handle handshake failure.
@@ -436,11 +444,7 @@ module Mongo
     def handle_handshake_failure!
       yield
     rescue Mongo::Error::SocketError, Mongo::Error::SocketTimeoutError => e
-      unknown!(
-        generation: e.generation,
-        service_id: e.service_id,
-        stop_push_monitor: true,
-      )
+      unknown!(generation: e.generation, stop_push_monitor: true)
       raise
     end
 
@@ -463,11 +467,7 @@ module Mongo
       raise
     rescue Mongo::Error::SocketError => e
       # non-timeout network error
-      unknown!(
-        generation: e.generation,
-        service_id: e.service_id,
-        stop_push_monitor: true,
-      )
+      unknown!(generation: e.generation, stop_push_monitor: true)
       raise
     rescue Auth::Unauthorized
       # auth error, keep server description and topology as they are
@@ -513,33 +513,13 @@ module Mongo
     #   respective server is cleared. Set this option to true to keep the
     #   existing connection pool (required when handling not master errors
     #   on 4.2+ servers).
-    # @option options [ Object ] :service_id Discard state for the specified
-    #   service id only.
     # @option options [ TopologyVersion ] :topology_version Topology version
     #   of the error response that is causing the server to be marked unknown.
     # @option options [ true | false ] :stop_push_monitor Whether to stop
     #   the PushMonitor associated with the server, if any.
-    # @option options [ Object ] :service_id Discard state for the specified
-    #   service id only.
     #
     # @since 2.4.0, SDAM events are sent as of version 2.7.0
     def unknown!(options = {})
-      if load_balancer?
-        # When the client is in load-balanced topology, servers (the one and
-        # only that can be) starts out as a load balancer and stays as a
-        # load balancer indefinitely. As such it is not marked unknown.
-        #
-        # However, this method also clears connection pool for the server
-        # when the latter is marked unknown, and this part needs to happen
-        # when the server is a load balancer.
-        if service_id = options[:service_id]
-          pool.disconnect!(service_id: service_id)
-        elsif Lint.enabled?
-          raise Error::LintError, 'Load balancer was asked to be marked unknown without a service id'
-        end
-        return
-      end
-
       if options[:generation] && options[:generation] < pool.generation
         return
       end
@@ -557,15 +537,10 @@ module Mongo
       # SDAM flow will update description on the server without in-place
       # mutations and invoke SDAM transitions as needed.
       config = {}
-      if options[:service_id]
-        config['serviceId'] = options[:service_id]
-      end
       if options[:topology_version]
         config['topologyVersion'] = options[:topology_version]
       end
-      new_description = Description.new(address, config,
-        load_balancer: load_balancer?,
-      )
+      new_description = Description.new(address, config)
       cluster.run_sdam_flow(description, new_description, options)
     end
 
@@ -574,14 +549,11 @@ module Mongo
       @description = description
     end
 
-    # @param [ Object ] :service_id Close connections with the specified
-    #   service id only.
-    #
     # @api private
-    def clear_connection_pool(service_id: nil)
+    def clear_connection_pool
       @pool_lock.synchronize do
         if @pool
-          @pool.disconnect!(service_id: service_id)
+          @pool.disconnect!
         end
       end
     end
@@ -605,6 +577,7 @@ require 'mongo/server/connection_base'
 require 'mongo/server/pending_connection'
 require 'mongo/server/connection'
 require 'mongo/server/connection_pool'
+require 'mongo/server/context'
 require 'mongo/server/description'
 require 'mongo/server/monitor'
 require 'mongo/server/round_trip_time_averager'
diff --git a/lib/mongo/server/connection.rb b/lib/mongo/server/connection.rb
index ef95ff897..855a1e7e5 100644
--- a/lib/mongo/server/connection.rb
+++ b/lib/mongo/server/connection.rb
@@ -314,12 +314,7 @@ module Mongo
           yield
         rescue Error::SocketError => e
           @error = e
-          @server.unknown!(
-            generation: e.generation,
-            # or description.service_id?
-            service_id: e.service_id,
-            stop_push_monitor: true,
-          )
+          @server.unknown!(generation: e.generation, stop_push_monitor: true)
           raise
         rescue Error::SocketTimeoutError => e
           @error = e
diff --git a/lib/mongo/server/connection_base.rb b/lib/mongo/server/connection_base.rb
index 53fe531bb..d2450be82 100644
--- a/lib/mongo/server/connection_base.rb
+++ b/lib/mongo/server/connection_base.rb
@@ -88,11 +88,6 @@ module Mongo
         :max_message_size,
         :mongos?
 
-      # @return [ nil | Object ] The service id, if any.
-      def service_id
-        description&.service_id
-      end
-
       # Connection pool generation from which this connection was created.
       # May be nil.
       #
@@ -172,7 +167,6 @@ module Mongo
             socket_object_id: socket.object_id, connection_id: id,
             connection_generation: generation,
             server_connection_id: description.server_connection_id,
-            service_id: description.service_id,
           )
           start = Utils.monotonic_time
           result = nil
@@ -190,7 +184,6 @@ module Mongo
             command_failed(nil, address, operation_id, message.payload,
               e.message, total_duration,
               started_event: started_event,
-              service_id: description.service_id,
             )
             raise
           else
@@ -198,7 +191,6 @@ module Mongo
             command_completed(result, address, operation_id, message.payload,
               total_duration,
               started_event: started_event,
-              service_id: description.service_id,
             )
           end
           if result && context.decrypt?
diff --git a/lib/mongo/server/connection_common.rb b/lib/mongo/server/connection_common.rb
index 2551d8a57..78e592c8e 100644
--- a/lib/mongo/server/connection_common.rb
+++ b/lib/mongo/server/connection_common.rb
@@ -57,29 +57,20 @@ module Mongo
       # @param [ Server::AppMetadata ] app_metadata Application metadata
       # @param [ BSON::Document ] speculative_auth_doc The speculative
       #   authentication document, if any.
-      # @param [ true | false ] load_balancer Whether the connection is to
-      #   a load balancer.
       # @param server_api [ Hash | nil ] server_api Server API version.
       #
       # @return [BSON::Document] Document that should be sent to a server
       #     for handshake purposes.
       #
       # @api private
-      def handshake_document(app_metadata, speculative_auth_doc: nil, load_balancer: false, server_api: nil)
+      def handshake_document(app_metadata, speculative_auth_doc: nil, server_api: nil)
         serv_api = app_metadata.server_api || server_api
         document = if serv_api
                      HELLO_DOC.merge(Utils.transform_server_api(serv_api))
                    else
                      LEGACY_HELLO_DOC
                    end
-        document.merge(app_metadata.validated_document).tap do |doc|
-          if speculative_auth_doc
-            doc.update(speculativeAuthenticate: speculative_auth_doc)
-          end
-          if load_balancer
-            doc.update(loadBalanced: true)
-          end
-        end
+        document.merge(app_metadata.validated_document)
       end
 
 
@@ -130,18 +121,10 @@ module Mongo
         if respond_to?(:id)
           note << ", connection #{generation}:#{id}"
         end
-        # Non-monitoring connections have service id.
-        # Monitoring connections do not.
-        if respond_to?(:service_id) && service_id
-          note << ", service id #{service_id}"
-        end
         e.add_note(note)
         if respond_to?(:generation)
           # Non-monitoring connections
           e.generation = generation
-          if respond_to?(:description)
-            e.service_id = service_id
-          end
         end
         raise e
       end
diff --git a/lib/mongo/server/connection_pool.rb b/lib/mongo/server/connection_pool.rb
index e78fcd138..554434aa4 100644
--- a/lib/mongo/server/connection_pool.rb
+++ b/lib/mongo/server/connection_pool.rb
@@ -277,7 +277,7 @@ module Mongo
       #   and remains so for longer than the wait timeout.
       #
       # @since 2.9.0
-      def check_out(service_id: nil)
+      def check_out
         check_invariants
 
         publish_cmap_event(
@@ -306,7 +306,7 @@ module Mongo
             # a connection while this thread is waiting for one.
             @lock.synchronize do
               until @available_connections.empty?
-                connection = next_available_connection(service_id: service_id)
+                connection = @available_connections.pop
 
                 if connection.pid != pid
                   log_warn("Detected PID change - Mongo client should have been reconnected (old pid #{connection.pid}, new pid #{pid}")
@@ -335,24 +335,6 @@ module Mongo
                 throw(:done)
               end
 
-              if service_id
-                publish_cmap_event(
-                  Monitoring::Event::Cmap::ConnectionCheckOutFailed.new(
-                    @server.address,
-                    # CONNECTION_ERROR is the closest reason.
-                    # Technically we haven't attempted to create a connection
-                    # (because there is no way to request a connection to a
-                    # specific service), but another way of looking at it
-                    # is that the pool did fail to provide a connection as
-                    # requested.
-                    Monitoring::Event::Cmap::ConnectionCheckOutFailed::CONNECTION_ERROR,
-                  ),
-                )
-
-                raise Error::NoServiceConnectionAvailable.generate(
-                  address: @server.address, service_id: service_id)
-              end
-
               # Ruby does not allow a thread to lock a mutex which it already
               # holds.
               if unsynchronized_size < max_size
@@ -491,12 +473,8 @@ module Mongo
       # @option options [ true | false ] :lazy If true, do not close any of
       #   the idle connections and instead let them be closed during a
       #   subsequent check out operation.
-      # @option options [ Object ] :service_id Discard state for the specified
-      #   service id only.
       # @option options [ true | false ] :stop_populator Whether to stop
       #   the populator background thread. For internal driver use only.
-      # @option options [ Object ] :service_id Clear connections with
-      #   the specified service id only.
       #
       # @return [ true ] true.
       #
@@ -510,38 +488,18 @@ module Mongo
           stop_populator
         end
 
-        service_id = options && options[:service_id]
-
         @lock.synchronize do
           @generation += 1
 
           publish_cmap_event(
-            Monitoring::Event::Cmap::PoolCleared.new(
-              @server.address,
-              service_id: service_id,
-            )
+            Monitoring::Event::Cmap::PoolCleared.new(@server.address)
           )
 
           unless options && options[:lazy]
-            if service_id
-              loop do
-                conn = @available_connections.detect do |conn|
-                  conn.service_id == service_id
-                end
-                if conn
-                  @available_connections.delete(conn)
-                  conn.disconnect!(reason: :stale)
-                  @populate_semaphore.signal
-                else
-                  break
-                end
-              end
-            else
-              until @available_connections.empty?
-                connection = @available_connections.pop
-                connection.disconnect!(reason: :stale)
-                @populate_semaphore.signal
-              end
+            until @available_connections.empty?
+              connection = @available_connections.pop
+              connection.disconnect!(reason: :stale)
+              @populate_semaphore.signal
             end
           end
         end
@@ -628,10 +586,10 @@ module Mongo
       # @return [ Object ] The result of the block.
       #
       # @since 2.0.0
-      def with_connection(service_id: nil)
+      def with_connection
         raise_if_closed!
 
-        connection = check_out(service_id: service_id)
+        connection = check_out
         yield(connection)
       ensure
         if connection
@@ -747,18 +705,6 @@ module Mongo
 
       private
 
-      def next_available_connection(service_id: nil)
-        if service_id
-          conn = @available_connections.detect do |conn|
-            conn.service_id == service_id
-          end
-          @available_connections.delete(conn)
-          conn
-        else
-          @available_connections.pop
-        end
-      end
-
       def create_connection
         connection = Connection.new(@server, options.merge(
           generation: generation,
@@ -826,11 +772,7 @@ module Mongo
           raise
         end
       rescue Error::SocketError, Error::SocketTimeoutError => exc
-        @server.unknown!(
-          generation: exc.generation,
-          service_id: exc.service_id,
-          stop_push_monitor: true,
-        )
+        @server.unknown!(generation: exc.generation, stop_push_monitor: true)
         raise
       end
 
diff --git a/lib/mongo/server/context.rb b/lib/mongo/server/context.rb
new file mode 100644
index 000000000..5895905bc
--- /dev/null
+++ b/lib/mongo/server/context.rb
@@ -0,0 +1,72 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+# Copyright (C) 2014-2020 MongoDB Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the 'License');
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an 'AS IS' BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+module Mongo
+  class Server
+
+    # Represents a context in which messages are sent to the server on a
+    # connection.
+    #
+    # @since 2.0.0
+    #
+    # @deprecated Will be removed in version 3.0
+    class Context
+      extend Forwardable
+
+      # Instantiate a server context.
+      #
+      # @example Instantiate a server context.
+      #   Mongo::Server::Context.new(server)
+      #
+      # @param [ Mongo::Server ] server The server the context is for.
+      #
+      # @since 2.0.0
+      def initialize(server)
+        @server = server
+      end
+
+      # @return [ Mongo::Server ] server The server the context is for.
+      attr_reader :server
+
+      # Delegate state checks to the server.
+      def_delegators :@server,
+                     :cluster,
+                     :features,
+                     :max_wire_version,
+                     :max_write_batch_size,
+                     :mongos?,
+                     :primary?,
+                     :secondary?,
+                     :standalone?
+
+      # Execute a block of code with a connection, that is checked out of the
+      # pool and then checked back in.
+      #
+      # @example Send a message with the connection.
+      #   context.with_connection do |connection|
+      #     connection.dispatch([ command ])
+      #   end
+      #
+      # @return [ Object ] The result of the block execution.
+      #
+      # @since 2.0.0
+      def with_connection(&block)
+        server.pool.with_connection(&block)
+      end
+    end
+  end
+end
diff --git a/lib/mongo/server/description.rb b/lib/mongo/server/description.rb
index 3028b8d16..fb0020df9 100644
--- a/lib/mongo/server/description.rb
+++ b/lib/mongo/server/description.rb
@@ -15,6 +15,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+require 'mongo/server/description/features'
+
 module Mongo
   class Server
 
@@ -199,8 +201,7 @@ module Mongo
                                ].freeze
 
       # Instantiate the new server description from the result of the hello
-      # command or fabricate a placeholder description for Unknown and
-      # LoadBalancer servers.
+      # command.
       #
       # @example Instantiate the new description.
       #   Description.new(address, { 'isWritablePrimary' => true }, 0.5)
@@ -208,30 +209,17 @@ module Mongo
       # @param [ Address ] address The server address.
       # @param [ Hash ] config The result of the hello command.
       # @param [ Float ] average_round_trip_time The moving average time (sec) the hello
-      #   command took to complete.
-      # @param [ Float ] average_round_trip_time The moving average time (sec)
-      #   the ismaster call took to complete.
-      # @param [ true | false ] load_balancer Whether the server is a load
-      #   balancer.
+      #   call took to complete.
       #
-      # @api private
-      def initialize(address, config = {}, average_round_trip_time: nil,
-        load_balancer: false
-      )
+      # @since 2.0.0
+      def initialize(address, config = {}, average_round_trip_time = nil)
         @address = address
         @config = config
-        @load_balancer = !!load_balancer
         @features = Features.new(wire_versions, me || @address.to_s)
         @average_round_trip_time = average_round_trip_time
         @last_update_time = Time.now.freeze
         @last_update_monotime = Utils.monotonic_time
 
-        if load_balancer
-          if ok? && !service_id
-            @config = @config.merge('serviceId' => "fake:#{rand(2**32-1)+1}")
-          end
-        end
-
         if Mongo::Lint.enabled?
           # prepopulate cache instance variables
           hosts
@@ -249,25 +237,11 @@ module Mongo
       # @return [ Hash ] The actual result from the hello command.
       attr_reader :config
 
-      # Returns whether this server is a load balancer.
-      #
-      # @return [ true | false ] Whether this server is a load balancer.
-      def load_balancer?
-        @load_balancer
-      end
-
       # @return [ Features ] features The features for the server.
       def features
         @features
       end
 
-      # @return [ nil | Object ] The service id, if any.
-      def service_id
-        if load_balancer?
-          rand(2**32-1) + 1
-        end
-      end
-
       # @return [ Float ] The moving average time the hello call took to complete.
       attr_reader :average_round_trip_time
 
@@ -651,7 +625,6 @@ module Mongo
       #
       # @since 2.4.0
       def server_type
-        return :load_balancer if load_balancer?
         return :arbiter if arbiter?
         return :ghost if ghost?
         return :sharded if mongos?
@@ -686,7 +659,6 @@ module Mongo
       #
       # @since 2.0.0
       def unknown?
-        return false if load_balancer?
         config.empty? || config.keys == %w(topologyVersion) || !ok?
       end
 
@@ -808,11 +780,6 @@ module Mongo
         config['connectionId']
       end
 
-      # @api experimental
-      def service_id
-        config['serviceId']
-      end
-
       # Check equality of two descriptions.
       #
       # @example Check description equality.
@@ -858,19 +825,8 @@ module Mongo
             raise ArgumentError, "Bogus required version #{version}"
           end
 
-        if load_balancer?
-          # If we are talking to a load balancer, there is no monitoring
-          # and we don't know what server is behind the load balancer.
-          # Assume everything is supported.
-          # TODO remove this when RUBY-2220 is implemented.
-          return true
-        end
-
         required_wv >= min_wire_version && required_wv <= max_wire_version
       end
     end
   end
 end
-
-require 'mongo/server/description/features'
-require 'mongo/server/description/load_balancer'
diff --git a/lib/mongo/server/description/features.rb b/lib/mongo/server/description/features.rb
index 6ca28e96c..006f68ae9 100644
--- a/lib/mongo/server/description/features.rb
+++ b/lib/mongo/server/description/features.rb
@@ -38,29 +38,28 @@ module Mongo
         #
         # @since 2.0.0
         MAPPINGS = {
-          retryable_write_error_label: 9,
-          commit_quorum: 9,
+          :retryable_write_error_label => 9,
           # Server versions older than 4.2 do not reliably validate options
           # provided by the client during findAndModify operations, requiring the
           # driver to raise client-side errors when those options are provided.
-          find_and_modify_option_validation: 8,
-          transactions: 7,
-          scram_sha_256: 7,
-          array_filters: 6,
-          op_msg: 6,
-          sessions: 6,
-          collation: 5,
-          max_staleness: 5,
+          :find_and_modify_option_validation => 8,
+          :transactions => 7,
+          :scram_sha_256 => 7,
+          :array_filters => 6,
+          :op_msg => 6,
+          :sessions => 6,
+          :collation => 5,
+          :max_staleness => 5,
           # Server versions older than 3.4 do not reliably validate options
           # provided by the client during update/delete operations, requiring the
           # driver to raise client-side errors when those options are provided.
-          update_delete_option_validation: 5,
-          find_command: 4,
-          list_collections: 3,
-          list_indexes: 3,
-          scram_sha_1: 3,
-          write_command: 2,
-          users_info: 2,
+          :update_delete_option_validation => 5,
+          :find_command => 4,
+          :list_collections => 3,
+          :list_indexes => 3,
+          :scram_sha_1 => 3,
+          :write_command => 2,
+          :users_info => 2
         }.freeze
 
         # Error message if the server is too old for this version of the driver.
diff --git a/lib/mongo/server/description/load_balancer.rb b/lib/mongo/server/description/load_balancer.rb
deleted file mode 100644
index dc7c90d3e..000000000
--- a/lib/mongo/server/description/load_balancer.rb
+++ /dev/null
@@ -1,33 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-# Copyright (C) 2021 MongoDB Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the 'License');
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an 'AS IS' BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-module Mongo
-  class Server
-    class Description
-
-      # Represents an assumed description of servers behind load balancers.
-      class LoadBalancer
-        def initialize(address)
-          @address = address
-        end
-
-        # @return [ Address ] address The server's address.
-        attr_reader :address
-      end
-    end
-  end
-end
diff --git a/lib/mongo/server/monitor.rb b/lib/mongo/server/monitor.rb
index cab79929a..967a6eb92 100644
--- a/lib/mongo/server/monitor.rb
+++ b/lib/mongo/server/monitor.rb
@@ -215,8 +215,7 @@ module Mongo
           old_description = server.description
 
           new_description = Description.new(server.address, result,
-            average_round_trip_time: server.round_trip_time_averager.average_round_trip_time
-          )
+            server.round_trip_time_averager.average_round_trip_time)
 
           server.cluster.run_sdam_flow(server.description, new_description, awaited: awaited)
 
diff --git a/lib/mongo/server/pending_connection.rb b/lib/mongo/server/pending_connection.rb
index f192fca37..10fe7f5d1 100644
--- a/lib/mongo/server/pending_connection.rb
+++ b/lib/mongo/server/pending_connection.rb
@@ -114,8 +114,7 @@ module Mongo
         hello_doc = handshake_document(
           app_metadata,
           speculative_auth_doc: speculative_auth_doc,
-          load_balancer: server.load_balancer?,
-          server_api: options[:server_api]
+          server_api: options[:server_api],
         )
 
         # TODO (DR): OP_MSG should be used if api version is declared.
@@ -194,7 +193,7 @@ module Mongo
       # This is a separate method to keep the nesting level down.
       #
       # @return [ Server::Description ] The server description calculated from
-      #   the handshake response for this particular connection.
+      #   hello response for this particular connection.
       def post_handshake(response, average_rtt)
         if response["ok"] == 1
           # Auth mechanism is entirely dependent on the contents of
@@ -211,11 +210,7 @@ module Mongo
           @sasl_supported_mechanisms = nil
         end
 
-        @description = Description.new(
-          address, response,
-          average_round_trip_time: average_rtt,
-          load_balancer: server.load_balancer?,
-        ).tap do |new_description|
+        @description = Description.new(address, response, average_rtt).tap do |new_description|
           @server.cluster.run_sdam_flow(@server.description, new_description)
         end
       end
diff --git a/lib/mongo/server_selector/base.rb b/lib/mongo/server_selector/base.rb
index 380036f02..df6faf0a5 100644
--- a/lib/mongo/server_selector/base.rb
+++ b/lib/mongo/server_selector/base.rb
@@ -173,10 +173,6 @@ module Mongo
       #
       # @since 2.0.0
       def select_server(cluster, ping = nil, session = nil)
-        if cluster.topology.is_a?(Cluster::Topology::LoadBalanced)
-          return cluster.servers.first
-        end
-
         server_selection_timeout = cluster.options[:server_selection_timeout] || SERVER_SELECTION_TIMEOUT
 
         # Special handling for zero timeout: if we have to select a server,
@@ -251,7 +247,7 @@ module Mongo
             end
 
             if session && session.starting_transaction? && cluster.sharded?
-              session.pin_to_server(server)
+              session.pin(server)
             end
 
             return server
diff --git a/lib/mongo/session.rb b/lib/mongo/session.rb
index ed22036d3..e1c54bc28 100644
--- a/lib/mongo/session.rb
+++ b/lib/mongo/session.rb
@@ -208,12 +208,6 @@ module Mongo
     # @api private
     attr_reader :pinned_server
 
-    # @return [ Object | nil ] The service id that this session is pinned to,
-    #   if any.
-    #
-    # @api private
-    attr_reader :pinned_service_id
-
     # @return [ BSON::Document | nil ] Recovery token for the sharded
     #   transaction being executed on this session, if any.
     #
@@ -701,7 +695,7 @@ module Mongo
     # @param [ Server ] server The server to pin this session to.
     #
     # @api private
-    def pin_to_server(server)
+    def pin(server)
       if server.nil?
         raise ArgumentError, 'Cannot pin to a nil server'
       end
@@ -713,24 +707,11 @@ module Mongo
       @pinned_server = server
     end
 
-    # Pins this session to the specified service.
-    #
-    # @param [ Object ] service_id The service id to pin this session to.
-    #
-    # @api private
-    def pin_to_service(service_id)
-      if service_id.nil?
-        raise ArgumentError, 'Cannot pin to a nil service id'
-      end
-      @pinned_service_id = service_id
-    end
-
     # Unpins this session from the pinned server, if the session was pinned.
     #
     # @api private
     def unpin
       @pinned_server = nil
-      @pinned_service_id = nil
     end
 
     # Unpins this session from the pinned server, if the session was pinned
diff --git a/lib/mongo/uri.rb b/lib/mongo/uri.rb
index 0881c27c4..67e3bab5e 100644
--- a/lib/mongo/uri.rb
+++ b/lib/mongo/uri.rb
@@ -520,24 +520,6 @@ module Mongo
       elsif uri_options[:direct_connection] == false && uri_options[:connect].to_s == 'direct'
         raise_invalid_error_no_fmt!("directConnection=false cannot be used with connect=direct")
       end
-
-      if uri_options[:load_balanced]
-        if servers.length > 1
-          raise_invalid_error_no_fmt!("loadBalanced=true cannot be used with multiple seeds")
-        end
-
-        if uri_options[:direct_connection]
-          raise_invalid_error_no_fmt!("directConnection=true cannot be used with loadBalanced=true")
-        end
-
-        if uri_options[:connect] && uri_options[:connect].to_sym == :direct
-          raise_invalid_error_no_fmt!("connect=direct cannot be used with loadBalanced=true")
-        end
-
-        if uri_options[:replica_set]
-          raise_invalid_error_no_fmt!("loadBalanced=true cannot be used with replicaSet option")
-        end
-      end
     end
   end
 end
diff --git a/lib/mongo/uri/options_mapper.rb b/lib/mongo/uri/options_mapper.rb
index e215d687a..9bd9728e2 100644
--- a/lib/mongo/uri/options_mapper.rb
+++ b/lib/mongo/uri/options_mapper.rb
@@ -268,7 +268,6 @@ module Mongo
       # Topology options
       uri_option 'directConnection', :direct_connection, type: :bool
       uri_option 'connect', :connect, type: :symbol
-      uri_option 'loadBalanced', :load_balanced, type: :bool
 
       # Auth Options
       uri_option 'authSource', :auth_source
diff --git a/lib/mongo/uri/srv_protocol.rb b/lib/mongo/uri/srv_protocol.rb
index 41c01b33f..32e087070 100644
--- a/lib/mongo/uri/srv_protocol.rb
+++ b/lib/mongo/uri/srv_protocol.rb
@@ -80,7 +80,7 @@ module Mongo
       DOT_PARTITION = '.'.freeze
 
       # @return [ Array<String> ] VALID_TXT_OPTIONS The valid options for a TXT record to specify.
-      VALID_TXT_OPTIONS = %w(replicaset authsource loadbalanced).freeze
+      VALID_TXT_OPTIONS = ['replicaset', 'authsource'].freeze
 
       # @return [ String ] INVALID_HOST Error message format string indicating that the hostname in
       #   in the URI does not fit the expected form.
@@ -102,6 +102,11 @@ module Mongo
       #   were found.
       NO_SRV_RECORDS = "The DNS query returned no SRV records for '%s'".freeze
 
+      # @return [ String ] INVALID_TXT_RECORD_OPTION Error message format string indicating that an
+      #   unexpected TXT record option was found.
+      INVALID_TXT_RECORD_OPTION = "TXT records can only specify the options " +
+                                    "[#{VALID_TXT_OPTIONS.join(', ')}].".freeze
+
       # @return [ String ] FORMAT The expected SRV URI format.
       FORMAT = 'mongodb+srv://[username:password@]host[/[database][?options]]'.freeze
 
@@ -217,11 +222,8 @@ module Mongo
       def parse_txt_options!(string)
         string.split(INDIV_URI_OPTS_DELIM).reduce({}) do |txt_options, opt|
           raise Error::InvalidTXTRecord.new(INVALID_OPTS_VALUE_DELIM) unless opt.index(URI_OPTS_VALUE_DELIM)
-          key, value = opt.split('=')
-          unless VALID_TXT_OPTIONS.include?(key.downcase)
-            msg = "TXT records can only specify the options [#{VALID_TXT_OPTIONS.join(', ')}]: #{string}"
-            raise Error::InvalidTXTRecord.new(msg)
-          end
+          key, value = opt.split(URI_OPTS_VALUE_DELIM)
+          raise Error::InvalidTXTRecord.new(INVALID_TXT_RECORD_OPTION) unless VALID_TXT_OPTIONS.include?(key.downcase)
           options_mapper.add_uri_option(key, value, txt_options)
           txt_options
         end
diff --git a/spec/integration/client_spec.rb b/spec/integration/client_spec.rb
index e004c5608..1bc26d724 100644
--- a/spec/integration/client_spec.rb
+++ b/spec/integration/client_spec.rb
@@ -21,8 +21,6 @@ describe 'Client' do
     end
 
     context 'after all servers are marked unknown' do
-      require_topology :single, :replica_set, :sharded
-
       before do
         client.cluster.servers.each do |server|
           server.unknown!
diff --git a/spec/integration/connection_spec.rb b/spec/integration/connection_spec.rb
index a3c7de1df..9cd2e645b 100644
--- a/spec/integration/connection_spec.rb
+++ b/spec/integration/connection_spec.rb
@@ -246,60 +246,43 @@ describe 'Connections' do
 
       let(:client) { ClientRegistry.instance.global_client('authorized').with(app_name: 'wire_protocol_update') }
 
-      context 'non-lb' do
-        require_topology :single, :replica_set, :sharded
+      it 'updates on hello response from non-monitoring connections' do
+        # connect server
+        client['test'].insert_one(test: 1)
 
-        it 'updates on handshake response from non-monitoring connections' do
-          # connect server
-          client['test'].insert_one(test: 1)
-
-          # kill background threads so that they are not interfering with
-          # our mocked hello response
-          client.cluster.servers.each do |server|
-            server.monitor.stop!
-          end
-
-          server = client.cluster.servers.first
-          expect(server.features.server_wire_versions.max >= 4).to be true
-          max_version = server.features.server_wire_versions.max
-
-          # Depending on server version, handshake here may return a
-          # description that compares equal to the one we got from a
-          # monitoring connection (pre-4.2) or not (4.2+).
-          # Since we do run SDAM flow on handshake responses on
-          # non-monitoring connections, force descriptions to be different
-          # by setting the existing description here to unknown.
-          server.monitor.instance_variable_set('@description',
-            Mongo::Server::Description.new(server.address))
-
-          RSpec::Mocks.with_temporary_scope do
-            # now pretend a handshake returned a different range
-            features = Mongo::Server::Description::Features.new(0..3)
-            # One Features instantiation is for SDAM event publication, this
-            # one always happens. The second one happens on servers
-            # where we do not negotiate auth mechanism.
-            expect(Mongo::Server::Description::Features).to receive(:new).at_least(:once).and_return(features)
-
-            connection = Mongo::Server::Connection.new(server, server.options)
-            expect(connection.connect!).to be true
-
-            # hello response should update server description via sdam flow,
-            # which includes wire version range
-            expect(server.features.server_wire_versions.max).to eq(3)
-          end
+        # kill background threads so that they are not interfering with
+        # our mocked hello response
+        client.cluster.servers.each do |server|
+          server.monitor.stop!
         end
-      end
-
-      context 'lb' do
-        require_topology :load_balanced
-
-        it 'does not update on handshake response from non-monitoring connections since there are not any' do
-          # connect server
-          client['test'].insert_one(test: 1)
 
-          server = client.cluster.servers.first
-          server.load_balancer?.should be true
-          server.features.server_wire_versions.max.should be 0
+        server = client.cluster.servers.first
+        expect(server.features.server_wire_versions.max >= 4).to be true
+        max_version = server.features.server_wire_versions.max
+
+        # Depending on server version, hello here may return a
+        # description that compares equal to the one we got from a
+        # monitoring connection (pre-4.2) or not (4.2+).
+        # Since we do run SDAM flow on hello responses on
+        # non-monitoring connections, force descriptions to be different
+        # by setting the existing description here to unknown.
+        server.monitor.instance_variable_set('@description',
+          Mongo::Server::Description.new(server.address))
+
+        RSpec::Mocks.with_temporary_scope do
+          # now pretend a hello returned a different range
+          features = Mongo::Server::Description::Features.new(0..3)
+          # One Features instantiation is for SDAM event publication, this
+          # one always happens. The second one happens on servers
+          # where we do not negotiate auth mechanism.
+          expect(Mongo::Server::Description::Features).to receive(:new).at_least(:once).and_return(features)
+
+          connection = Mongo::Server::Connection.new(server, server.options)
+          expect(connection.connect!).to be true
+
+          # hello response should update server description via sdam flow,
+          # which includes wire version range
+          expect(server.features.server_wire_versions.max).to eq(3)
         end
       end
     end
diff --git a/spec/integration/crud_spec.rb b/spec/integration/crud_spec.rb
index 876f934a2..f0fc9ffad 100644
--- a/spec/integration/crud_spec.rb
+++ b/spec/integration/crud_spec.rb
@@ -4,8 +4,7 @@
 require 'spec_helper'
 
 describe 'CRUD operations' do
-  let(:client) { authorized_client }
-  let(:collection) { client['crud_integration'] }
+  let(:collection) { authorized_client['crud_integration'] }
 
   before do
     collection.delete_many
@@ -65,178 +64,6 @@ describe 'CRUD operations' do
         end
       end
     end
-
-    context 'with read concern' do
-      # Read concern requires 3.2+ server.
-      min_server_fcv '3.2'
-
-      context 'with read concern specified on operation level' do
-
-        it 'passes the read concern' do
-          event = Utils.get_command_event(client, 'find') do |client|
-            client['foo'].find({}, read_concern: {level: :local}).to_a
-          end
-          event.command.fetch('readConcern').should == {'level' => 'local'}
-        end
-      end
-
-      context 'with read concern specified on collection level' do
-
-        it 'passes the read concern' do
-          event = Utils.get_command_event(client, 'find') do |client|
-            client['foo', read_concern: {level: :local}].find.to_a
-          end
-          event.command.fetch('readConcern').should == {'level' => 'local'}
-        end
-      end
-
-      context 'with read concern specified on client level' do
-
-        let(:client) { authorized_client.with(read_concern: {level: :local}) }
-
-        it 'passes the read concern' do
-          event = Utils.get_command_event(client, 'find') do |client|
-            client['foo'].find.to_a
-          end
-          event.command.fetch('readConcern').should == {'level' => 'local'}
-        end
-      end
-    end
-
-    context 'with oplog_replay option' do
-      let(:collection_name) { 'crud_integration_oplog_replay' }
-
-      let(:oplog_query) do
-        {ts: {'$gt' => 1}}
-      end
-
-      context 'passed to operation' do
-        it 'passes the option' do
-          event = Utils.get_command_event(client, 'find') do |client|
-            client[collection_name].find(oplog_query, oplog_replay: true).to_a
-          end
-          event.command.fetch('oplogReplay').should be true
-        end
-
-        it 'warns' do
-          client.should receive(:log_warn).with('The :oplog_replay option is deprecated and ignored by MongoDB 4.4 and later')
-          client[collection_name].find(oplog_query, oplog_replay: true).to_a
-        end
-      end
-
-      context 'set on collection' do
-        it 'passes the option' do
-          event = Utils.get_command_event(client, 'find') do |client|
-            client[collection_name, oplog_replay: true].find(oplog_query).to_a
-          end
-          event.command.fetch('oplogReplay').should be true
-        end
-
-        it 'warns' do
-          client.should receive(:log_warn).with('The :oplog_replay option is deprecated and ignored by MongoDB 4.4 and later')
-          client[collection_name, oplog_replay: true].find(oplog_query).to_a
-        end
-      end
-    end
-  end
-
-  describe 'explain' do
-    context 'with explicit session' do
-      min_server_fcv '3.6'
-
-      it 'passes the session' do
-        client.start_session do |session|
-          event = Utils.get_command_event(client, 'explain') do |client|
-            client['foo'].find({}, session: session).explain.should be_explain_output
-          end
-          event.command.fetch('lsid').should == session.session_id
-        end
-      end
-    end
-
-    context 'with read preference specified on operation level' do
-      require_topology :sharded
-
-      # RUBY-2706
-      min_server_fcv '3.6'
-
-      it 'passes the read preference' do
-        event = Utils.get_command_event(client, 'explain') do |client|
-          client['foo'].find({}, read: {mode: :secondary_preferred}).explain.should be_explain_output
-        end
-        event.command.fetch('$readPreference').should == {'mode' => 'secondaryPreferred'}
-      end
-    end
-
-    context 'with read preference specified on collection level' do
-      require_topology :sharded
-
-      # RUBY-2706
-      min_server_fcv '3.6'
-
-      it 'passes the read preference' do
-        event = Utils.get_command_event(client, 'explain') do |client|
-          client['foo', read: {mode: :secondary_preferred}].find.explain.should be_explain_output
-        end
-        event.command.fetch('$readPreference').should == {'mode' => 'secondaryPreferred'}
-      end
-    end
-
-    context 'with read preference specified on client level' do
-      require_topology :sharded
-
-      # RUBY-2706
-      min_server_fcv '3.6'
-
-      let(:client) { authorized_client.with(read: {mode: :secondary_preferred}) }
-
-      it 'passes the read preference' do
-        event = Utils.get_command_event(client, 'explain') do |client|
-          client['foo'].find.explain.should be_explain_output
-        end
-        event.command.fetch('$readPreference').should == {'mode' => 'secondaryPreferred'}
-      end
-    end
-
-    context 'with read concern' do
-      # Read concern requires 3.2+ server.
-      min_server_fcv '3.2'
-
-      context 'with read concern specifed on operation level' do
-
-        # Read concern is not allowed in explain command, driver drops it.
-        it 'drops the read concern' do
-          event = Utils.get_command_event(client, 'explain') do |client|
-            client['foo'].find({}, read_concern: {level: :local}).explain.should have_key('queryPlanner')
-          end
-          event.command.should_not have_key('readConcern')
-        end
-      end
-
-      context 'with read concern specifed on collection level' do
-
-        # Read concern is not allowed in explain command, driver drops it.
-        it 'drops the read concern' do
-          event = Utils.get_command_event(client, 'explain') do |client|
-            client['foo', read_concern: {level: :local}].find.explain.should have_key('queryPlanner')
-          end
-          event.command.should_not have_key('readConcern')
-        end
-      end
-
-      context 'with read concern specifed on client level' do
-
-        let(:client) { authorized_client.with(read_concern: {level: :local}) }
-
-        # Read concern is not allowed in explain command, driver drops it.
-        it 'drops the read concern' do
-          event = Utils.get_command_event(client, 'explain') do |client|
-            client['foo'].find.explain.should have_key('queryPlanner')
-          end
-          event.command.should_not have_key('readConcern')
-        end
-      end
-    end
   end
 
   describe 'insert' do
diff --git a/spec/integration/cursor_pinning_spec.rb b/spec/integration/cursor_pinning_spec.rb
deleted file mode 100644
index bf1041e7a..000000000
--- a/spec/integration/cursor_pinning_spec.rb
+++ /dev/null
@@ -1,124 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-require 'spec_helper'
-
-describe 'Cursor pinning' do
-  let(:client) { authorized_client }
-  let(:collection_name) { 'cursor_pinning' }
-  let(:collection) { client[collection_name] }
-
-  before do
-    authorized_client[collection_name].insert_many([{test: 1}] * 200)
-  end
-
-  let(:server) { client.cluster.next_primary }
-
-  clean_slate
-
-  context 'non-lb' do
-    require_topology :single, :replica_set, :sharded
-    require_no_multi_shard
-
-    # When not in load-balanced topology, iterating a cursor creates
-    # new connections as needed.
-
-    it 'creates new connections for iteration' do
-      server.pool.size.should == 0
-
-      # Use batch_size of 2 until RUBY-2727 is fixed.
-      enum = collection.find({}, batch_size: 2).to_enum
-      # Still zero because we haven't iterated
-      server.pool.size.should == 0
-
-      enum.next
-      enum.next
-      server.pool.size.should == 1
-
-      # Grab the connection that was used
-      server.with_connection do
-        # This requires a new connection
-        enum.next
-
-        server.pool.size.should == 2
-      end
-    end
-  end
-
-  context 'lb' do
-    require_topology :load_balanced
-
-    # In load-balanced topology, we cannot create new connections to a
-    # particular service.
-
-    context 'when no connection is available' do
-
-      it 'raises NoServiceConnectionAvailable' do
-        server.pool.size.should == 0
-
-        enum = collection.find({}, batch_size: 1).to_enum
-        # Still zero because we haven't iterated
-        server.pool.size.should == 0
-
-        enum.next
-        server.pool.size.should == 1
-
-        # Grab the connection that was used
-        server.with_connection do
-          # This requires a new connection, but we cannot make one.
-          lambda do
-            enum.next
-          end.should raise_error(Mongo::Error::NoServiceConnectionAvailable)
-
-          server.pool.size.should == 1
-        end
-      end
-    end
-
-    context 'when connection is available' do
-      # This is tricky to test because the server doesn't report service ids,
-      # hence every connection has its own service id presently and
-      # therefore we cannot use another connection for completing iteration
-      # other than the one on which the iteration started.
-
-      let(:client) { authorized_client.with(max_pool_size: 4) }
-
-      it 'uses the available connection' do
-        server.pool.size.should == 0
-
-        # Create 4 connections.
-
-        enums = []
-        connections = []
-        service_ids = []
-
-        4.times do
-          view = collection.find({}, batch_size: 1)
-          enum = view.to_enum
-
-          enum.next
-
-          enums << enum
-          service_ids << view.cursor.initial_result.connection_description.service_id
-          connections << server.pool.check_out
-        end
-
-        service_ids.uniq.length.should be > 1
-
-        server.pool.size.should == 4
-
-        connections.each do |c|
-          server.pool.check_in(c)
-        end
-
-        # At this point, in theory, all connections are equally likely to
-        # be chosen, but we have cursors referencing more than one
-        # distinct service.
-        # Iterate each cursor to ensure they all continue to work.
-        enums.each do |enum|
-          enum.next
-        end
-      end
-    end
-  end
-end
diff --git a/spec/integration/cursor_reaping_spec.rb b/spec/integration/cursor_reaping_spec.rb
index 2ae347706..b79d3bb0f 100644
--- a/spec/integration/cursor_reaping_spec.rb
+++ b/spec/integration/cursor_reaping_spec.rb
@@ -8,8 +8,6 @@ describe 'Cursor reaping' do
   # in MRI, I don't currently know how to force GC to run in JRuby
   require_mri
 
-# Uncomment for debugging this test.
-=begin
   around(:all) do |example|
     saved_level = Mongo::Logger.logger.level
     Mongo::Logger.logger.level = Logger::DEBUG
@@ -19,7 +17,6 @@ describe 'Cursor reaping' do
       Mongo::Logger.logger.level = saved_level
     end
   end
-=end
 
   let(:subscriber) { EventSubscriber.new }
 
@@ -60,11 +57,10 @@ describe 'Cursor reaping' do
         10.times do
           scope = collection.find.batch_size(2).no_cursor_timeout
 
-          # Begin iteration, creating the cursor
+          # there is no API for retrieving the cursor
           scope.each.first
-
-          scope.cursor.should_not be nil
-          cursor_ids << scope.cursor.id
+          # and keep the first cursor
+          cursor_ids << scope.instance_variable_get('@cursor').id
         end
       end
     end
diff --git a/spec/integration/map_reduce_spec.rb b/spec/integration/map_reduce_spec.rb
deleted file mode 100644
index 38afed640..000000000
--- a/spec/integration/map_reduce_spec.rb
+++ /dev/null
@@ -1,77 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-require 'spec_helper'
-
-describe 'Map-reduce operations' do
-  let(:client) { authorized_client }
-  let(:collection) { client['mr_integration'] }
-
-  let(:subscriber) { EventSubscriber.new }
-
-  let(:find_options) { {} }
-
-  let(:operation) do
-    collection.find({}, find_options).map_reduce('function(){}', 'function(){}')
-  end
-
-  before do
-    collection.insert_one(test: 1)
-    client.subscribe(Mongo::Monitoring::COMMAND, subscriber)
-  end
-
-  let(:event) { subscriber.single_command_started_event('mapReduce') }
-
-  context 'read preference' do
-    require_topology :sharded
-
-    context 'specified on client' do
-      let(:client) { authorized_client.with(read: {mode: :secondary_preferred }) }
-
-      # RUBY-2706: read preference is not sent on pre-3.6 servers
-      min_server_fcv '3.6'
-
-      it 'is sent' do
-        operation.to_a
-
-        event.command['$readPreference'].should == {'mode' => 'secondaryPreferred'}
-      end
-    end
-
-    context 'specified on collection' do
-      let(:collection) { client['mr_integration', read: {mode: :secondary_preferred }] }
-
-      # RUBY-2706: read preference is not sent on pre-3.6 servers
-      min_server_fcv '3.6'
-
-      it 'is sent' do
-        operation.to_a
-
-        event.command['$readPreference'].should == {'mode' => 'secondaryPreferred'}
-      end
-    end
-
-    context 'specified on operation' do
-      let(:find_options) { {read: {mode: :secondary_preferred }} }
-
-      # RUBY-2706: read preference is not sent on pre-3.6 servers
-      min_server_fcv '3.6'
-
-      it 'is sent' do
-        operation.to_a
-
-        event.command['$readPreference'].should == {'mode' => 'secondaryPreferred'}
-      end
-    end
-  end
-
-  context 'session' do
-    min_server_fcv '3.6'
-
-    it 'is sent' do
-      operation.to_a
-
-      event.command['lsid'].should_not be nil
-    end
-  end
-end
diff --git a/spec/integration/reconnect_spec.rb b/spec/integration/reconnect_spec.rb
index 7a3607f85..c43d25469 100644
--- a/spec/integration/reconnect_spec.rb
+++ b/spec/integration/reconnect_spec.rb
@@ -16,38 +16,20 @@ describe 'Client after reconnect' do
     expect(doc['testk']).to eq('testv')
   end
 
-  context 'non-lb' do
-    require_topology :single, :replica_set, :sharded
+  it 'recreates monitor thread' do
+    thread = client.cluster.servers.first.monitor.instance_variable_get('@thread')
+    expect(thread).to be_alive
 
-    it 'recreates monitor thread' do
-      thread = client.cluster.servers.first.monitor.instance_variable_get('@thread')
-      expect(thread).to be_alive
-
-      thread.kill
-      # context switch to let the thread get killed
-      sleep 0.1
-      expect(thread).not_to be_alive
-
-      client.reconnect
-
-      new_thread = client.cluster.servers.first.monitor.instance_variable_get('@thread')
-      expect(new_thread).not_to eq(thread)
-      expect(new_thread).to be_alive
-    end
-  end
-
-  context 'lb' do
-    require_topology :load_balanced
+    thread.kill
+    # context switch to let the thread get killed
+    sleep 0.1
+    expect(thread).not_to be_alive
 
-    it 'does not recreate monitor thread' do
-      thread = client.cluster.servers.first.monitor.instance_variable_get('@thread')
-      expect(thread).to be nil
-
-      client.reconnect
+    client.reconnect
 
-      new_thread = client.cluster.servers.first.monitor.instance_variable_get('@thread')
-      expect(new_thread).to be nil
-    end
+    new_thread = client.cluster.servers.first.monitor.instance_variable_get('@thread')
+    expect(new_thread).not_to eq(thread)
+    expect(new_thread).to be_alive
   end
 
   context 'with min_pool_size > 0' do
diff --git a/spec/integration/sdam_error_handling_spec.rb b/spec/integration/sdam_error_handling_spec.rb
index 8b71fda5b..051cc732b 100644
--- a/spec/integration/sdam_error_handling_spec.rb
+++ b/spec/integration/sdam_error_handling_spec.rb
@@ -4,8 +4,6 @@
 require 'spec_helper'
 
 describe 'SDAM error handling' do
-  require_topology :single, :replica_set, :sharded
-
   clean_slate
 
   after do
diff --git a/spec/integration/server_monitor_spec.rb b/spec/integration/server_monitor_spec.rb
index 997852b67..53157e5f9 100644
--- a/spec/integration/server_monitor_spec.rb
+++ b/spec/integration/server_monitor_spec.rb
@@ -4,7 +4,6 @@
 require 'spec_helper'
 
 describe 'Server::Monitor' do
-  require_topology :single, :replica_set, :sharded
 
   let(:client) do
     new_local_client([ClusterConfig.instance.primary_address_str],
diff --git a/spec/integration/server_selector_spec.rb b/spec/integration/server_selector_spec.rb
index 615f52e0d..89a05cd4f 100644
--- a/spec/integration/server_selector_spec.rb
+++ b/spec/integration/server_selector_spec.rb
@@ -52,8 +52,6 @@ describe 'Server selector' do
       end
 
       context 'there is no known primary' do
-        require_topology :single, :replica_set, :sharded
-
         before do
           primary_server = client.cluster.next_primary
           client.close
@@ -61,30 +59,15 @@ describe 'Server selector' do
           primary_server.unknown!
         end
 
-        context 'non-lb' do
-          require_topology :single, :replica_set, :sharded
-
-          it 'raises NoServerAvailable with a message explaining the situation' do
-            expect do
-              result
-            end.to raise_error(Mongo::Error::NoServerAvailable, /The cluster is disconnected \(client may have been closed\)/)
-          end
-        end
-
-        context 'lb' do
-          require_topology :load_balanced
-
-          it 'returns the load balancer' do
-            expect(result).to be_a(Mongo::Server)
-            result.should be_load_balancer
-          end
+        it 'raises NoServerAvailable with a message explaining the situation' do
+          expect do
+            result
+          end.to raise_error(Mongo::Error::NoServerAvailable, /The cluster is disconnected \(client may have been closed\)/)
         end
       end
     end
 
     context 'monitoring thread is dead' do
-      require_topology :single, :replica_set, :sharded
-
       before do
         client.cluster.servers.each do |server|
           server.monitor.instance_variable_get('@thread').kill
diff --git a/spec/integration/server_spec.rb b/spec/integration/server_spec.rb
index 66d77bbda..3f02ed3f3 100644
--- a/spec/integration/server_spec.rb
+++ b/spec/integration/server_spec.rb
@@ -33,8 +33,6 @@ describe 'Server' do
       end
 
       context 'unknown server in disconnected cluster' do
-        require_topology :single, :replica_set, :sharded
-
         before do
           client.close
           server.unknown!
diff --git a/spec/integration/transaction_pinning_spec.rb b/spec/integration/transaction_pinning_spec.rb
deleted file mode 100644
index 08ca4b29f..000000000
--- a/spec/integration/transaction_pinning_spec.rb
+++ /dev/null
@@ -1,120 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-require 'spec_helper'
-
-describe 'Transaction pinning' do
-  let(:client) { authorized_client.with(max_pool_size: 4) }
-  let(:collection_name) { 'tx_pinning' }
-  let(:collection) { client[collection_name] }
-
-  before do
-    authorized_client[collection_name].insert_many([{test: 1}] * 200)
-  end
-
-  let(:server) { client.cluster.next_primary }
-
-  clean_slate
-
-  context 'non-lb' do
-    require_topology :sharded
-    min_server_fcv '4.2'
-
-    # Start several transactions, then complete each of them.
-    # Force each transaction to be on its own connection.
-
-    before do
-      4.times do |i|
-        # Collections cannot be created inside transactions.
-        client["tx_pin_t#{i}"].drop
-        client["tx_pin_t#{i}"].create
-      end
-    end
-
-    it 'works' do
-      sessions = []
-      connections = []
-
-      4.times do |i|
-        session = client.start_session
-        session.start_transaction
-        client["tx_pin_t#{i}"].insert_one({test: 1}, session: session)
-        session.pinned_server.should be_a(Mongo::Server)
-        sessions << session
-        connections << server.pool.check_out
-      end
-
-      server.pool.size.should == 4
-
-      connections.each do |c|
-        server.pool.check_in(c)
-      end
-
-      sessions.each_with_index do |session, i|
-        client["tx_pin_t#{i}"].insert_one({test: 2}, session: session)
-        session.commit_transaction
-      end
-    end
-  end
-
-  context 'lb' do
-    require_topology :load_balanced
-    min_server_fcv '4.2'
-
-    # In load-balanced topology, we cannot create new connections to a
-    # particular service.
-
-    context 'when no connection is available' do
-
-      before do
-        client["tx_pin"].drop
-        client["tx_pin"].create
-      end
-
-      it 'raises NoServiceConnectionAvailable' do
-        session = client.start_session
-        session.start_transaction
-        client["tx_pin"].insert_one({test: 1}, session: session)
-        session.pinned_server.should be nil
-        session.pinned_service_id.should_not be nil
-
-        server.pool.size.should == 1
-        server.pool.clear
-        server.pool.size.should == 0
-
-        lambda do
-          client["tx_pin"].insert_one({test: 2}, session: session)
-        end.should raise_error(Mongo::Error::NoServiceConnectionAvailable)
-      end
-    end
-
-    context 'when connection is available' do
-
-      it 'uses the available connection' do
-        sessions = []
-        connections = []
-
-        4.times do |i|
-          session = client.start_session
-          session.start_transaction
-          client["tx_pin_t#{i}"].insert_one({test: 1}, session: session)
-          session.pinned_server.should be nil
-          session.pinned_service_id.should_not be nil
-          sessions << session
-          connections << server.pool.check_out
-        end
-
-        server.pool.size.should == 4
-
-        connections.each do |c|
-          server.pool.check_in(c)
-        end
-
-        sessions.each_with_index do |session, i|
-          client["tx_pin_t#{i}"].insert_one({test: 2}, session: session)
-          session.commit_transaction
-        end
-      end
-    end
-  end
-end
diff --git a/spec/lite_spec_helper.rb b/spec/lite_spec_helper.rb
index b3ab77882..15be8dd17 100644
--- a/spec/lite_spec_helper.rb
+++ b/spec/lite_spec_helper.rb
@@ -16,6 +16,7 @@ RETRYABLE_READS_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/retryable_read
 COMMAND_MONITORING_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/command_monitoring/**/*.yml").sort
 CONNECTION_STRING_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/connection_string/*.yml").sort
 URI_OPTIONS_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/uri_options/*.yml").sort
+DNS_SEEDLIST_DISCOVERY_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/dns_seedlist_discovery/*.yml").sort
 GRIDFS_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/gridfs/*.yml").sort
 TRANSACTIONS_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/transactions/*.yml").sort
 TRANSACTIONS_API_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/transactions_api/*.yml").sort
diff --git a/spec/mongo/address/unix_spec.rb b/spec/mongo/address/unix_spec.rb
index dbe3c5ec8..20713aef4 100644
--- a/spec/mongo/address/unix_spec.rb
+++ b/spec/mongo/address/unix_spec.rb
@@ -28,7 +28,6 @@ describe Mongo::Address::Unix do
   end
 
   describe '#socket' do
-    require_unix_socket
 
     let(:address) do
       "/tmp/mongodb-#{SpecConfig.instance.any_port}.sock"
diff --git a/spec/mongo/client_construction_spec.rb b/spec/mongo/client_construction_spec.rb
index ecd95720c..e1c12b72c 100644
--- a/spec/mongo/client_construction_spec.rb
+++ b/spec/mongo/client_construction_spec.rb
@@ -24,8 +24,26 @@ describe Mongo::Client do
     end
 
     context 'with default scan: true' do
-
-      shared_examples 'does not wait for server selection timeout' do
+      # TODO this test requires there being no outstanding background
+      # monitoring threads running, as otherwise the scan! expectation
+      # can be executed on a thread that belongs to one of the global
+      # clients for instance
+      it 'performs one round of sdam' do
+        # Does not work due to
+        # https://github.com/rspec/rspec-mocks/issues/1242.
+        #expect_any_instance_of(Mongo::Server::Monitor).to receive(:scan!).
+        #  exactly(SpecConfig.instance.addresses.length).times.and_call_original
+        c = new_local_client(
+          SpecConfig.instance.addresses, SpecConfig.instance.test_options)
+        expect(c.cluster.servers).not_to be_empty
+      end
+
+      # This checks the case of all initial seeds being removed from
+      # cluster during SDAM
+      context 'me mismatch on the only initial seed' do
+        let(:address) do
+          ClusterConfig.instance.alternate_address.to_s
+        end
 
         let(:logger) do
           Logger.new(STDOUT, level: Logger::DEBUG)
@@ -76,7 +94,6 @@ describe Mongo::Client do
             Mongo::Cluster::Topology::ReplicaSetWithPrimary,
             Mongo::Cluster::Topology::Single,
             Mongo::Cluster::Topology::Sharded,
-            Mongo::Cluster::Topology::LoadBalanced,
           ]).to include(actual_class)
           expect(time_taken).to be < 5
 
@@ -84,44 +101,6 @@ describe Mongo::Client do
           client.database.command(ping: 1)
         end
       end
-
-      context 'when cluster is monitored' do
-        require_topology :single, :replica_set, :sharded
-
-        # TODO this test requires there being no outstanding background
-        # monitoring threads running, as otherwise the scan! expectation
-        # can be executed on a thread that belongs to one of the global
-        # clients for instance
-        it 'performs one round of sdam' do
-          # Does not work due to
-          # https://github.com/rspec/rspec-mocks/issues/1242.
-          #expect_any_instance_of(Mongo::Server::Monitor).to receive(:scan!).
-          #  exactly(SpecConfig.instance.addresses.length).times.and_call_original
-          c = new_local_client(
-            SpecConfig.instance.addresses, SpecConfig.instance.test_options)
-          expect(c.cluster.servers).not_to be_empty
-        end
-
-        # This checks the case of all initial seeds being removed from
-        # cluster during SDAM
-        context 'me mismatch on the only initial seed' do
-          let(:address) do
-            ClusterConfig.instance.alternate_address.to_s
-          end
-
-          include_examples 'does not wait for server selection timeout'
-        end
-      end
-
-      context 'when cluster is not monitored' do
-        require_topology :load_balanced
-
-        let(:address) do
-          ClusterConfig.instance.alternate_address.to_s
-        end
-
-        include_examples 'does not wait for server selection timeout'
-      end
     end
 
     context 'with monitoring_io: false' do
@@ -409,24 +388,10 @@ describe Mongo::Client do
             end.should_not raise_error
           end
 
-          context 'non-lb' do
-            require_topology :single, :replica_set, :sharded
-
-            it 'fails server selection due to very small timeout' do
-              lambda do
-                client.database.command(ping: 1)
-              end.should raise_error(Mongo::Error::NoServerAvailable)
-            end
-          end
-
-          context 'lb' do
-            require_topology :load_balanced
-
-            it 'fails the operation after successful server selection' do
-              lambda do
-                client.database.command(ping: 1)
-              end.should raise_error(Mongo::Error::SocketTimeoutError, /socket took over.*to connect/)
-            end
+          it 'fails server selection due to very small timeout' do
+            lambda do
+              client.database.command(ping: 1)
+            end.should raise_error(Mongo::Error::NoServerAvailable)
           end
         end
 
@@ -1327,153 +1292,6 @@ describe Mongo::Client do
             client.options[:connect].should be :sharded
           end
         end
-
-        context 'load_balanced: true and multiple seeds' do
-          let(:client) do
-            new_local_client_nmio(['127.0.0.1:27017', '127.0.0.2:27017'],
-              load_balanced: true)
-          end
-
-          it 'is rejected' do
-            lambda do
-              client
-            end.should raise_error(ArgumentError, /load_balanced=true cannot be used with multiple seeds/)
-          end
-        end
-
-        context 'load_balanced: false and multiple seeds' do
-          let(:client) do
-            new_local_client_nmio(['127.0.0.1:27017', '127.0.0.2:27017'],
-              load_balanced: false)
-          end
-
-          it 'is accepted' do
-            lambda do
-              client
-            end.should_not raise_error
-            client.options[:load_balanced].should be false
-          end
-        end
-
-        context 'load_balanced: true and direct_connection: true' do
-          let(:client) do
-            new_local_client_nmio(['127.0.0.1:27017'],
-              load_balanced: true, direct_connection: true)
-          end
-
-          it 'is rejected' do
-            lambda do
-              client
-            end.should raise_error(ArgumentError, /direct_connection=true cannot be used with load_balanced=true/)
-          end
-        end
-
-        context 'load_balanced: true and direct_connection: false' do
-          let(:client) do
-            new_local_client_nmio(['127.0.0.1:27017'],
-              load_balanced: true, direct_connection: false)
-          end
-
-          it 'is accepted' do
-            lambda do
-              client
-            end.should_not raise_error
-            client.options[:load_balanced].should be true
-            client.options[:direct_connection].should be false
-          end
-        end
-
-        context 'load_balanced: false and direct_connection: true' do
-          let(:client) do
-            new_local_client_nmio(['127.0.0.1:27017'],
-              load_balanced: false, direct_connection: true)
-          end
-
-          it 'is accepted' do
-            lambda do
-              client
-            end.should_not raise_error
-            client.options[:load_balanced].should be false
-            client.options[:direct_connection].should be true
-          end
-        end
-
-        [:direct, 'direct', :sharded, 'sharded'].each do |v|
-          context "load_balanced: true and connect: #{v.inspect}" do
-            let(:client) do
-              new_local_client_nmio(['127.0.0.1:27017'],
-                load_balanced: true, connect: v)
-            end
-
-            it 'is rejected' do
-              lambda do
-                client
-              end.should raise_error(ArgumentError, /connect=#{v} cannot be used with load_balanced=true/)
-            end
-          end
-        end
-
-        [nil].each do |v|
-          context "load_balanced: true and connect: #{v.inspect}" do
-            let(:client) do
-              new_local_client_nmio(['127.0.0.1:27017'],
-                load_balanced: true, connect: v)
-            end
-
-            it 'is accepted' do
-              lambda do
-                client
-              end.should_not raise_error
-              client.options[:load_balanced].should be true
-              client.options[:connect].should eq v
-            end
-          end
-        end
-
-        [:load_balanced, 'load_balanced'].each do |v|
-          context "load_balanced: true and connect: #{v.inspect}" do
-            let(:client) do
-              new_local_client_nmio(['127.0.0.1:27017'],
-                load_balanced: true, connect: v)
-            end
-
-            it 'is accepted' do
-              lambda do
-                client
-              end.should_not raise_error
-              client.options[:load_balanced].should be true
-              client.options[:connect].should eq v
-            end
-          end
-        end
-
-        [:replica_set, 'replica_set'].each do |v|
-          context "load_balanced: true and connect: #{v.inspect}" do
-            let(:client) do
-              new_local_client_nmio(['127.0.0.1:27017'],
-                load_balanced: true, connect: v, replica_set: 'x')
-            end
-
-            it 'is rejected' do
-              lambda do
-                client
-              end.should raise_error(ArgumentError, /connect=replica_set cannot be used with load_balanced=true/)
-            end
-          end
-
-          context "load_balanced: true and #{v.inspect} option" do
-            let(:client) do
-              new_local_client_nmio(['127.0.0.1:27017'],
-                load_balanced: true, v => 'rs')
-            end
-
-            it 'is rejected' do
-              lambda do
-                client
-              end.should raise_error(ArgumentError, /load_balanced=true cannot be used with replica_set option/)
-            end
-          end
-        end
       end
 
       context ':bg_error_backtrace option' do
@@ -2488,12 +2306,7 @@ describe Mongo::Client do
       before do
         client.cluster.next_primary
         events = subscriber.select_started_events(Mongo::Monitoring::Event::ServerHeartbeatStarted)
-        if ClusterConfig.instance.topology == :load_balanced
-          # No server monitoring in LB topology
-          events.length.should == 0
-        else
-          events.length.should > 0
-        end
+        events.length.should > 0
       end
 
       it 'does not copy sdam_proc option to new client' do
@@ -2505,12 +2318,7 @@ describe Mongo::Client do
         # Give those some time to be processed.
         sleep 2
 
-        if ClusterConfig.instance.topology == :load_balanced
-          # No server monitoring in LB topology
-          expect(subscriber.started_events.length).to eq 0
-        else
-          expect(subscriber.started_events.length).to be > 0
-        end
+        expect(subscriber.started_events.length).to be > 0
         subscriber.started_events.clear
 
         # If this test takes longer than heartbeat interval,
diff --git a/spec/mongo/client_spec.rb b/spec/mongo/client_spec.rb
index 6b2290a2a..6e8bcd73d 100644
--- a/spec/mongo/client_spec.rb
+++ b/spec/mongo/client_spec.rb
@@ -939,15 +939,13 @@ describe Mongo::Client do
     end
 
     context 'monitoring present' do
-      require_topology :single, :replica_set, :sharded
-
       let(:client) do
         authorized_client
       end
 
       it 'does not indicate lack of monitoring' do
-        client.summary.should =~ /servers=.*(?:STANDALONE|PRIMARY|MONGOS)/
-        client.summary.should_not =~ /servers=.*(?:STANDALONE|PRIMARY|MONGOS).*NO-MONITORING/
+        client.summary.should =~ /servers=.*(STANDALONE|PRIMARY|MONGOS)/
+        client.summary.should_not =~ /servers=.*(STANDALONE|PRIMARY|MONGOS).*NO-MONITORING/
       end
     end
 
@@ -959,7 +957,7 @@ describe Mongo::Client do
       end
 
       it 'does not indicate lack of monitoring' do
-        client.summary.should =~ /servers=.*(STANDALONE|PRIMARY|MONGOS|\bLB\b).*NO-MONITORING/
+        client.summary.should =~ /servers=.*(STANDALONE|PRIMARY|MONGOS).*NO-MONITORING/
       end
     end
   end
diff --git a/spec/mongo/cluster/cursor_reaper_spec.rb b/spec/mongo/cluster/cursor_reaper_spec.rb
index c8845fb7d..5c7cdbf46 100644
--- a/spec/mongo/cluster/cursor_reaper_spec.rb
+++ b/spec/mongo/cluster/cursor_reaper_spec.rb
@@ -5,18 +5,16 @@ require 'spec_helper'
 
 describe Mongo::Cluster::CursorReaper do
 
-  let(:cluster) { double('cluster') }
-
   before do
     authorized_collection.drop
   end
 
   let(:reaper) do
-    described_class.new(cluster)
+    described_class.new
   end
 
-  let(:active_cursor_ids) do
-    reaper.instance_variable_get(:@active_cursor_ids)
+  let(:active_cursors) do
+    reaper.instance_variable_get(:@active_cursors)
   end
 
   describe '#intialize' do
@@ -26,29 +24,16 @@ describe Mongo::Cluster::CursorReaper do
     end
 
     it 'initializes a set for the list of active cursors' do
-      expect(reaper.instance_variable_get(:@active_cursor_ids)).to be_a(Set)
+      expect(reaper.instance_variable_get(:@active_cursors)).to be_a(Set)
     end
   end
 
   describe '#schedule_kill_cursor' do
 
-    let(:address) { Mongo::Address.new('localhost') }
-    let(:server) do
-      double('server').tap do |server|
-        allow(server).to receive(:address).and_return(address)
-      end
-    end
+    let(:server) { double('server') }
     let(:cursor_id) { 1 }
-    let(:cursor_kill_spec_1) do
-      Mongo::Cursor::KillSpec.new(
-        cursor_id: cursor_id, coll_name: 'c', db_name: 'd', service_id: nil,
-      )
-    end
-    let(:cursor_kill_spec_2) do
-      Mongo::Cursor::KillSpec.new(
-        cursor_id: cursor_id, coll_name: 'c', db_name: 'q', service_id: nil,
-      )
-    end
+    let(:op_spec_1) { double('op_spec_1') }
+    let(:op_spec_2) { double('op_spec_2') }
     let(:to_kill) { reaper.instance_variable_get(:@to_kill)}
 
     context 'when the cursor is on the list of active cursors' do
@@ -60,36 +45,36 @@ describe Mongo::Cluster::CursorReaper do
       context 'when there is not a list already for the server' do
 
         before do
-          reaper.schedule_kill_cursor(cursor_kill_spec_1, server)
+          reaper.schedule_kill_cursor(cursor_id, op_spec_1, server)
         end
 
         it 'initializes the list of op specs to a set' do
-          expect(to_kill.keys).to eq([ address.seed ])
-          expect(to_kill[address.seed]).to eq(Set.new([cursor_kill_spec_1]))
+          expect(to_kill.keys).to eq([ server ])
+          expect(to_kill[server]).to eq(Set.new([op_spec_1]))
         end
       end
 
       context 'when there is a list of ops already for the server' do
 
         before do
-          reaper.schedule_kill_cursor(cursor_kill_spec_1, server)
-          reaper.schedule_kill_cursor(cursor_kill_spec_2, server)
+          reaper.schedule_kill_cursor(cursor_id, op_spec_1, server)
+          reaper.schedule_kill_cursor(cursor_id, op_spec_2, server)
         end
 
         it 'adds the op to the server list' do
-          expect(to_kill.keys).to eq([ address.seed ])
-          expect(to_kill[address.seed]).to contain_exactly(cursor_kill_spec_1, cursor_kill_spec_2)
+          expect(to_kill.keys).to eq([ server ])
+          expect(to_kill[server]).to contain_exactly(op_spec_1, op_spec_2)
         end
 
         context 'when the same op is added more than once' do
 
           before do
-            reaper.schedule_kill_cursor(cursor_kill_spec_2, server)
+            reaper.schedule_kill_cursor(cursor_id, op_spec_2, server)
           end
 
           it 'does not allow duplicates ops for a server' do
-            expect(to_kill.keys).to eq([ address.seed ])
-            expect(to_kill[address.seed]).to contain_exactly(cursor_kill_spec_1, cursor_kill_spec_2)
+            expect(to_kill.keys).to eq([ server ])
+            expect(to_kill[server]).to contain_exactly(op_spec_1, op_spec_2)
           end
         end
       end
@@ -98,7 +83,7 @@ describe Mongo::Cluster::CursorReaper do
     context 'when the cursor is not on the list of active cursors' do
 
       before do
-        reaper.schedule_kill_cursor(cursor_kill_spec_1, server)
+        reaper.schedule_kill_cursor(cursor_id, op_spec_1, server)
       end
 
       it 'does not add the kill cursors op spec to the list' do
@@ -146,7 +131,7 @@ describe Mongo::Cluster::CursorReaper do
       end
 
       it 'registers the cursor id as active' do
-        expect(active_cursor_ids).to eq(Set.new([2]))
+        expect(active_cursors).to eq(Set.new([2]))
       end
     end
   end
@@ -161,7 +146,7 @@ describe Mongo::Cluster::CursorReaper do
       end
 
       it 'removes the cursor id' do
-        expect(active_cursor_ids.size).to eq(0)
+        expect(active_cursors.size).to eq(0)
       end
     end
   end
@@ -189,7 +174,7 @@ describe Mongo::Cluster::CursorReaper do
     around do |example|
       authorized_collection.insert_many(docs)
       periodic_executor.stop!
-      cluster.schedule_kill_cursor(cursor.kill_spec,
+      cluster.schedule_kill_cursor(cursor.id, cursor.send(:kill_cursors_op_spec),
                                    cursor.instance_variable_get(:@server))
       periodic_executor.flush
       example.run
diff --git a/spec/mongo/cluster/periodic_executor_spec.rb b/spec/mongo/cluster/periodic_executor_spec.rb
index 3ab888050..e879f76fe 100644
--- a/spec/mongo/cluster/periodic_executor_spec.rb
+++ b/spec/mongo/cluster/periodic_executor_spec.rb
@@ -5,10 +5,8 @@ require 'spec_helper'
 
 describe Mongo::Cluster::PeriodicExecutor do
 
-  let(:cluster) { double('cluster') }
-
   let(:executor) do
-    described_class.new(cluster)
+    described_class.new
   end
 
   describe '#log_warn' do
diff --git a/spec/mongo/cluster_spec.rb b/spec/mongo/cluster_spec.rb
index 95d6b335a..4e0395665 100644
--- a/spec/mongo/cluster_spec.rb
+++ b/spec/mongo/cluster_spec.rb
@@ -425,7 +425,7 @@ describe Mongo::Cluster do
     end
 
     let(:primary_candidates) do
-      if cluster.single? || cluster.load_balanced?
+      if cluster.single?
         cluster.servers
       elsif cluster.sharded?
         cluster.servers
@@ -611,17 +611,7 @@ describe Mongo::Cluster do
             monitoring_io: false, server_selection_timeout: 0.183))
       end
 
-      context 'in load-balanced topology' do
-        require_topology :load_balanced
-
-        it_behaves_like 'supports sessions'
-      end
-
-      context 'not in load-balanced topology' do
-        require_topology :single, :replica_set, :sharded
-
-        it_behaves_like 'does not support sessions'
-      end
+      it_behaves_like 'does not support sessions'
     end
 
     context 'when client has contacted servers and then disconnected' do
@@ -771,9 +761,6 @@ describe Mongo::Cluster do
     let(:default_address) { SpecConfig.instance.addresses.first }
 
     context 'cluster has unknown servers' do
-      # Servers are never unknown in load-balanced topology.
-      require_topology :single, :replica_set, :sharded
-
       it 'includes unknown servers' do
         cluster.servers_list.each do |server|
           expect(server).to be_unknown
diff --git a/spec/mongo/collection/view/builder/find_command_spec.rb b/spec/mongo/collection/view/builder/find_command_spec.rb
index 74cc23a9a..5ab7ffa92 100644
--- a/spec/mongo/collection/view/builder/find_command_spec.rb
+++ b/spec/mongo/collection/view/builder/find_command_spec.rb
@@ -1,9 +1,6 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-# TODO convert, move or delete these tests as part of RUBY-2706.
-
-=begin
 require 'lite_spec_helper'
 
 describe Mongo::Collection::View::Builder::FindCommand do
@@ -525,4 +522,3 @@ describe Mongo::Collection::View::Builder::FindCommand do
     end
   end
 end
-=end
diff --git a/spec/mongo/operation/find/builder/flags_spec.rb b/spec/mongo/collection/view/builder/flags_spec.rb
similarity index 96%
rename from spec/mongo/operation/find/builder/flags_spec.rb
rename to spec/mongo/collection/view/builder/flags_spec.rb
index a2b480d70..df4cd36af 100644
--- a/spec/mongo/operation/find/builder/flags_spec.rb
+++ b/spec/mongo/collection/view/builder/flags_spec.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-require 'lite_spec_helper'
+require 'spec_helper'
 
-describe Mongo::Operation::Find::Builder::Flags do
+describe Mongo::Collection::View::Builder::Flags do
 
   describe '.map_flags' do
 
diff --git a/spec/mongo/operation/find/builder/modifiers_spec.rb b/spec/mongo/collection/view/builder/modifiers_spec.rb
similarity index 98%
rename from spec/mongo/operation/find/builder/modifiers_spec.rb
rename to spec/mongo/collection/view/builder/modifiers_spec.rb
index e1d472974..33966fe8e 100644
--- a/spec/mongo/operation/find/builder/modifiers_spec.rb
+++ b/spec/mongo/collection/view/builder/modifiers_spec.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-require 'lite_spec_helper'
+require 'spec_helper'
 
-describe Mongo::Operation::Find::Builder::Modifiers do
+describe Mongo::Collection::View::Builder::Modifiers do
 
   describe '.map_driver_options' do
 
diff --git a/spec/mongo/collection/view/builder/op_query_spec.rb b/spec/mongo/collection/view/builder/op_query_spec.rb
index 6e4b67c8d..710ca0712 100644
--- a/spec/mongo/collection/view/builder/op_query_spec.rb
+++ b/spec/mongo/collection/view/builder/op_query_spec.rb
@@ -1,9 +1,6 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-# TODO convert, move or delete these tests as part of RUBY-2706.
-
-=begin
 require 'spec_helper'
 
 describe Mongo::Collection::View::Builder::OpQuery do
@@ -158,4 +155,3 @@ describe Mongo::Collection::View::Builder::OpQuery do
     end
   end
 end
-=end
diff --git a/spec/mongo/collection_crud_spec.rb b/spec/mongo/collection_crud_spec.rb
index d3841565c..0ccadbc8d 100644
--- a/spec/mongo/collection_crud_spec.rb
+++ b/spec/mongo/collection_crud_spec.rb
@@ -1894,11 +1894,6 @@ describe Mongo::Collection do
     context 'when a session supporting causal consistency is used' do
       require_wired_tiger
 
-      before do
-        collection.drop
-        collection.create
-      end
-
       let(:cursors) do
         collection.parallel_scan(2, session: session)
       end
@@ -4357,7 +4352,7 @@ describe Mongo::Collection do
         expect(command[:writeConcern]).to_not be_nil
         expect(command[:writeConcern][:w]).to eq(1)
         expect(command[:upsert]).to be(true)
-        expect(command[:bypassDocumentValidation]).to be false
+        expect(command[:bypassDocumentValidation]).to be_nil
         expect(command[:maxTimeMS]).to eq(200)
       end
     end
diff --git a/spec/mongo/cursor/builder/get_more_command_spec.rb b/spec/mongo/cursor/builder/get_more_command_spec.rb
index bdffd7656..bfec873b4 100644
--- a/spec/mongo/cursor/builder/get_more_command_spec.rb
+++ b/spec/mongo/cursor/builder/get_more_command_spec.rb
@@ -1,9 +1,6 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-# TODO convert, move or delete these tests as part of RUBY-2706.
-
-=begin
 require 'spec_helper'
 
 describe Mongo::Cursor::Builder::GetMoreCommand do
@@ -192,4 +189,3 @@ describe Mongo::Cursor::Builder::GetMoreCommand do
     end
   end
 end
-=end
diff --git a/spec/mongo/cursor/builder/op_get_more_spec.rb b/spec/mongo/cursor/builder/op_get_more_spec.rb
index 7f4531d62..8bc864b5d 100644
--- a/spec/mongo/cursor/builder/op_get_more_spec.rb
+++ b/spec/mongo/cursor/builder/op_get_more_spec.rb
@@ -1,9 +1,6 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-# TODO convert, move or delete these tests as part of RUBY-2706.
-
-=begin
 require 'spec_helper'
 
 describe Mongo::Cursor::Builder::OpGetMore do
@@ -65,4 +62,3 @@ describe Mongo::Cursor::Builder::OpGetMore do
     end
   end
 end
-=end
diff --git a/spec/mongo/cursor/builder/op_kill_cursors_spec.rb b/spec/mongo/cursor/builder/op_kill_cursors_spec.rb
new file mode 100644
index 000000000..f2af3c0a1
--- /dev/null
+++ b/spec/mongo/cursor/builder/op_kill_cursors_spec.rb
@@ -0,0 +1,66 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+require 'spec_helper'
+
+describe Mongo::Cursor::Builder::OpKillCursors do
+
+  let(:reply) do
+    Mongo::Protocol::Reply.allocate.tap do |reply|
+      allow(reply).to receive(:cursor_id).and_return(8000)
+    end
+  end
+
+  let(:description) do
+    Mongo::Server::Description.new(
+      double('description address'),
+      { 'minWireVersion' => 0, 'maxWireVersion' => 2 }
+    )
+  end
+
+  let(:result) do
+    Mongo::Operation::Result.new(reply, description)
+  end
+
+  let(:view) do
+    Mongo::Collection::View.new(
+      authorized_collection,
+      {},
+      tailable: true,
+      max_time_ms: 100
+    )
+  end
+
+  let(:cursor) do
+    Mongo::Cursor.new(view, result, authorized_primary)
+  end
+
+  let(:builder) do
+    described_class.new(cursor)
+  end
+
+  describe '#specification' do
+
+    let(:specification) do
+      builder.specification
+    end
+
+    it 'includes the cursor ids' do
+      expect(specification[:cursor_ids]).to eq([BSON::Int64.new(8000)])
+    end
+
+    it 'includes the database name' do
+      expect(specification[:db_name]).to eq(SpecConfig.instance.test_db)
+    end
+
+    it 'includes the collection name' do
+      expect(specification[:coll_name]).to eq(TEST_COLL)
+    end
+  end
+
+  describe '.get_cursors_list' do
+    it 'returns integer cursor ids' do
+      expect(described_class.get_cursors_list(builder.specification)).to eq([8000])
+    end
+  end
+end
diff --git a/spec/mongo/cursor_spec.rb b/spec/mongo/cursor_spec.rb
index 0463d29a1..5597640c4 100644
--- a/spec/mongo/cursor_spec.rb
+++ b/spec/mongo/cursor_spec.rb
@@ -80,8 +80,6 @@ describe Mongo::Cursor do
     end
 
     context 'server is unknown' do
-      require_topology :single, :replica_set, :sharded
-
       let(:server) do
         view.send(:server_selector).select_server(authorized_client.cluster).tap do |server|
           authorized_client.cluster.disconnect!
@@ -331,7 +329,8 @@ describe Mongo::Cursor do
 
       before do
         authorized_collection.insert_many(documents)
-        cluster.schedule_kill_cursor(cursor.kill_spec,
+        cluster.schedule_kill_cursor(cursor.id,
+                                     cursor.send(:kill_cursors_op_spec),
                                      cursor.instance_variable_get(:@server))
       end
 
@@ -430,7 +429,7 @@ describe Mongo::Cursor do
 
       it 'removes the cursor id from the active cursors tracked by the cluster cursor manager' do
         enum.next
-        expect(cursor_reaper.instance_variable_get(:@active_cursor_ids)).not_to include(cursor_id)
+        expect(cursor_reaper.instance_variable_get(:@active_cursors)).not_to include(cursor_id)
       end
     end
   end
@@ -556,17 +555,8 @@ describe Mongo::Cursor do
         db_name: SpecConfig.instance.test_db, coll_name: TEST_COLL }
     end
 
-    let(:conn_desc) do
-      double('connection description').tap do |cd|
-        allow(cd).to receive(:service_id).and_return(nil)
-      end
-    end
-
     let(:reply) do
-      double('reply').tap do |reply|
-        allow(reply).to receive(:is_a?).with(Mongo::Operation::Result).and_return(true)
-        allow(reply).to receive(:namespace)
-        allow(reply).to receive(:connection_description).and_return(conn_desc)
+      Mongo::Operation::Find.new(query_spec).tap do |reply|
         allow(reply).to receive(:cursor_id).and_return(42)
       end
     end
diff --git a/spec/mongo/database_spec.rb b/spec/mongo/database_spec.rb
index 7938a34a0..279d90f6e 100644
--- a/spec/mongo/database_spec.rb
+++ b/spec/mongo/database_spec.rb
@@ -732,12 +732,12 @@ describe Mongo::Database do
         database.cluster.next_primary
       end
 
-      it 'uses read preference of primary' do
-        RSpec::Mocks.with_temporary_scope do
-          expect(primary_server).to receive(:with_connection).with(any_args).and_call_original
+      before do
+        expect(primary_server).to receive(:with_connection).at_least(:once).and_call_original
+      end
 
-          expect(database.command(ping: 1)).to be_successful
-        end
+      it 'uses read preference of primary' do
+        expect(database.command(ping: 1)).to be_successful
       end
     end
 
@@ -760,12 +760,12 @@ describe Mongo::Database do
         described_class.new(client, SpecConfig.instance.test_db, client.options)
       end
 
-      it 'does not use the client read preference 'do
-        RSpec::Mocks.with_temporary_scope do
-          expect(primary_server).to receive(:with_connection).with(any_args).and_call_original
+      before do
+        expect(primary_server).to receive(:with_connection).at_least(:once).and_call_original
+      end
 
-          expect(database.command(ping: 1)).to be_successful
-        end
+      it 'does not use the client read preference 'do
+        expect(database.command(ping: 1)).to be_successful
       end
     end
 
diff --git a/spec/mongo/operation/delete/op_msg_spec.rb b/spec/mongo/operation/delete/op_msg_spec.rb
index 4d0f698ba..5e1fc9585 100644
--- a/spec/mongo/operation/delete/op_msg_spec.rb
+++ b/spec/mongo/operation/delete/op_msg_spec.rb
@@ -95,7 +95,7 @@ describe Mongo::Operation::Delete::OpMsg do
     context 'when write concern is specified' do
 
       it 'includes write concern in the selector' do
-        expect(op.send(:command, connection)[:writeConcern]).to eq(BSON::Document.new(write_concern.options))
+        expect(op.send(:command, connection)[:writeConcern]).to eq(write_concern.options)
       end
     end
   end
diff --git a/spec/mongo/operation/find/legacy_spec.rb b/spec/mongo/operation/find/legacy_spec.rb
index f9cf973f3..c7dac4f75 100644
--- a/spec/mongo/operation/find/legacy_spec.rb
+++ b/spec/mongo/operation/find/legacy_spec.rb
@@ -78,7 +78,6 @@ describe Mongo::Operation::Find::Legacy do
         double('description').tap do |description|
           expect(description).to receive(:mongos?) { false }
           expect(description).to receive(:standalone?) { false }
-          #expect(description).to receive(:load_balancer?) { false }
         end
       end
 
diff --git a/spec/mongo/operation/insert/op_msg_spec.rb b/spec/mongo/operation/insert/op_msg_spec.rb
index be1274fc8..3b1fc765f 100644
--- a/spec/mongo/operation/insert/op_msg_spec.rb
+++ b/spec/mongo/operation/insert/op_msg_spec.rb
@@ -95,7 +95,7 @@ describe Mongo::Operation::Insert::OpMsg do
     context 'when write concern is specified' do
 
       it 'includes write concern in the selector' do
-        expect(op.send(:command, connection)[:writeConcern]).to eq(BSON::Document.new(write_concern.options))
+        expect(op.send(:command, connection)[:writeConcern]).to eq(write_concern.options)
       end
     end
   end
diff --git a/spec/mongo/operation/kill_cursors_spec.rb b/spec/mongo/operation/kill_cursors_spec.rb
index 1a5dea7ba..20c24a7e7 100644
--- a/spec/mongo/operation/kill_cursors_spec.rb
+++ b/spec/mongo/operation/kill_cursors_spec.rb
@@ -35,12 +35,9 @@ describe Mongo::Operation::KillCursors::Legacy do
   end
 
   describe '#message' do
-    let(:expected_cursor_ids) do
-      spec[:cursor_ids].map { |v| BSON::Int64.new(v) }
-    end
 
     it 'creates a kill cursors wire protocol message with correct specs' do
-      expect(Mongo::Protocol::KillCursors).to receive(:new).with(TEST_COLL, SpecConfig.instance.test_db, expected_cursor_ids)
+      expect(Mongo::Protocol::KillCursors).to receive(:new).with(TEST_COLL, SpecConfig.instance.test_db, spec[:cursor_ids])
       op.send(:message, double('server'))
     end
   end
diff --git a/spec/mongo/operation/read_preference_legacy_spec.rb b/spec/mongo/operation/read_preference_legacy_spec.rb
index 1fb4ff5e3..0c0dbd3eb 100644
--- a/spec/mongo/operation/read_preference_legacy_spec.rb
+++ b/spec/mongo/operation/read_preference_legacy_spec.rb
@@ -33,16 +33,12 @@ describe Mongo::Operation::ReadPreferenceSupported do
     double('description').tap do |description|
       allow(description).to receive(:mongos?).and_return(mongos?)
       allow(description).to receive(:standalone?).and_return(standalone?)
-      # TODO consider adding tests for load-balanced topologies also
-      allow(description).to receive(:load_balancer?).and_return(false)
     end
   end
 
   let(:server) do
     double('server').tap do |server|
       allow(server).to receive(:cluster).and_return(cluster)
-      # TODO consider adding tests for load-balanced topologies also
-      allow(server).to receive(:load_balancer?).and_return(false)
     end
   end
 
diff --git a/spec/mongo/operation/read_preference_op_msg_spec.rb b/spec/mongo/operation/read_preference_op_msg_spec.rb
index 29b68a658..f1c9262a4 100644
--- a/spec/mongo/operation/read_preference_op_msg_spec.rb
+++ b/spec/mongo/operation/read_preference_op_msg_spec.rb
@@ -41,8 +41,6 @@ describe Mongo::Operation::SessionsSupported do
   let(:server) do
     double('server').tap do |server|
       allow(server).to receive(:cluster).and_return(cluster)
-      # TODO consider adding tests for load-balanced topologies also
-      allow(server).to receive(:load_balancer?).and_return(false)
     end
   end
 
diff --git a/spec/mongo/operation/update/op_msg_spec.rb b/spec/mongo/operation/update/op_msg_spec.rb
index 144692f23..60f62a794 100644
--- a/spec/mongo/operation/update/op_msg_spec.rb
+++ b/spec/mongo/operation/update/op_msg_spec.rb
@@ -101,7 +101,7 @@ describe Mongo::Operation::Update::OpMsg do
     context 'when write concern is specified' do
 
       it 'includes write concern in the selector' do
-        expect(op.send(:command, connection)[:writeConcern]).to eq(BSON::Document.new(write_concern.options))
+        expect(op.send(:command, connection)[:writeConcern]).to eq(write_concern.options)
       end
     end
   end
diff --git a/spec/mongo/query_cache_spec.rb b/spec/mongo/query_cache_spec.rb
index 0ef3fe3b9..c3f5e7fce 100644
--- a/spec/mongo/query_cache_spec.rb
+++ b/spec/mongo/query_cache_spec.rb
@@ -139,11 +139,7 @@ describe Mongo::QueryCache do
 
   describe '#get' do
     let(:view) { double("Mongo::Collection::View") }
-    let(:result) do
-      double("Mongo::Operation::Result").tap do |result|
-        allow(result).to receive(:is_a?).with(Mongo::Operation::Result).and_return(true)
-      end
-    end
+    let(:result) { double("Mongo::Operation::Result") }
     let(:server) { double("Mongo::Server") }
     let(:caching_cursor) { Mongo::CachingCursor.new(view, result, server) }
 
diff --git a/spec/mongo/server/connection_common_spec.rb b/spec/mongo/server/connection_common_spec.rb
index 54a922bb8..6cc4fee1f 100644
--- a/spec/mongo/server/connection_common_spec.rb
+++ b/spec/mongo/server/connection_common_spec.rb
@@ -1,47 +1,24 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-require 'lite_spec_helper'
+require 'spec_helper'
 
 describe Mongo::Server::ConnectionCommon do
   let(:subject) { described_class.new }
 
   describe '#handshake_document' do
-    let(:metadata) do
-      Mongo::Server::AppMetadata.new({})
+    it 'returns hello document with API version' do
+      meta = Mongo::Server::AppMetadata.new({
+        server_api: { version: '1'  }
+      })
+      document = subject.handshake_document(meta)
+      expect(document['hello']).to eq(1)
     end
 
-    let(:document) do
-      subject.handshake_document(metadata)
-    end
-
-    context 'with api version' do
-      let(:metadata) do
-        Mongo::Server::AppMetadata.new({
-          server_api: { version: '1'  }
-        })
-      end
-
-      it 'returns hello document with API version' do
-        expect(document['hello']).to eq(1)
-      end
-    end
-
-    context 'without api version' do
-      it 'returns legacy hello document without API version' do
-        expect(document['isMaster']).to eq(1)
-      end
-    end
-
-    context 'when connecting to load balancer' do
-
-      let(:document) do
-        subject.handshake_document(metadata, load_balancer: true)
-      end
-
-      it 'includes loadBalanced: true' do
-        document['loadBalanced'].should be true
-      end
+    it 'returns legacy hello document without API version' do
+      meta = Mongo::Server::AppMetadata.new({})
+      document = subject.handshake_document(meta)
+      expect(document['isMaster']).to eq(1)
     end
   end
 end
diff --git a/spec/mongo/server/connection_pool_spec.rb b/spec/mongo/server/connection_pool_spec.rb
index 17f93feac..7d4804f4a 100644
--- a/spec/mongo/server/connection_pool_spec.rb
+++ b/spec/mongo/server/connection_pool_spec.rb
@@ -489,31 +489,13 @@ describe Mongo::Server::ConnectionPool do
 
       context 'when the max size is reached' do
 
-        context 'without service_id' do
-          it 'raises a timeout error' do
-            expect(Mongo::Server::Connection).to receive(:new).once.and_call_original
+        it 'raises a timeout error' do
+          expect(Mongo::Server::Connection).to receive(:new).once.and_call_original
+          expect {
             pool.check_out
-            expect {
-              pool.check_out
-            }.to raise_error(::Timeout::Error)
-            expect(pool.size).to eq(1)
-          end
-        end
-
-        context 'with service_id' do
-          require_topology :load_balanced
-
-          it 'raises a timeout error' do
-            expect(Mongo::Server::Connection).to receive(:new).once.and_call_original
-            connection = pool.check_out
-            pool.check_in(connection)
-            pool.check_out(service_id: connection.service_id)
-            expect {
-              pool.check_out(service_id: connection.service_id)
-            # TODO RUBY-2657 wait for up to the timeout, expect ::Timeout::Error
-            }.to raise_error(Mongo::Error::NoServiceConnectionAvailable)
-            expect(pool.size).to eq(1)
-          end
+            pool.check_out
+          }.to raise_error(::Timeout::Error)
+          expect(pool.size).to eq(1)
         end
       end
     end
diff --git a/spec/mongo/server/connection_spec.rb b/spec/mongo/server/connection_spec.rb
index a95e1e9b7..35c27d3ab 100644
--- a/spec/mongo/server/connection_spec.rb
+++ b/spec/mongo/server/connection_spec.rb
@@ -448,16 +448,8 @@ describe Mongo::Server::Connection do
           )
         end
 
-        let(:exception) do
-          Mongo::Error::SocketError.new.tap do |exc|
-            if server.load_balancer?
-              allow(exc).to receive(:service_id).and_return('fake')
-            end
-          end
-        end
-
         let(:error) do
-          expect_any_instance_of(auth_mechanism).to receive(:login).and_raise(exception)
+          expect_any_instance_of(auth_mechanism).to receive(:login).and_raise(Mongo::Error::SocketError)
           begin
             connection.send(:connect!)
           rescue => ex
@@ -825,10 +817,8 @@ describe Mongo::Server::Connection do
           # of the test, i.e. to avoid racing with the monitor thread
           # which may put the server back into non-unknown state before
           # we can verify that the server was marked unknown, kill off
-          # the monitor thread.
-          unless ClusterConfig.instance.topology == :load_balanced
-            server.monitor.instance_variable_get('@thread').kill
-          end
+          # the monitor thread
+          server.monitor.instance_variable_get('@thread').kill
         end
       end
 
@@ -854,44 +844,27 @@ describe Mongo::Server::Connection do
           expect(connection).to be_error
         end
 
-        context 'in load-balanced topology' do
-          require_topology :load_balanced
-
-          it 'disconnects connection pool for service id' do
-            connection.service_id.should_not be nil
-
-            RSpec::Mocks.with_temporary_scope do
-              expect(server.pool).to receive(:disconnect!).with(service_id: connection.service_id)
-              result
-            end
-          end
-
-          it 'does not mark server unknown' do
-            expect(server).not_to be_unknown
-            result
-            expect(server).not_to be_unknown
-          end
+        it 'disconnects connection pool' do
+          expect(server.pool).to receive(:disconnect!)
+          result
         end
 
-        context 'in non-lb topologies' do
-          require_topology :single, :replica_set, :sharded
-
-          it 'disconnects connection pool' do
-            expect(server.pool).to receive(:disconnect!)
-            result
-          end
-
-          it 'marks server unknown' do
-            expect(server).not_to be_unknown
-            result
-            expect(server).to be_unknown
-          end
+        it 'marks server unknown' do
+          expect(server).not_to be_unknown
+          result
+          expect(server).to be_unknown
         end
 
         it 'does not request server scan' do
           expect(server.scan_semaphore).not_to receive(:signal)
           result
         end
+
+        it 'marks server unknown' do
+          expect(server).not_to be_unknown
+          result
+          expect(server).to be_unknown
+        end
       end
 
       context 'when a socket timeout occurs' do
diff --git a/spec/mongo/server/description_spec.rb b/spec/mongo/server/description_spec.rb
index d0a6a510b..703b181b8 100644
--- a/spec/mongo/server/description_spec.rb
+++ b/spec/mongo/server/description_spec.rb
@@ -331,7 +331,7 @@ describe Mongo::Server::Description do
       describe '#average_round_trip_time' do
 
         let(:description) do
-          described_class.new(address, { 'secondary' => false }, average_round_trip_time: 4.5)
+          described_class.new(address, { 'secondary' => false }, 4.5)
         end
 
         it 'defaults to nil' do
diff --git a/spec/mongo/socket/unix_spec.rb b/spec/mongo/socket/unix_spec.rb
index ea6f8fdf9..4478eb6e4 100644
--- a/spec/mongo/socket/unix_spec.rb
+++ b/spec/mongo/socket/unix_spec.rb
@@ -4,7 +4,6 @@
 require 'spec_helper'
 
 describe Mongo::Socket::Unix do
-  require_unix_socket
 
   let(:path) { "/tmp/mongodb-#{SpecConfig.instance.any_port}.sock" }
 
diff --git a/spec/mongo/uri_option_parsing_spec.rb b/spec/mongo/uri_option_parsing_spec.rb
index bc45f3d7e..a52464f8f 100644
--- a/spec/mongo/uri_option_parsing_spec.rb
+++ b/spec/mongo/uri_option_parsing_spec.rb
@@ -267,52 +267,19 @@ describe Mongo::URI do
 
   context 'connect' do
 
-    let(:client) { new_local_client_nmio(string) }
+    let(:string) { 'mongodb://example.com/?connect=sharded' }
 
-    shared_examples 'raises an error when client is created' do
-      it 'raises an error when client is created' do
-        lambda do
-          client
-        end.should raise_error(ArgumentError, /Invalid :connect option value/)
-      end
-    end
-
-    %i(direct sharded replica_set load_balanced).each do |value|
-      context "#{value}" do
-        let(:string) { "mongodb://example.com/?connect=#{value}" }
-
-        it_behaves_like 'parses successfully'
-
-        it 'is a symbol' do
-          expect(uri.uri_options[:connect]).to eq(value)
-        end
-      end
-    end
-
-    %i(replica-set load-balanced).each do |value|
-      context "#{value}" do
-        let(:string) { "mongodb://example.com/?connect=#{value}" }
-
-        it_behaves_like 'parses successfully'
-
-        it 'is a symbol' do
-          expect(uri.uri_options[:connect]).to eq(value)
-        end
+    it_behaves_like 'parses successfully'
 
-        include_examples 'raises an error when client is created'
-      end
+    it 'is a symbol' do
+      expect(uri.uri_options[:connect]).to eq(:sharded)
     end
 
     context 'invalid value' do
       let(:string) { 'mongodb://example.com/?connect=bogus' }
 
+      # should raise an error
       it_behaves_like 'parses successfully'
-
-      it 'is a symbol' do
-        expect(uri.uri_options[:connect]).to eq(:bogus)
-      end
-
-      include_examples 'raises an error when client is created'
     end
   end
 
diff --git a/spec/runners/connection_string.rb b/spec/runners/connection_string.rb
index a0160a347..56ce5b2ef 100644
--- a/spec/runners/connection_string.rb
+++ b/spec/runners/connection_string.rb
@@ -147,14 +147,10 @@ module Mongo
         end
       end
 
-      def expected_options
+      def options
         @spec['options']
       end
 
-      def non_uri_options
-        @spec['parsed_options']
-      end
-
       def client
         @client ||= ClientRegistry.instance.new_local_client(@spec['uri'], monitoring_io: false)
       rescue Mongo::Error::LintError => e
@@ -311,14 +307,14 @@ def define_connection_string_spec_tests(test_paths, spec_cls = Mongo::Connection
               expect(test.client).to match_auth(test)
             end
 
-            if test.expected_options
+            if test.options
               it 'creates a client with the correct options' do
                 mapped = Mongo::URI::OptionsMapper.new.ruby_to_smc(test.client.options)
                 # Connection string spec tests do not use canonical URI option names
                 actual = Utils.downcase_keys(mapped)
                 actual.delete('authsource')
                 expected = Mongo::ConnectionString.adjust_expected_mongo_client_options(
-                  test.expected_options,
+                  test.options,
                 )
                 actual.should == expected
               end
diff --git a/spec/runners/crud/requirement.rb b/spec/runners/crud/requirement.rb
index 01ca36432..90b92d5a1 100644
--- a/spec/runners/crud/requirement.rb
+++ b/spec/runners/crud/requirement.rb
@@ -27,7 +27,6 @@ module Mongo
               'single' => :single,
               'sharded' => :sharded,
               'sharded-replicaset' => :sharded,
-              'load-balanced' => :load_balanced,
             }[topology].tap do |v|
               unless v
                 raise "Unknown topology #{topology}"
diff --git a/spec/runners/sdam.rb b/spec/runners/sdam.rb
index a881a77a1..275d7a580 100644
--- a/spec/runners/sdam.rb
+++ b/spec/runners/sdam.rb
@@ -37,7 +37,6 @@ module Mongo
           when 'PossiblePrimary' then server.unknown?
           when 'RSGhost' then server.ghost?
           when 'RSOther' then server.other?
-          when 'LoadBalancer' then server.load_balancer?
           else
             raise "Unknown type #{type}"
         end
diff --git a/spec/runners/unified.rb b/spec/runners/unified.rb
index 7990d2d34..225afc0cb 100644
--- a/spec/runners/unified.rb
+++ b/spec/runners/unified.rb
@@ -1,12 +1,12 @@
 # frozen_string_literal: true
 # encoding: utf-8
 
-require 'support/using_hash'
 require 'runners/unified/error'
 require 'runners/unified/entity_map'
 require 'runners/unified/event_subscriber'
 require 'runners/unified/test'
 require 'runners/unified/test_group'
+require 'runners/unified/using_hash'
 
 def define_unified_spec_tests(base_path, paths, expect_failure: false)
   paths.each do |path|
diff --git a/spec/runners/unified/assertions.rb b/spec/runners/unified/assertions.rb
index f903e2ced..98112eb60 100644
--- a/spec/runners/unified/assertions.rb
+++ b/spec/runners/unified/assertions.rb
@@ -4,7 +4,6 @@
 module Unified
 
   module Assertions
-    include RSpec::Matchers
 
     def assert_result_matches(actual, expected)
       if Hash === expected
@@ -87,6 +86,8 @@ module Unified
 
     def assert_document_matches(actual, expected, msg)
       unless actual == expected
+    p actual
+    p expected
         raise Error::ResultMismatch, "#{msg} does not match"
       end
     end
@@ -129,7 +130,7 @@ module Unified
       expected_name = expected_name.sub(/Event$/, '').sub(/^(.)/) { $1.upcase }
       assert_eq(actual.class.name.sub(/.*::/, ''), expected_name, 'Event name does not match')
       if spec.use('hasServiceId')
-        actual.service_id.should_not be nil
+        # TODO: RUBY-2654
       end
       if db_name = spec.use('databaseName')
         assert_eq(actual.database_name, db_name, 'Database names differ')
diff --git a/spec/runners/unified/test.rb b/spec/runners/unified/test.rb
index 69b7f5856..4bac107cb 100644
--- a/spec/runners/unified/test.rb
+++ b/spec/runners/unified/test.rb
@@ -165,9 +165,6 @@ module Unified
           database = entities.get(:database, spec.use!('database'))
           # TODO verify
           opts = Utils.snakeize_hash(spec.use('collectionOptions') || {})
-          if opts.key?(:read_preference)
-            opts[:read] = opts.delete(:read_preference)
-          end
           database[spec.use!('collectionName'), opts]
         when 'bucket'
           database = entities.get(:database, spec.use!('database'))
diff --git a/spec/runners/unified/using_hash.rb b/spec/runners/unified/using_hash.rb
new file mode 100644
index 000000000..4ebf01b4e
--- /dev/null
+++ b/spec/runners/unified/using_hash.rb
@@ -0,0 +1,34 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+module Unified
+
+  class UsingHash < Hash
+    def use(key)
+      wrap(self[key]).tap do
+        delete(key)
+      end
+    end
+
+    def use!(key)
+      wrap(fetch(key)).tap do
+        delete(key)
+      end
+    end
+
+    private
+
+    def wrap(v)
+      case v
+      when Hash
+        self.class[v]
+      when Array
+        v.map do |subv|
+          wrap(subv)
+        end
+      else
+        v
+      end
+    end
+  end
+end
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/direct-connection-false.yml b/spec/spec_tests/data/dns_seedlist_discovery/direct-connection-false.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/direct-connection-false.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/direct-connection-false.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/direct-connection-true.yml b/spec/spec_tests/data/dns_seedlist_discovery/direct-connection-true.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/direct-connection-true.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/direct-connection-true.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/longer-parent-in-return.yml b/spec/spec_tests/data/dns_seedlist_discovery/longer-parent-in-return.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/longer-parent-in-return.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/longer-parent-in-return.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/misformatted-option.yml b/spec/spec_tests/data/dns_seedlist_discovery/misformatted-option.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/misformatted-option.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/misformatted-option.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/no-results.yml b/spec/spec_tests/data/dns_seedlist_discovery/no-results.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/no-results.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/no-results.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/not-enough-parts.yml b/spec/spec_tests/data/dns_seedlist_discovery/not-enough-parts.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/not-enough-parts.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/not-enough-parts.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/one-result-default-port.yml b/spec/spec_tests/data/dns_seedlist_discovery/one-result-default-port.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/one-result-default-port.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/one-result-default-port.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/one-txt-record-multiple-strings.yml b/spec/spec_tests/data/dns_seedlist_discovery/one-txt-record-multiple-strings.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/one-txt-record-multiple-strings.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/one-txt-record-multiple-strings.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/one-txt-record.yml b/spec/spec_tests/data/dns_seedlist_discovery/one-txt-record.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/one-txt-record.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/one-txt-record.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch1.yml b/spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch1.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch1.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch1.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch2.yml b/spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch2.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch2.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch2.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch3.yml b/spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch3.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch3.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch3.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch4.yml b/spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch4.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch4.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch4.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch5.yml b/spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch5.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/parent-part-mismatch5.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/parent-part-mismatch5.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/returned-parent-too-short.yml b/spec/spec_tests/data/dns_seedlist_discovery/returned-parent-too-short.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/returned-parent-too-short.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/returned-parent-too-short.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/returned-parent-wrong.yml b/spec/spec_tests/data/dns_seedlist_discovery/returned-parent-wrong.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/returned-parent-wrong.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/returned-parent-wrong.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/two-results-default-port.yml b/spec/spec_tests/data/dns_seedlist_discovery/two-results-default-port.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/two-results-default-port.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/two-results-default-port.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/two-results-nonstandard-port.yml b/spec/spec_tests/data/dns_seedlist_discovery/two-results-nonstandard-port.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/two-results-nonstandard-port.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/two-results-nonstandard-port.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/two-txt-records.yml b/spec/spec_tests/data/dns_seedlist_discovery/two-txt-records.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/two-txt-records.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/two-txt-records.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-not-allowed-option.yml b/spec/spec_tests/data/dns_seedlist_discovery/txt-record-not-allowed-option.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-not-allowed-option.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/txt-record-not-allowed-option.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-with-overridden-ssl-option.yml b/spec/spec_tests/data/dns_seedlist_discovery/txt-record-with-overridden-ssl-option.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-with-overridden-ssl-option.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/txt-record-with-overridden-ssl-option.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-with-overridden-uri-option.yml b/spec/spec_tests/data/dns_seedlist_discovery/txt-record-with-overridden-uri-option.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-with-overridden-uri-option.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/txt-record-with-overridden-uri-option.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-with-unallowed-option.yml b/spec/spec_tests/data/dns_seedlist_discovery/txt-record-with-unallowed-option.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/txt-record-with-unallowed-option.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/txt-record-with-unallowed-option.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-port.yml b/spec/spec_tests/data/dns_seedlist_discovery/uri-with-port.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-port.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/uri-with-port.yml
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-two-hosts.yml b/spec/spec_tests/data/dns_seedlist_discovery/uri-with-two-hosts.yml
similarity index 100%
rename from spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-two-hosts.yml
rename to spec/spec_tests/data/dns_seedlist_discovery/uri-with-two-hosts.yml
diff --git a/spec/spec_tests/data/load_balancers/lb-connection-establishment.yml b/spec/spec_tests/data/load_balancers/lb-connection-establishment.yml
deleted file mode 100644
index 46e5d781f..000000000
--- a/spec/spec_tests/data/load_balancers/lb-connection-establishment.yml
+++ /dev/null
@@ -1,36 +0,0 @@
-description: connection establishment for load-balanced clusters
-
-schemaVersion: '1.3'
-
-runOnRequirements:
-  - topologies: [ load-balanced ]
-
-createEntities:
-  - client:
-      id: &client0 client0
-      uriOptions:
-        # Explicitly set loadBalanced to false to override the option from the global URI.
-        loadBalanced: false
-      observeEvents:
-        - commandStartedEvent
-  - database:
-      id: &database0 database0
-      client: *client0
-      databaseName: &database0Name database0
-
-tests:
-  - description: operations against load balancers fail if URI contains loadBalanced=false
-    skipReason: servers have not implemented LB support yet so they will not fail the connection handshake in this case
-    operations:
-      - name: runCommand
-        object: *database0
-        arguments:
-          commandName: ping
-          command: { ping: 1 }
-        expectError:
-          isClientError: false
-    expectEvents:
-      # No events should be published because the server fails the connection handshake, so the "ping" command is never
-      # sent.
-      - client: *client0
-        events: []
diff --git a/spec/spec_tests/data/load_balancers/non-lb-connection-establishment.yml b/spec/spec_tests/data/load_balancers/non-lb-connection-establishment.yml
deleted file mode 100644
index e805549ac..000000000
--- a/spec/spec_tests/data/load_balancers/non-lb-connection-establishment.yml
+++ /dev/null
@@ -1,56 +0,0 @@
-description: connection establishment if loadBalanced is specified for non-load balanced clusters
-
-schemaVersion: '1.3'
-
-runOnRequirements:
-  # Don't run on replica sets because the URI used to configure the clients will contain multiple hosts and the
-  # replicaSet option, which will cause an error when constructing the lbTrueClient entity.
-  - topologies: [ single, sharded ]
-
-createEntities:
-  - client:
-      id: &lbTrueClient lbTrueClient
-      # Restrict to a single mongos to ensure there are not multiple hosts in the URI, which would conflict with
-      # loadBalanced=true.
-      useMultipleMongoses: false
-      uriOptions:
-        loadBalanced: true
-  - database:
-      id: &lbTrueDatabase lbTrueDatabase
-      client: *lbTrueClient
-      databaseName: &lbTrueDatabaseName lbTrueDb
-  - client:
-      id: &lbFalseClient lbFalseClient
-      uriOptions:
-        loadBalanced: false
-  - database:
-      id: &lbFalseDatabase lbFalseDatabase
-      client: *lbFalseClient
-      databaseName: &lbFalseDatabaseName lbFalseDb
-
-_yamlAnchors:
-  runCommandArguments:
-    - &pingArguments
-      arguments:
-        commandName: ping
-        command: { ping: 1 }
-
-tests:
-  # These tests assert that drivers behave correctly if loadBalanced=true/false for non-load balanced clusters. Existing
-  # spec tests should cover the case where loadBalanced is unset.
-
-  # If the server is not configured to be behind a load balancer and the URI contains loadBalanced=true, the driver
-  # should error during the connection handshake because the server's hello response does not contain a serviceId field.
-  - description: operations against non-load balanced clusters fail if URI contains loadBalanced=true
-    operations:
-      - name: runCommand
-        object: *lbTrueDatabase
-        <<: *pingArguments
-        expectError:
-          errorContains: Driver attempted to initialize in load balancing mode, but the server does not support this mode
-
-  - description: operations against non-load balanced clusters succeed if URI contains loadBalanced=false
-    operations:
-      - name: runCommand
-        object: *lbFalseDatabase
-        <<: *pingArguments
diff --git a/spec/spec_tests/data/load_balancers/server-selection.yml b/spec/spec_tests/data/load_balancers/server-selection.yml
deleted file mode 100644
index 5c5c9a9a1..000000000
--- a/spec/spec_tests/data/load_balancers/server-selection.yml
+++ /dev/null
@@ -1,50 +0,0 @@
-description: server selection for load-balanced clusters
-
-schemaVersion: '1.3'
-
-runOnRequirements:
-  - topologies: [ load-balanced ]
-
-createEntities:
-  - client:
-      id: &client0 client0
-      useMultipleMongoses: true
-      observeEvents:
-        - commandStartedEvent
-  - database:
-      id: &database0 database0
-      client: *client0
-      databaseName: &database0Name database0Name
-  - collection:
-      id: &collection0 collection0
-      database: *database0
-      collectionName: &collection0Name coll0
-      collectionOptions:
-        readPreference:
-          # Use secondaryPreferred to ensure that operations can succeed even if the shards are only comprised of one
-          # server.
-          mode: &readPrefMode secondaryPreferred
-
-initialData:
-  - collectionName: *collection0Name
-    databaseName: *database0Name
-    documents: []
-
-tests:
-  - description: $readPreference is sent for load-balanced clusters
-    operations:
-      - name: find
-        object: *collection0
-        arguments:
-          filter: {}
-    expectEvents:
-      - client: *client0
-        events:
-          - commandStartedEvent:
-              command:
-                find: *collection0Name
-                filter: {}
-                $readPreference:
-                  mode: *readPrefMode
-              commandName: find
-              databaseName: *database0Name
diff --git a/spec/spec_tests/data/sdam/load-balanced/discover_load_balancer.yml b/spec/spec_tests/data/sdam/load-balanced/discover_load_balancer.yml
deleted file mode 100644
index 20083d98b..000000000
--- a/spec/spec_tests/data/sdam/load-balanced/discover_load_balancer.yml
+++ /dev/null
@@ -1,25 +0,0 @@
-description: "Load balancer can be discovered and only has the address property set"
-
-uri: "mongodb://a/?loadBalanced=true"
-
-phases:
-
-  # There should be no monitoring in LoadBalanced mode, so no responses are necessary to get the topology into the
-  # correct state.
-  - outcome:
-      servers:
-        a:27017:
-          type: LoadBalancer
-          setName: null
-          setVersion: null
-          electionId: null
-          logicalSessionTimeoutMinutes: null
-          minWireVersion: null
-          maxWireVersion: null
-          topologyVersion: null
-      topologyType: LoadBalanced
-      setName: null
-      logicalSessionTimeoutMinutes: null
-      maxSetVersion: null
-      maxElectionId: null
-      compatible: true
diff --git a/spec/spec_tests/data/sdam_integration/find-network-error.yml b/spec/spec_tests/data/sdam_integration/find-network-error.yml
index 85bac6c95..1f505428d 100644
--- a/spec/spec_tests/data/sdam_integration/find-network-error.yml
+++ b/spec/spec_tests/data/sdam_integration/find-network-error.yml
@@ -2,8 +2,6 @@
 runOn:
     # failCommand appName requirements
     - minServerVersion: "4.4"
-      # TODO Remove the line below when load balancer is ready
-      topology: ["replicaset","sharded","single"]
 
 database_name: &database_name "sdam-tests"
 collection_name: &collection_name "find-network-error"
diff --git a/spec/spec_tests/data/sdam_integration/find-shutdown-error.yml b/spec/spec_tests/data/sdam_integration/find-shutdown-error.yml
index 4a1fb6ae2..bf5231373 100644
--- a/spec/spec_tests/data/sdam_integration/find-shutdown-error.yml
+++ b/spec/spec_tests/data/sdam_integration/find-shutdown-error.yml
@@ -2,8 +2,6 @@
 runOn:
     # failCommand appName requirements
     - minServerVersion: "4.4"
-      # TODO Remove the line below when load balancer is ready
-      topology: ["replicaset","sharded","single"]
 
 database_name: &database_name "sdam-tests"
 collection_name: &collection_name "find-shutdown-error"
diff --git a/spec/spec_tests/data/sdam_integration/insert-network-error.yml b/spec/spec_tests/data/sdam_integration/insert-network-error.yml
index 866019939..ddd9f356b 100644
--- a/spec/spec_tests/data/sdam_integration/insert-network-error.yml
+++ b/spec/spec_tests/data/sdam_integration/insert-network-error.yml
@@ -2,8 +2,6 @@
 runOn:
     # failCommand appName requirements
     - minServerVersion: "4.4"
-      # TODO Remove the line below when load balancer is ready
-      topology: ["replicaset","sharded","single"]
 
 database_name: &database_name "sdam-tests"
 collection_name: &collection_name "insert-network-error"
diff --git a/spec/spec_tests/data/sdam_integration/insert-shutdown-error.yml b/spec/spec_tests/data/sdam_integration/insert-shutdown-error.yml
index 426388004..503607a6b 100644
--- a/spec/spec_tests/data/sdam_integration/insert-shutdown-error.yml
+++ b/spec/spec_tests/data/sdam_integration/insert-shutdown-error.yml
@@ -2,8 +2,6 @@
 runOn:
     # failCommand appName requirements
     - minServerVersion: "4.4"
-      # TODO Remove the line below when load balancer is ready
-      topology: ["replicaset","sharded","single"]
 
 database_name: &database_name "sdam-tests"
 collection_name: &collection_name "insert-shutdown-error"
diff --git a/spec/spec_tests/data/sdam_integration/isMaster-command-error.yml b/spec/spec_tests/data/sdam_integration/isMaster-command-error.yml
index 752b33384..8c8c79cee 100644
--- a/spec/spec_tests/data/sdam_integration/isMaster-command-error.yml
+++ b/spec/spec_tests/data/sdam_integration/isMaster-command-error.yml
@@ -2,7 +2,6 @@
 runOn:
     # failCommand appName requirements
     - minServerVersion: "4.4"
-      topology: ["replicaset","sharded","single"]
 
 database_name: &database_name "sdam-tests"
 collection_name: &collection_name "isMaster-command-error"
diff --git a/spec/spec_tests/data/sdam_integration/isMaster-network-error.yml b/spec/spec_tests/data/sdam_integration/isMaster-network-error.yml
index b625d06fa..639e4cda4 100644
--- a/spec/spec_tests/data/sdam_integration/isMaster-network-error.yml
+++ b/spec/spec_tests/data/sdam_integration/isMaster-network-error.yml
@@ -2,7 +2,6 @@
 runOn:
     # failCommand appName requirements
     - minServerVersion: "4.4"
-      topology: ["replicaset","sharded","single"]
 
 database_name: &database_name "sdam-tests"
 collection_name: &collection_name "isMaster-network-error"
diff --git a/spec/spec_tests/data/sdam_integration/isMaster-timeout.yml b/spec/spec_tests/data/sdam_integration/isMaster-timeout.yml
index 61fd51f88..c88cf71fa 100644
--- a/spec/spec_tests/data/sdam_integration/isMaster-timeout.yml
+++ b/spec/spec_tests/data/sdam_integration/isMaster-timeout.yml
@@ -2,7 +2,6 @@
 runOn:
     # failCommand appName requirements
     - minServerVersion: "4.4"
-      topology: ["replicaset","sharded","single"]
 
 database_name: &database_name "sdam-tests"
 collection_name: &collection_name "isMaster-timeout"
diff --git a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-directConnection.yml b/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-directConnection.yml
deleted file mode 100644
index 0c96f352c..000000000
--- a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-directConnection.yml
+++ /dev/null
@@ -1,13 +0,0 @@
-# The TXT record for test20.test.build.10gen.cc contains loadBalanced=true.
-# DRIVERS-1721 introduced this test as passing.
-uri: "mongodb+srv://test20.test.build.10gen.cc/?directConnection=false"
-seeds:
-    - localhost.test.build.10gen.cc:27017
-hosts:
-    # In LB mode, the driver does not do server discovery, so the hostname does
-    # not get resolved to localhost:27017.
-    - localhost.test.build.10gen.cc:27017
-options:
-    loadBalanced: true
-    ssl: true
-    directConnection: false
diff --git a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-replicaSet-errors.yml b/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-replicaSet-errors.yml
deleted file mode 100644
index 208c6a973..000000000
--- a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-replicaSet-errors.yml
+++ /dev/null
@@ -1,6 +0,0 @@
-# The TXT record for test20.test.build.10gen.cc contains loadBalanced=true.
-uri: "mongodb+srv://test20.test.build.10gen.cc/?replicaSet=replset"
-seeds: []
-hosts: []
-error: true
-comment: Should fail because loadBalanced=true is incompatible with replicaSet
diff --git a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-true-multiple-hosts.yml b/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-true-multiple-hosts.yml
deleted file mode 100644
index c8276c1b7..000000000
--- a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-true-multiple-hosts.yml
+++ /dev/null
@@ -1,5 +0,0 @@
-uri: "mongodb+srv://test1.test.build.10gen.cc/?loadBalanced=true"
-seeds: []
-hosts: []
-error: true
-comment: Should fail because loadBalanced is true but the SRV record resolves to multiple hosts
diff --git a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-true-txt.yml b/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-true-txt.yml
deleted file mode 100644
index bbf9e8c59..000000000
--- a/spec/spec_tests/data/seed_list_discovery/load-balanced/loadBalanced-true-txt.yml
+++ /dev/null
@@ -1,10 +0,0 @@
-uri: "mongodb+srv://test20.test.build.10gen.cc/"
-seeds:
-    - localhost.test.build.10gen.cc:27017
-hosts:
-    # In LB mode, the driver does not do server discovery, so the hostname does
-    # not get resolved to localhost:27017.
-    - localhost.test.build.10gen.cc:27017
-options:
-    loadBalanced: true
-    ssl: true
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/encoded-userinfo-and-db.yml b/spec/spec_tests/data/seed_list_discovery/replica-set/encoded-userinfo-and-db.yml
deleted file mode 100644
index c0c6616f4..000000000
--- a/spec/spec_tests/data/seed_list_discovery/replica-set/encoded-userinfo-and-db.yml
+++ /dev/null
@@ -1,15 +0,0 @@
-uri: "mongodb+srv://b*b%40f3tt%3D:%244to%40L8%3DMC@test3.test.build.10gen.cc/mydb%3F?replicaSet=repl0"
-seeds:
-    - localhost.test.build.10gen.cc:27017
-hosts:
-    - localhost:27017
-    - localhost:27018
-    - localhost:27019
-options:
-    replicaSet: repl0
-    ssl: true
-parsed_options:
-    user: "b*b@f3tt="
-    password: "$4to@L8=MC"
-    db: "mydb?"
-comment: Encoded user, pass, and DB parse correctly
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/loadBalanced-false-txt.yml b/spec/spec_tests/data/seed_list_discovery/replica-set/loadBalanced-false-txt.yml
deleted file mode 100644
index 424d19207..000000000
--- a/spec/spec_tests/data/seed_list_discovery/replica-set/loadBalanced-false-txt.yml
+++ /dev/null
@@ -1,10 +0,0 @@
-uri: "mongodb+srv://test21.test.build.10gen.cc/"
-seeds:
-    - localhost.test.build.10gen.cc:27017
-hosts:
-    - localhost:27017
-    - localhost:27018
-    - localhost:27019
-options:
-    loadBalanced: false
-    ssl: true
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-admin-database.yml b/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-admin-database.yml
deleted file mode 100644
index fb714bde0..000000000
--- a/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-admin-database.yml
+++ /dev/null
@@ -1,13 +0,0 @@
-uri: "mongodb+srv://test1.test.build.10gen.cc/adminDB?replicaSet=repl0"
-seeds:
-    - localhost.test.build.10gen.cc:27017
-    - localhost.test.build.10gen.cc:27018
-hosts:
-    - localhost:27017
-    - localhost:27018
-    - localhost:27019
-options:
-    replicaSet: repl0
-    ssl: true
-parsed_options:
-    auth_database: adminDB
diff --git a/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-auth.yml b/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-auth.yml
deleted file mode 100644
index 9ecfca73e..000000000
--- a/spec/spec_tests/data/seed_list_discovery/replica-set/uri-with-auth.yml
+++ /dev/null
@@ -1,12 +0,0 @@
-uri: "mongodb+srv://auser:apass@test1.test.build.10gen.cc/?replicaSet=repl0"
-seeds:
-    - localhost.test.build.10gen.cc:27017
-    - localhost.test.build.10gen.cc:27018
-hosts:
-    - localhost:27017
-    - localhost:27018
-    - localhost:27019
-parsed_options:
-    user: auser
-    password: apass
-comment: Should preserve auth credentials
diff --git a/spec/spec_tests/data/uri_options/connection-options.yml b/spec/spec_tests/data/uri_options/connection-options.yml
index 5f0a914bf..c90b88d74 100644
--- a/spec/spec_tests/data/uri_options/connection-options.yml
+++ b/spec/spec_tests/data/uri_options/connection-options.yml
@@ -147,63 +147,3 @@ tests:
       hosts: ~
       auth: ~
       options: {}
-    -
-      description: loadBalanced=true
-      uri: "mongodb://example.com/?loadBalanced=true"
-      valid: true
-      warning: false
-      hosts: ~
-      auth: ~
-      options:
-          loadBalanced: true
-    -
-      description: loadBalanced=true with directConnection=false
-      uri: "mongodb://example.com/?loadBalanced=true&directConnection=false"
-      valid: true
-      warning: false
-      hosts: ~
-      auth: ~
-      options:
-          loadBalanced: true
-          directConnection: false
-    -
-      description: loadBalanced=false
-      uri: "mongodb://example.com/?loadBalanced=false"
-      valid: true
-      warning: false
-      hosts: ~
-      auth: ~
-      options:
-          loadBalanced: false
-    -
-      description: Invalid loadBalanced value
-      uri: "mongodb://example.com/?loadBalanced=1"
-      valid: true
-      warning: true
-      hosts: ~
-      auth: ~
-      options: {}
-    -
-      description: loadBalanced=true with multiple hosts causes an error
-      uri: "mongodb://example1,example2/?loadBalanced=true"
-      valid: false
-      warning: false
-      hosts: ~
-      auth: ~
-      options: {}
-    -
-      description: loadBalanced=true with directConnection=true causes an error
-      uri: "mongodb://example.com/?loadBalanced=true&directConnection=true"
-      valid: false
-      warning: false
-      hosts: ~
-      auth: ~
-      options: {}
-    -
-      description: loadBalanced=true with replicaSet causes an error
-      uri: "mongodb://example.com/?loadBalanced=true&replicaSet=replset"
-      valid: false
-      warning: false
-      hosts: ~
-      auth: ~
-      options: {}
diff --git a/spec/spec_tests/dns_seedlist_discovery_spec.rb b/spec/spec_tests/dns_seedlist_discovery_spec.rb
new file mode 100644
index 000000000..10fb7527e
--- /dev/null
+++ b/spec/spec_tests/dns_seedlist_discovery_spec.rb
@@ -0,0 +1,79 @@
+# frozen_string_literal: true
+# encoding: utf-8
+
+require 'lite_spec_helper'
+
+require 'runners/connection_string'
+
+describe 'DNS Seedlist Discovery' do
+  require_external_connectivity
+
+  include Mongo::ConnectionString
+
+  DNS_SEEDLIST_DISCOVERY_TESTS.each do |test_path|
+
+    spec = YAML.load(File.read(test_path))
+
+    test = Mongo::ConnectionString::Test.new(spec)
+
+    context(File.basename(test_path)) do
+
+      context 'when the uri is invalid', if: test.raise_error? do
+
+        let(:valid_errors) do
+          [
+            Mongo::Error::InvalidTXTRecord,
+            Mongo::Error::NoSRVRecords,
+            Mongo::Error::InvalidURI,
+            Mongo::Error::MismatchedDomain,
+          ]
+        end
+
+        let(:error) do
+          e = nil
+          begin; test.uri; rescue => ex; e = ex; end
+          e
+        end
+
+        it 'raises an error' do
+          expect(valid_errors).to include(error.class)
+        end
+      end
+
+      context 'when the uri is valid', unless: test.raise_error? do
+
+        it 'does not raise an exception' do
+          expect(test.uri).to be_a(Mongo::URI::SRVProtocol)
+        end
+
+        if test.seeds
+          # DNS seed list tests specify both seeds and hosts.
+          # To get the hosts, the client must do SDAM (as required in the
+          # spec tests' description), but this isn't testing DNS seed list -
+          # it is testing SDAM. Plus, all of the hosts are always the same.
+          # If seed list is given in the expectations, just test the seed
+          # list and not the expanded hosts.
+          it 'creates a client with the correct seeds' do
+            expect(test.client).to have_hosts(test, test.seeds)
+          end
+        else
+          it 'creates a client with the correct hosts' do
+            expect(test.client).to have_hosts(test, test.hosts)
+          end
+        end
+
+        it 'creates a client with the correct options' do
+          mapped = Mongo::URI::OptionsMapper.new.ruby_to_smc(test.client.options)
+          # Connection string spec tests do not use canonical URI option names
+          actual = Utils.downcase_keys(mapped)
+          expected = Utils.downcase_keys(test.options)
+          # SRV tests use ssl URI option instead of tls one
+          if expected.key?('ssl') && !expected.key?('tls')
+            expected['tls'] = expected.delete('ssl')
+          end
+          actual.should == expected
+        end
+      end
+    end
+  end
+end
diff --git a/spec/spec_tests/load_balancers_spec.rb b/spec/spec_tests/load_balancers_spec.rb
deleted file mode 100644
index 0d92e0b2e..000000000
--- a/spec/spec_tests/load_balancers_spec.rb
+++ /dev/null
@@ -1,15 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-require 'spec_helper'
-
-require 'runners/unified'
-
-base = "#{CURRENT_PATH}/spec_tests/data/load_balancers"
-LOAD_BALANCER_TESTS = Dir.glob("#{base}/**/*.yml").sort
-
-describe 'Load balancer spec tests' do
-  require_topology :load_balanced
-
-  define_unified_spec_tests(base, LOAD_BALANCER_TESTS)
-end
diff --git a/spec/spec_tests/sdam_monitoring_spec.rb b/spec/spec_tests/sdam_monitoring_spec.rb
index 71c9bb797..10ad9f990 100644
--- a/spec/spec_tests/sdam_monitoring_spec.rb
+++ b/spec/spec_tests/sdam_monitoring_spec.rb
@@ -68,7 +68,7 @@ describe 'SDAM Monitoring' do
               result['minWireVersion'] ||= 0
               result['maxWireVersion'] ||= 0
               new_description = Mongo::Server::Description.new(
-                server.description.address, result, average_round_trip_time: 0.5)
+                server.description.address, result, 0.5)
               @client.cluster.run_sdam_flow(server.description, new_description)
             end
             @subscriber.phase_finished(phase_index)
diff --git a/spec/spec_tests/sdam_spec.rb b/spec/spec_tests/sdam_spec.rb
index 2c0149b58..6600391b8 100644
--- a/spec/spec_tests/sdam_spec.rb
+++ b/spec/spec_tests/sdam_spec.rb
@@ -98,7 +98,7 @@ describe 'Server Discovery and Monitoring' do
               result['minWireVersion'] ||= 0
               result['maxWireVersion'] ||= 0
               new_description = Mongo::Server::Description.new(
-                server.description.address, result, average_round_trip_time: 0.5)
+                server.description.address, result, 0.5)
               @client.cluster.run_sdam_flow(server.description, new_description)
             end
 
diff --git a/spec/spec_tests/seed_list_discovery_spec.rb b/spec/spec_tests/seed_list_discovery_spec.rb
deleted file mode 100644
index 149c3a295..000000000
--- a/spec/spec_tests/seed_list_discovery_spec.rb
+++ /dev/null
@@ -1,118 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-require 'lite_spec_helper'
-
-require 'support/using_hash'
-require 'runners/connection_string'
-
-SEED_LIST_DISCOVERY_TESTS = Dir.glob("#{CURRENT_PATH}/spec_tests/data/seed_list_discovery/**/*.yml").sort
-
-describe 'DNS Seedlist Discovery' do
-  require_external_connectivity
-
-  include Mongo::ConnectionString
-
-  SEED_LIST_DISCOVERY_TESTS.each do |test_path|
-
-    spec = YAML.load(File.read(test_path))
-
-    test = Mongo::ConnectionString::Test.new(spec)
-
-    context(File.basename(test_path)) do
-
-      if test.raise_error?
-        context 'the uri is invalid' do
-
-          let(:valid_errors) do
-            [
-              Mongo::Error::InvalidTXTRecord,
-              Mongo::Error::NoSRVRecords,
-              Mongo::Error::InvalidURI,
-              Mongo::Error::MismatchedDomain,
-              # This is unfortunate. RUBY-2624
-              ArgumentError,
-            ]
-          end
-
-          let(:error) do
-            begin
-              test.client
-            rescue => ex
-            end
-            ex
-          end
-
-          it 'raises an error' do
-            expect(valid_errors).to include(error.class)
-          end
-        end
-
-      else
-
-        context 'the uri is valid' do
-
-          it 'does not raise an exception' do
-            expect(test.uri).to be_a(Mongo::URI::SRVProtocol)
-          end
-
-          if test.seeds
-            # DNS seed list tests specify both seeds and hosts.
-            # To get the hosts, the client must do SDAM (as required in the
-            # spec tests' description), but this isn't testing DNS seed list -
-            # it is testing SDAM. Plus, all of the hosts are always the same.
-            # If seed list is given in the expectations, just test the seed
-            # list and not the expanded hosts.
-            it 'creates a client with the correct seeds' do
-              expect(test.client).to have_hosts(test, test.seeds)
-            end
-          else
-            it 'creates a client with the correct hosts' do
-              expect(test.client).to have_hosts(test, test.hosts)
-            end
-          end
-
-          if test.expected_options
-            it 'creates a client with the correct uri options' do
-              mapped = Mongo::URI::OptionsMapper.new.ruby_to_smc(test.client.options)
-              # Connection string spec tests do not use canonical URI option names
-              actual = Utils.downcase_keys(mapped)
-              expected = Utils.downcase_keys(test.expected_options)
-              # SRV tests use ssl URI option instead of tls one
-              if expected.key?('ssl') && !expected.key?('tls')
-                expected['tls'] = expected.delete('ssl')
-              end
-              # The client object contains auth source in options which
-              # isn't asserted in some tests.
-              if actual.key?('authsource') && !expected.key?('authsource')
-                actual.delete('authsource')
-              end
-              actual.should == expected
-            end
-          end
-
-          if test.non_uri_options
-            it 'creates a client with the correct non-uri options' do
-              opts = UsingHash[test.non_uri_options]
-              if user = opts.use('user')
-                test.client.options[:user].should == user
-              end
-              if password = opts.use('password')
-                test.client.options[:password].should == password
-              end
-              if db = opts.use('db')
-                test.client.database.name.should == db
-              end
-              if auth_source = opts.use('auth_database')
-                Mongo::Auth::User.new(test.client.options).auth_source == auth_source
-              end
-              unless opts.empty?
-                raise "Unhandled keys: #{opts}"
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/spec/spec_tests/uri_options_spec.rb b/spec/spec_tests/uri_options_spec.rb
index 9e79cf6c9..49eec0781 100644
--- a/spec/spec_tests/uri_options_spec.rb
+++ b/spec/spec_tests/uri_options_spec.rb
@@ -52,8 +52,8 @@ describe 'URI options' do
               expect(test.client).to match_auth(test)
             end
 
-            if opts = test.expected_options
-              if opts['compressors'] && opts['compressors'].include?('snappy')
+            if test.options
+              if test.options['compressors'] && test.options['compressors'].include?('snappy')
                 before do
                   unless ENV.fetch('BUNDLE_GEMFILE', '') =~ /snappy/
                     skip "This test requires snappy compression"
@@ -61,7 +61,7 @@ describe 'URI options' do
                 end
               end
 
-              if opts['compressors'] && opts['compressors'].include?('zstd')
+              if test.options['compressors'] && test.options['compressors'].include?('zstd')
                 before do
                   unless ENV.fetch('BUNDLE_GEMFILE', '') =~ /zstd/
                     skip "This test requires zstd compression"
@@ -72,7 +72,7 @@ describe 'URI options' do
               it 'creates a client with the correct options' do
                 mapped = Mongo::URI::OptionsMapper.new.ruby_to_smc(test.client.options)
                 expected = Mongo::ConnectionString.adjust_expected_mongo_client_options(
-                  opts,
+                  test.options,
                 )
                 mapped.should == expected
               end
diff --git a/spec/support/matchers.rb b/spec/support/matchers.rb
index f14324c20..2ee77790f 100644
--- a/spec/support/matchers.rb
+++ b/spec/support/matchers.rb
@@ -73,16 +73,3 @@ RSpec::Matchers.define :take_shorter_than do |min_expected_time|
     (Time.now - start_time).should < min_expected_time
   end
 end
-
-RSpec::Matchers.define :be_explain_output do
-  match do |actual|
-    Hash === actual && (
-      actual.key?('queryPlanner') ||
-      actual.key?('allPlans')
-    )
-  end
-
-  failure_message do |actual|
-    "expected that #{actual} is explain output: is a hash with either allPlans or queryPlanner keys present"
-  end
-end
diff --git a/spec/support/spec_config.rb b/spec/support/spec_config.rb
index 5e78f4f37..e64eceb0c 100644
--- a/spec/support/spec_config.rb
+++ b/spec/support/spec_config.rb
@@ -15,10 +15,7 @@ class SpecConfig
     if ENV['MONGODB_URI']
       @mongodb_uri = Mongo::URI.new(ENV['MONGODB_URI'])
       @uri_options = Mongo::Options::Mapper.transform_keys_to_symbols(@mongodb_uri.uri_options)
-      if ENV['TOPOLOGY'] == 'load-balanced'
-        @addresses = @mongodb_uri.servers
-        @connect_options = { connect: :load_balanced }
-      elsif @uri_options[:replica_set]
+      if @uri_options[:replica_set]
         @addresses = @mongodb_uri.servers
         @connect_options = { connect: :replica_set, replica_set: @uri_options[:replica_set] }
       elsif @uri_options[:connect] == :sharded || ENV['TOPOLOGY'] == 'sharded-cluster'
@@ -33,6 +30,15 @@ class SpecConfig
       else
         @ssl = @uri_options[:ssl]
       end
+    elsif ENV['MONGODB_ADDRESSES']
+      @addresses = ENV['MONGODB_ADDRESSES'] ? ENV['MONGODB_ADDRESSES'].split(',').freeze : [ '127.0.0.1:27017' ].freeze
+      if ENV['RS_ENABLED']
+        @connect_options = { connect: :replica_set, replica_set: ENV['RS_NAME'] }
+      elsif ENV['SHARDED_ENABLED']
+        @connect_options = { connect: :sharded }
+      else
+        @connect_options = { connect: :direct }
+      end
     end
 
     @uri_tls_options = {}
@@ -628,9 +634,4 @@ EOT
       creds
     end
   end
-
-  # Returns whether the test suite was configured with a single mongos.
-  def single_mongos?
-    %w(1 true yes).include?(ENV['SINGLE_MONGOS'])
-  end
 end
diff --git a/spec/support/using_hash.rb b/spec/support/using_hash.rb
deleted file mode 100644
index 5f9106cb0..000000000
--- a/spec/support/using_hash.rb
+++ /dev/null
@@ -1,31 +0,0 @@
-# frozen_string_literal: true
-# encoding: utf-8
-
-class UsingHash < Hash
-  def use(key)
-    wrap(self[key]).tap do
-      delete(key)
-    end
-  end
-
-  def use!(key)
-    wrap(fetch(key)).tap do
-      delete(key)
-    end
-  end
-
-  private
-
-  def wrap(v)
-    case v
-    when Hash
-      self.class[v]
-    when Array
-      v.map do |subv|
-        wrap(subv)
-      end
-    else
-      v
-    end
-  end
-end
